<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>apache下载zip文件没有content-length</title>
    <url>/2016/07/11/apache-e4-b8-8b-e8-bd-bdzip-e6-96-87-e4-bb-b6-e6-b2-a1-e6-9c-89content-length/</url>
    <content><![CDATA[<p>今天同事下载服务器的zip包，却告诉我找不到zip文件的长度；<br>上网查询之后找到的解决方案如下：<br>打开http.comf文件</p>
<p>方法1：（较生猛，不推荐使用）<br>LoadModule deflate_module modules/mod_deflate.so<br>找到这行代码并注释掉<br>网上找到的这个解决方案不知道别人可不可以，我是不行的，修改过后重启Apache失败，而且对其他应用也有错误，不建议这种方法</p>
<p>方法2：<br>添加下列代码，重启Apache即可<br>SetEnvIfNoCase Request_URI \.(?:gif|jpe?g|png|zip)$ no-gzip dont-vary</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>centos7关闭firewall防火墙并使用iptables</title>
    <url>/2019/05/23/centos7-e5-85-b3-e9-97-adfirewall-e9-98-b2-e7-81-ab-e5-a2-99-e4-b8-8d-e4-bd-bf-e7-94-a8iptables/</url>
    <content><![CDATA[<p>1、关闭firewall防火墙</p>
<pre><code>systemctl stop firewalld</code></pre><p>2、禁止firewall开机启动</p>
<pre><code>systemctl disable firewalld</code></pre><p>3、安装iptables防火墙</p>
<pre><code>yum install -y iptables iptables-services</code></pre><p>4、启动iptables</p>
<pre><code>systemctl start iptables</code></pre><p>5、将iptables加入开机自启动</p>
<pre><code>systemctl enable iptables</code></pre>]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>ab测试</title>
    <url>/2016/10/10/ab-e6-b5-8b-e8-af-95/</url>
    <content><![CDATA[<p>ab -n 100 -c 10 -k <a href="http://www.xupengfei.net/site/index.html" target="_blank" rel="noopener">http://www.xupengfei.net/site/index.html</a> &gt;&gt; D:\wamp\index.txt<br>//模拟10个用户发送100个请求</p>
<p>ab -t 60 -c 10 -k <a href="http://www.xupengfei.net/site/index.html" target="_blank" rel="noopener">http://www.xupengfei.net/site/index.html</a><br>//模拟10个用户在60秒内发送请求</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>apidoc修改生成时间</title>
    <url>/2017/01/11/apidoc-e4-bf-ae-e6-94-b9-e7-94-9f-e6-88-90-e6-97-b6-e9-97-b4/</url>
    <content><![CDATA[<p>找到apidoc安装目录打开apidoc\apidoc\lib\index.js文件<br>找到第104行；或者在文件中搜索Date 替换一下代码：</p>
<p>apidoc.setGeneratorInfos({<br>    name   : json.name,<br>    time   : new Date(),<br>    url    : json.homepage,<br>    version: json.version<br>});</p>
<p>替换为：</p>
<p>var date    =  new Date();<br>apidoc.setGeneratorInfos({<br>    name   : json.name,<br>    time   : date.getFullYear() + “-“ + (date.getMonth() &lt; 10 ? ‘0’ + (date.getMonth()+1) : (date.getMonth()+1)) + “-“ + (date.getDate() &lt; 10 ? ‘0’ + date.getDate() : date.getDate())+ “ “ + date.toLocaleTimeString(),<br>    url    : json.homepage,<br>    version: json.version<br>});</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>centos切换启动方式（桌面和命令行两种方式）</title>
    <url>/2017/01/09/centos-e5-88-87-e6-8d-a2-e5-90-af-e5-8a-a8-e6-96-b9-e5-bc-8f-ef-bc-88-e6-a1-8c-e9-9d-a2-e5-92-8c-e5-91-bd-e4-bb-a4-e8-a1-8c-e4-b8-a4-e7-a7-8d-e6-96-b9-e5-bc-8f-ef-bc-89/</url>
    <content><![CDATA[<p>查看当前启动方式：<br>systemctl get-default</p>
<p>获得结果为两种：<br>multi-user.target    命令行<br>graphical.target     桌面环境</p>
<p>设置启动模式<br>systemctl set-default multi-user.target  设置命令行启动</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>docker安装mysql主从分布</title>
    <url>/2018/01/31/docker-e5-ae-89-e8-a3-85mysql-e4-b8-bb-e4-bb-8e-e5-88-86-e5-b8-83/</url>
    <content><![CDATA[<blockquote>
<p>在centos虚拟机上做的实验</p>
</blockquote>
<h4 id="1、获取mysql镜像"><a href="#1、获取mysql镜像" class="headerlink" title="1、获取mysql镜像"></a>1、获取mysql镜像</h4><pre><code>docker pull mysql:5.7</code></pre><h4 id="2、设置配置文件"><a href="#2、设置配置文件" class="headerlink" title="2、设置配置文件"></a>2、设置配置文件</h4><pre><code>1、主服务器：
新建目录：docker/mysql/master/conf/
新建文件：master.cnf
[mysqld]
server_id = 999  ##mysql服务器的唯一标识，每个都不一样

log-bin = mysql-bin

2、从服务器：
新建目录：docker/mysql/slave01/conf/
新建文件：slave01.cnf
[mysqld]
server_id = 1  ##mysql服务器的唯一标识，每个都不一样

log-bin = mysql-bin</code></pre><h4 id="3、分别创建mysql主从服务器的docker容器"><a href="#3、分别创建mysql主从服务器的docker容器" class="headerlink" title="3、分别创建mysql主从服务器的docker容器"></a>3、分别创建mysql主从服务器的docker容器</h4><pre><code>docker run -p 29001:3306 --name master 
    -v /docker/mysql/master/conf:/etc/mysql/conf.d -v /docker/mysql/master/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7

docker run -p 29002:3306 --name slave01 
    -v /docker/mysql/slave01/conf:/etc/mysql/conf.d -v /docker/mysql/master/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre><h4 id="4、mysql主服务器设置："><a href="#4、mysql主服务器设置：" class="headerlink" title="4、mysql主服务器设置："></a>4、mysql主服务器设置：</h4><pre><code>docker exec -i -t master /bin/bash

mysql -u root -p
//创建一个同步数据的账号
GRANT REPLICATION SLAVE ON *.* to &apos;backup&apos;@&apos;%&apos; identified by &apos;123456&apos;;
//查看状态，记住File、Position的值，在Slaver中将用到
show master status;</code></pre><h4 id="5、mysql从服务器设置："><a href="#5、mysql从服务器设置：" class="headerlink" title="5、mysql从服务器设置："></a>5、mysql从服务器设置：</h4><pre><code>docker exec -i -t slave01 /bin/bash

mysql -u root -p

//设置主库链接
change master to master_host=&apos;192.168.56.101&apos;,master_user=&apos;backup&apos;,
    master_password=&apos;123456&apos;,master_log_file=&apos;mysql-bin.000003&apos;,master_log_pos=154,master_port=29001;

//启动从库同步    
start slave; 

//查看状态  
show slave status\G;</code></pre><p><a href="https://i.loli.net/2018/08/09/5b6bdf61cc82b.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdf61cc82b.png" alt="undefined" title="undefined"></a> 这种情况说明mysql主从同步配置成功</p>
<blockquote>
<p>备注1：</p>
</blockquote>
<p>我一开始总是报错：Slave_IO_Running: Connecting；原因是在设置主库链接时我将ip地址设置为localhost；改为实际ip192.168.56.101即可  </p>
<blockquote>
<p>备注2（从服务器设置）：</p>
</blockquote>
<ol>
<li>master_host：主库地址</li>
<li>master_user：主库创建的同步账号</li>
<li>master_password：主库创建的同步密码</li>
<li>master_log_file：主库产生的日志（File）</li>
<li>master_log_pos：主库日志记录偏移量（Position）</li>
<li>master_port：主库使用的端口，默认为3306；我的是29001</li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>bash on ubuntu安装php开发环境</title>
    <url>/2017/01/05/bash-on-ubuntu-e5-ae-89-e8-a3-85php-e5-bc-80-e5-8f-91-e7-8e-af-e5-a2-83/</url>
    <content><![CDATA[<p>1.进入root权限</p>
<p>sudo su</p>
<p>2.安装php7.1</p>
<p>sudo apt-get install python-software-properties<br>sudo add-apt-repository ppa:ondrej/php<br>sudo apt-get update<br>sudo apt-get install php7.1</p>
<p>3.查询可安装的php模块</p>
<p>apt-cache search php7-*</p>
<p>4.安装nginx</p>
<p>sudo apt-add-repository ppa:nginx/development<br>sudo apt-get update<br>sudo apt-get install nginx</p>
<p>5.修改nginx配置</p>
<p>修改vim /etc/nginx/sites-available/default文件<br>修改内容如下：（修改监听的端口号并注释掉ipv6的监听）<br>listen 8080 default_server;#不需要修改<br>#listen [::]:80 default_server;</p>
<p>修改 /etc/nginx/nginx.conf， 添加配置(添加到第四行)<br>master_process off;</p>
<p>6.卸载nginx</p>
<p>注意：以下卸载方法我并没有验证过</p>
<p>卸载方法1.</p>
<h1 id="删除nginx，保留配置文件"><a href="#删除nginx，保留配置文件" class="headerlink" title="删除nginx，保留配置文件"></a>删除nginx，保留配置文件</h1><p>sudo apt-get remove nginx<br>#删除配置文件<br>rm -rf /etc/nginx<br>卸载方法2.<br>#删除nginx连带配置文件<br>sudo apt-get purge nginx # Removes everything.<br>#卸载不再需要的nginx依赖程序<br>sudo apt-get autoremove</p>
<p>备注：</p>
<ol>
<li>查看window端口占用</li>
</ol>
<p>netstat -ano</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>docker启动容器端口映射报错</title>
    <url>/2018/02/27/docker-e5-90-af-e5-8a-a8-e5-ae-b9-e5-99-a8-e7-ab-af-e5-8f-a3-e6-98-a0-e5-b0-84-e6-8a-a5-e9-94-99/</url>
    <content><![CDATA[<p>错误代码如下：</p>
<p>/usr/bin/docker-current: Error response from daemon:<br>driver failed programming external connectivity on endpoint mysql_master<br>(c7a4d7518ade91a35ffb437b8fda9de7a15dbeb7860b5a41ee7f27c4cc55c54a):<br>iptables failed:<br>iptables –wait -t nat -A DOCKER -p tcp -d 0/0 –dport 29001 -j DNAT<br>–to-destination 172.17.0.3:3306 ! -i docker0: iptables: No chain/target/match by that name.</p>
<p>网上查询的解决方式如下：</p>
<p>pkill docker<br>iptables -t nat -F<br>ifconfig docker0 down<br>brctl delbr docker0<br>docker -d<br>service docker restart</p>
<p>2018.04.10修改：</p>
<p>关闭所有的容器后重启docker即可</p>
<p>systemctl restart docker</p>
<p>参考以下链接：<br><a href="https://github.com/moby/moby/issues/1871" target="_blank" rel="noopener">https://github.com/moby/moby/issues/1871</a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>代码注释</title>
    <url>/2016/03/03/e4-bb-a3-e7-a0-81-e6-b3-a8-e9-87-8a/</url>
    <content><![CDATA[<!--    
                                         MDMN88N    
                                        ODMMDNDNMNN    
                                       M8DMNNMMMNNN    
                                       M7DMID8ZOMNMN    
                                   N8??NODIN7MNIZ?N    
                             Z~==?I7$O78D7NDZ8M8NM    
                   O~+II77?7??8D8OOO8DD8D8N$MOI$=N    
                 :~8D$~~?7Z$7DZZ8DDDNN888N8N88I~$$+~+N    
               M~DD8ZZ8Z$77I$ODNNNNNNN8D8MNN8++?$I?7D8OO+    
              7=NDO88Z7?++?78$7NNDDD88NNDDNDO$8ND8O77Z7??+    
             M+DDOZZ$I+??IZ7?Z8$8$7I8NNDN8D7D$IZ8NDD8$I????    
             Z+N8ZZZIII7$77$ZIOD8$8Z$7777D8DDDOII?IZ$I?I??I    
            ?I+NDZZ77$$ZZOZIIZ88OZ8$II??I?NOI++++++?$$777I7?    
          M==$?NDOZZO888O77$ODOO8Z$$7I???787?++++?==?8Z$7777    
          I~NN7ONDDDDOOOZZO8DDOO8O$$77I??$O7I??????+INNOO$ZI    
          +NNN88DNNNNN7NDNNND888OZZ$$7I??IO77IIIIIIIINNDIODI?    
         +?NIN8DOOOO87NNNMMNND8OOZZ$$77II8O7777777$$7MMNDI?+IZ    
        ?8Z$$NNDOZ$+DOI+$MMND88OZ$$$$$$$ONZ777777$Z$NNO$O?I+I8?M8   ZDDM MN    
       D8O7?IDNN=+NNO$O$DMMNND8OOOOOOO88NNZ$$$$ZZO8DMN8$I$OO$NOII?INZO$N8N7II    
       ~~ND8Z$O?8DNDMDO8MMMNMNDDDD8888D8DND888DD8DNNNNN8O$O8DN8OZZNDOMDNMNNZ7$    
      I7+88ODO?DNM78N?NNONMMNDDDD8OZZZO8OZZZOZ$8ON7N8MDNNMNNNMND8DDDZ8MMZ7DMDD+    
     ?ND$?D$8+OMMNZNO?8DO?MMMMNDNNDDO$OOZ$8ND88DM   O8NNNMNN8NNND88NNMNNNZ$$O8O    
     ?NZNN$DD?NZZZDD7$NOI$7NNMMNND8OZONOZZ8DNN        ODMNNNOO8OO8ONNNNI$ZNDD?=    
     +NNNNDNNOND8N8888Z77O7$OMMNNNNND8NDDDDNO8         8MDMNN8DONMMNMNOD$OODDO    
     IDDDNDNNNDM8OZ8DOOZD7Z7NMMMNDOO$N88DNNNDIN         MMMMNDDDDDNNN8$ZONN7~    
      N8NNDNDNNMNOODNZDND88DMMMMND8O$D8O8DMNMMD?I?N       MNNMMMMMMNMNNO8ZON    
       M8MNNDNDDDNNMZON$ON8MMMMNDNDNNMN888MMMZ8$7+?????      8O88D8OMDNDD8$    
         8NMNNNNNNNDDNN8N8$MMMMMMNMMNMMMMMMM8MDD8Z7?++???    
           M8DNNNDMMMMMNNNNMNMMMMMMMMNNMMMNMDMMMMND8Z7?????    
                 =8MMMNN8ZO$DNMMMMMMMNNMMMMDDDNMMMMMNDO7?+??    
                =IMMMNN8$7I77ONMMMNNNNMMMNNNDZ$7$$Z8NNNDZ7I???    
               O8DNMNNDZ7III78NMMMMMMMMMMMMMMD8Z7II7$O88D8OZI?I7    
              D?NNMMNDO$7II7ZNNMNMMMMMMNNNMMMMMN8$77I7$$ZZO8O8N??    
              OONNNMNDZ7IIII$8DNMMMMMMMDMMMMMMMMNDOZ$7III7$88DII7N    
              +DNNMMN8$777ZDNDDNM        MNMMMMMMMMMMMN888DZOOO7+I    
              7NNNMND8Z$$8NNDDNM                NMMMMMDMMMDDOZD$??D    
             IONNNMND8OODNN8DNM                  :DMMNMMMMDNM8NDZI    
             ~NMMNNDOZOOND88NM                  ~INMNMMMMMMMMNNMZMO    
           D?$8MMMN88ZZ8N88D8                    Z8MDMMNMMMNMMOZ?7?    
        OIII=NMMMMOO88$$NDD8                     ONZMMMMMNNNNMZZ7    
      ~8N788MMNMNDNZIZODN$M                      MMM8DNNDNNDNNDO    
     :8OMNNMMNMMMNMMM$DNND                        +MDMMMDDDDDMD    
      $DMNMMMMMN8O$$8M8M8                         NMNMMMDDNO    
     M$MDMMMMNMMNNN8MMNN                         7NZD8NNNDN    
     MM8MMMMMDMNNNN8DN7                         OMNNDNDZZO?+    
      N8M8MMMMI8DN8Z8$                         ZNNDNNN8$$?++?M    
      OMMNMNNNN7NNDOZO                         NNNDDNNNOI$$?I7OZM    
     DOMMMNN8NNNND8DM                           DMNNNNNNOIZD$7OO$II8    
     ?MNMM8ON8DNDI                                  MDNNN8$$8OD7DIMD    
    ~NNMMMNNDNO7M                                      $NND8$IIID$7I    
    =NMNN8Z7ZZ                                          8NNNNNNDO?I$    
    +8NN8DO$I?                                              N DNNDNM    
   =$NNN8DII++I    
  ?NNNNNONO7?=7    
 DDND8NODZI7Z+I7    
8DN8ON8ZND$NZI?7    
NDNOND$ON87DNN?I    
   NNMNNMZ8MN$I7    
         N   N    
-->]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>docker容器开机自动启动</title>
    <url>/2018/12/07/docker-e5-ae-b9-e5-99-a8-e5-bc-80-e6-9c-ba-e8-87-aa-e5-8a-a8-e5-90-af-e5-8a-a8/</url>
    <content><![CDATA[<p>docker开机启动</p>
<pre><code>chkconfig docker on</code></pre><p>创建容器启动时可使用参数：–restart=always 示例：</p>
<pre><code>docker run xxxxxxx --restart=always</code></pre><p>如果在创建时未使用上述方法的话可使用update参数修改容器 示例：</p>
<pre><code>docker update --restart=always xxx</code></pre>]]></content>
      <categories>
        <category>docker</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>centos7安装composer</title>
    <url>/2017/02/20/centos7-e5-ae-89-e8-a3-85composer/</url>
    <content><![CDATA[<p>1、下载composer文件</p>
<p>curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="noopener">https://getcomposer.org/installer</a> | php</p>
<p>2、可在下载过程中安装；可以通过 –install-dir 选项指定 Composer 的安装目录（它可以是一个绝对或相对路径）</p>
<p>curl -sS <a href="https://getcomposer.org/installer" target="_blank" rel="noopener">https://getcomposer.org/installer</a> | php – –install-dir=lumen</p>
<p>3、运行php composer.phar检查安装状态<br>4、全局使用composer而不是php composer.phar</p>
<p>mv composer.phar /usr/local/bin/composer</p>
<p>现在可以全局使用composer命令了</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>两个时间段判断是否有交叉</title>
    <url>/2018/01/12/e4-b8-a4-e4-b8-aa-e6-97-b6-e9-97-b4-e6-ae-b5-e5-88-a4-e6-96-ad-e6-98-af-e5-90-a6-e6-9c-89-e4-ba-a4-e5-8f-89/</url>
    <content><![CDATA[<p>时间段a,b与时间段c,d 判断这两个时间段之间是否有交叉： <a href="https://i.loli.net/2018/08/09/5b6bdf4030b4c.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdf4030b4c.png" alt="undefined" title="undefined"></a> 由上图可看出； 当a&lt;d&amp;&amp;b&gt;c时；两个时间段必然有交叉</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>原博客数据导出</title>
    <url>/2018/07/26/e5-8e-9f-e5-8d-9a-e5-ae-a2-e6-95-b0-e6-8d-ae-e5-af-bc-e5-87-ba/</url>
    <content><![CDATA[<pre><code>public function index(){
        $xml = &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;rss version=&quot;2.0&quot;
    xmlns:excerpt=&quot;http://wordpress.org/export/1.2/excerpt/&quot;
    xmlns:content=&quot;http://purl.org/rss/1.0/modules/content/&quot;
    xmlns:wfw=&quot;http://wellformedweb.org/CommentAPI/&quot;
    xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;
    xmlns:wp=&quot;http://wordpress.org/export/1.2/&quot;
&gt;

&lt;channel&gt;
    &lt;title&gt;唯物鹰扬&lt;/title&gt;
    &lt;link&gt;http://wordpress.xupengfei.net&lt;/link&gt;
    &lt;description&gt;又一个WordPress站点&lt;/description&gt;
    &lt;pubDate&gt;Thu, 26 Jul 2018 02:16:53 +0000&lt;/pubDate&gt;
    &lt;language&gt;zh-CN&lt;/language&gt;
    &lt;wp:wxr_version&gt;1.2&lt;/wp:wxr_version&gt;
    &lt;wp:base_site_url&gt;http://wordpress.xupengfei.net&lt;/wp:base_site_url&gt;
    &lt;wp:base_blog_url&gt;http://wordpress.xupengfei.net&lt;/wp:base_blog_url&gt;

    &lt;wp:author&gt;&lt;wp:author_id&gt;1&lt;/wp:author_id&gt;&lt;wp:author_login&gt;&lt;![CDATA[admin]]&gt;&lt;/wp:author_login&gt;&lt;wp:author_email&gt;&lt;![CDATA[1121252990@qq.com]]&gt;&lt;/wp:author_email&gt;&lt;wp:author_display_name&gt;&lt;![CDATA[admin]]&gt;&lt;/wp:author_display_name&gt;&lt;wp:author_first_name&gt;&lt;![CDATA[]]&gt;&lt;/wp:author_first_name&gt;&lt;wp:author_last_name&gt;&lt;![CDATA[]]&gt;&lt;/wp:author_last_name&gt;&lt;/wp:author&gt;


    &lt;generator&gt;https://wordpress.org/?v=4.9.7&lt;/generator&gt;&apos;;

        $db = Db::instance(&apos;blog&apos;);
        $data = $db-&gt;select()-&gt;from(&apos;blog&apos;)-&gt;query();

        foreach ($data as $k=&gt;$v){
            $xml .= &apos;&lt;item&gt;&apos;;
            $xml .= &apos;&lt;title&gt;&apos;.$v[&apos;title&apos;].&apos;&lt;/title&gt;&apos;;
            $xml .= &apos;&lt;link&gt; &lt;/link&gt;&apos;;
            $xml .= &apos;&lt;pubDate&gt;&lt;/pubDate&gt;&apos;;
            $xml .= &apos;&lt;dc:creator&gt;&lt;![CDATA[admin]]&gt;&lt;/dc:creator&gt;&apos;;
            $xml .= &apos;&lt;description&gt;&lt;/description&gt;&apos;;
            $xml .= &apos;&lt;content:encoded&gt;&lt;![CDATA[&apos;.$v[&apos;content&apos;].&apos;]]&gt;&lt;/content:encoded&gt;&apos;;
            $xml .= &apos;&lt;excerpt:encoded&gt;&lt;![CDATA[]]&gt;&lt;/excerpt:encoded&gt;&apos;;
            $xml .= &apos;&lt;wp:post_id&gt;&apos;.($k+5).&apos;&lt;/wp:post_id&gt;&apos;;
            $xml .= &apos;&lt;wp:post_date&gt;&lt;![CDATA[&apos;.date(&apos;Y-m-d H:i:s&apos;,$v[&apos;create_time&apos;]).&apos;]]&gt;&lt;/wp:post_date&gt;&apos;;
            $xml .= &apos;&lt;wp:post_date_gmt&gt;&lt;![CDATA[&apos;.date(&apos;Y-m-d H:i:s&apos;,$v[&apos;create_time&apos;]).&apos;]]&gt;&lt;/wp:post_date_gmt&gt;&apos;;
            $xml .= &apos;&lt;wp:comment_status&gt;&lt;![CDATA[open]]&gt;&lt;/wp:comment_status&gt;&apos;;
            $xml .= &apos;&lt;wp:ping_status&gt;&lt;![CDATA[open]]&gt;&lt;/wp:ping_status&gt;&apos;;
            $xml .= &apos;&lt;wp:post_name&gt;&lt;![CDATA[&apos;.$v[&apos;title&apos;].&apos;]]&gt;&lt;/wp:post_name&gt;&apos;;
            $xml .= &apos;&lt;wp:status&gt;&lt;![CDATA[publish]]&gt;&lt;/wp:status&gt;&apos;;
            $xml .= &apos;&lt;wp:post_parent&gt;0&lt;/wp:post_parent&gt;&apos;;
            $xml .= &apos;&lt;wp:menu_order&gt;0&lt;/wp:menu_order&gt;&apos;;
            $xml .= &apos;&lt;wp:post_type&gt;&lt;![CDATA[post]]&gt;&lt;/wp:post_type&gt;&apos;;
            $xml .= &apos;&lt;wp:post_password&gt;&lt;![CDATA[]]&gt;&lt;/wp:post_password&gt;&apos;;
            $xml .= &apos;&lt;wp:is_sticky&gt;0&lt;/wp:is_sticky&gt;&apos;;
            $xml .= &apos;&lt;category domain=&quot;category&quot; nicename=&quot;uncategorized&quot;&gt;&lt;![CDATA[未分类]]&gt;&lt;/category&gt;&apos;;
            $xml .= &apos;&lt;wp:postmeta&gt;&apos;;
            $xml .= &apos;&lt;wp:meta_key&gt;&lt;![CDATA[post_views_count]]&gt;&lt;/wp:meta_key&gt;&apos;;
            $xml .= &apos;&lt;wp:meta_value&gt;&lt;![CDATA[&apos;.$v[&apos;onclicks&apos;].&apos;]]&gt;&lt;/wp:meta_value&gt;&apos;;
            $xml .= &apos;&lt;/wp:postmeta&gt;&apos;;
            $xml .= &apos;&lt;/item&gt;&apos;;
        }

        $xml .= &apos;&lt;/channel&gt;
&lt;/rss&gt;&apos;;
        Http::header(&apos;Content-type: text/xml&apos;);
        return $this-&gt;send($xml);
    }</code></pre>]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>安装grpc</title>
    <url>/2018/09/14/e5-ae-89-e8-a3-85grpc/</url>
    <content><![CDATA[<p>grpc安装方式：</p>
<pre><code>go get google.golang.org/grpc</code></pre><p>使用这个命令会报如下错误</p>
<pre><code>package google.golang.org/grpc: unrecognized import path &quot;google.golang.org/grpc
&quot; (https fetch: Get https://google.golang.org/grpc?go-get=1: dial tcp 119.28.87.
227:443: connectex: A connection attempt failed because the connected party did
not properly respond after a period of time, or established connection failed be
cause connected host has failed to respond.)</code></pre><p>在网上搜索有很多人说是被墙了；但是本人挂了vpn还是报同样的错误； 替代的安装方式如下：</p>
<pre><code>//$GOPATH为你电脑上golang的环境变量；可通过命令“go env”查找

git clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpc

git clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/net

git clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/text

go get -u github.com/golang/protobuf/{proto,protoc-gen-go}

git clone https://github.com/google/go-genproto.git $GOPATH/src/google.golang.org/genproto

cd $GOPATH/src/

go install google.golang.org/grpc</code></pre><p>测试：</p>
<pre><code>cd src\google.golang.org\grpc\examples\helloworld
//运行服务端
go run greeter_server\main.go
//运行客户端
go run greeter_client\main.go</code></pre><p>参考地址： 1. <a href="https://doc.oschina.net/grpc" target="_blank" rel="noopener" title="grpc文档中文版地址">grpc文档中文版地址</a></p>
]]></content>
      <categories>
        <category>golang</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>免费SSL证书Let&#39;s Encrypt(certbot)通配符证书小记</title>
    <url>/2019/05/07/e5-85-8d-e8-b4-b9ssl-e8-af-81-e4-b9-a6lets-encryptcertbot-e9-80-9a-e9-85-8d-e7-ac-a6-e8-af-81-e4-b9-a6-e5-b0-8f-e8-ae-b0/</url>
    <content><![CDATA[<p>使用环境：centos7+nginx 1、安装：</p>
<pre><code>yum install certbot python2-certbot-nginx</code></pre><p>2、创建通配符证书</p>
<pre><code>certbot certonly -d *.example.com -d example.com --manual --preferred-challenges dns --server https://acme-v02.api.letsencrypt.org/directory</code></pre><p>3、自动更新（未测试）</p>
<pre><code>## 通配符证书只支持 DNS 验证方式，官方提供的插件没有针对国内 DNS 服务器的样例，幸好在github上找打一个；
## github地址：https://github.com/ywdblog/certbot-letencrypt-wildcardcertificates-alydns-au

## 申请证书
certbot certonly  -d *.example.com --manual --preferred-challenges dns --manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot;

## 自动更新(加入 crontab)
## 推荐使用gocron来管理定时任务
## github地址：https://github.com/ouqiang/gocron
1 1 1 * 1 root certbot-auto renew --manual --preferred-challenges dns  --manual-auth-hook &quot;/脚本目录/au.sh php aly add&quot; --manual-cleanup-hook &quot;/脚本目录/au.sh php aly clean&quot; 
1 1 2 * 1 root systemctl restart nginx</code></pre><p>​<br>​    </p>
<p>4、nginx配置</p>
<pre><code>server {
  listen 80;
  listen 443 ssl http2;

  ## example.com需要更改为你的地址
  ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;

  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
  ssl_prefer_server_ciphers on;
  ssl_session_timeout 10m;
  ssl_session_cache builtin:1000 shared:SSL:10m;
  ssl_buffer_size 1400;
  add_header Strict-Transport-Security max-age=15768000;
  ssl_stapling on;
  ssl_stapling_verify on;

  ## example.com需要更改为你的地址
  server_name *.example.com;

  access_log off;
  index index.html index.htm index.php;

  ## example.com需要更改为你的地址
  root /data/wwwroot/example.com;
  if ($ssl_protocol = &quot;&quot;) { return 301 https://$host$request_uri; }

  .......
}</code></pre><h2 id="使用acme-sh"><a href="#使用acme-sh" class="headerlink" title="使用acme.sh"></a>使用acme.sh</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装</span><br><span class="line">curl  https:&#x2F;&#x2F;get.acme.sh | sh</span><br><span class="line"></span><br><span class="line">生成</span><br><span class="line">cd ~&#x2F;.acme.sh</span><br><span class="line">export Ali_Key&#x3D;&quot;****&quot;</span><br><span class="line">export Ali_Secret&#x3D;&quot;****&quot;</span><br><span class="line">.&#x2F;acme.sh --issue --dns  dns_ali -d *.example.com</span><br><span class="line">.&#x2F;acme.sh --issue --dns  dns_ali -d *.test.xupengfei.net --install-cert --key-file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;ssl&#x2F;key.pem --fullchain-file &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;ssl&#x2F;cert.pem --reloadcmd &quot;systemctl force-reload nginx&quot; </span><br><span class="line">.&#x2F;acme.sh --issue --dns  dns_ali -d *.test.xupengfei.net --reloadcmd &quot;sudo systemctl force-reload nginx&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序中主动退出程序</title>
    <url>/2018/11/22/e5-be-ae-e4-bf-a1-e5-b0-8f-e7-a8-8b-e5-ba-8f-e4-b8-ad-e4-b8-bb-e5-8a-a8-e9-80-80-e5-87-ba-e7-a8-8b-e5-ba-8f/</url>
    <content><![CDATA[<p>在微信小程序中主动退出程序；比如无网络状态下的处理 以前用的方法如下：</p>
<pre><code>wx.navigateBack({
　　　delta: -1
　　})
}</code></pre><p>但这种方法微信官方回复说这是一个bug，不建议这么做，并且已经修复了这个bug 官方修复这个bug后提供了一个API用户主动退出小程序；如下：</p>
<pre><code>&lt;navigator open-type=&quot;exit&quot; target=&quot;miniProgram&quot;&gt;退出&lt;/navigator&gt;</code></pre><p>参考网址： 1. <a href="https://developers.weixin.qq.com/community/develop/doc/00048c9ed504b02099e660d385b000" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/develop/doc/00048c9ed504b02099e660d385b000</a> 2. <a href="https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/navigator.html</a></p>
]]></content>
      <categories>
        <category>全部文章</category>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序涂鸦功能的实现</title>
    <url>/2018/10/24/e5-be-ae-e4-bf-a1-e5-b0-8f-e7-a8-8b-e5-ba-8f-e6-b6-82-e9-b8-a6-e5-8a-9f-e8-83-bd-e7-9a-84-e5-ae-9e-e7-8e-b0/</url>
    <content><![CDATA[<pre><code>//wxml文件
&lt;view class=&quot;page-body&quot;&gt;
  &lt;view class=&quot;page-body-wrapper&quot;&gt;
    &lt;canvas canvas-id=&quot;canvas&quot; class=&quot;canvas&quot; bindtouchstart=&quot;toachStart&quot; bindtouchmove=&quot;toachMove&quot; bindtouchend=&quot;toachEnd&quot;&gt;&lt;/canvas&gt;
  &lt;/view&gt;
&lt;/view&gt;

//js文件

Page({
  data: {
    radius:10,
    fillColor:&apos;#FFB6C1&apos;,
  },
  onReady: function () {
    console.log(this.colorRgb(this.data.fillColor));
    var context = wx.createCanvasContext(&quot;canvas&quot;, this);
    this.setData({
      context:context
    })
    context.drawImage(&apos;https://imgsa.baidu.com/exp/pic/item/0e655ca7d933c8951b305a6ada1373f082020012.jpg&apos;, 50, 50, 200, 200);
    context.draw();
    context.save();
  },
  toachStart:function(e){
    this.toachMove(e)
  },
  toachMove: function (e) {
    let startX1 = e.changedTouches[0].x
    let startY1 = e.changedTouches[0].y
    let self = this;
    //判断当前涂鸦是否在图片范围内
    wx.canvasGetImageData({
      canvasId: &apos;canvas&apos;,
      x: startX1-self.data.radius,
      y: startY1 - self.data.radius,
      width: this.data.radius*2,
      height: this.data.radius*2,
      success(res) {
        var bool = true;
        for(var i=0;i&lt;res.data.length;i++){
          if(i%4==3){
            if(res.data[i]==0){
              bool = false
            }
          }
        }
        if(bool){
          self.drawHeart(startX1, startY1);

        }
      }
    })


  },
  toachEnd:function(e){
    this.toachMove(e)
  },
  /**
   * 绘制圆形
   */
  drawCir: function (x, y) {
    var context = wx.createCanvasContext(&quot;canvas&quot;, this);
    context.beginPath();//开始一个新的路径  
    context.arc(x, y, this.data.radius, 0, 2 * Math.PI, true);//设置一个原点(x,y)，半径为为radius的圆的路径到当前路径  
    context.setFillStyle(this.data.fillColor)//设置填充色
    // context.setStrokeStyle(this.data.fillColor)
    context.fill();//填充颜色
    // context.stroke();//对当前路径进行描边  
    context.closePath();//关闭当前路径  
    context.draw(true);
  },
  /**
   * 绘制自定义图片
   */
  drawImg:function(pointX,pointY){
    var src = &quot;https://ardownload.kayunzh.com/server/crayon.png&quot;;
    var context = wx.createCanvasContext(&quot;canvas&quot;, this);
    context.drawImage(src, pointX-this.data.radius, pointY-this.data.radius, this.data.radius*2, this.data.radius*2);
    context.draw(true);
  },
  /**
   * 绘制五角星
   */
  drawStar: function (x, y){
    var r = this.data.radius/2;
    var R = this.data.radius;
    var context = wx.createCanvasContext(&quot;canvas&quot;, this);
    context.beginPath();//开始一个新的路径  

    //设置是个顶点的坐标，根据顶点制定路径   
    for (var i = 0; i &lt; 5; i++) {
      context.lineTo(Math.cos((18 + i * 72) / 180 * Math.PI) * R + x, -Math.sin((18 + i * 72) / 180 * Math.PI) * R + y);
      context.lineTo(Math.cos((54 + i * 72) / 180 * Math.PI) * r + x, -Math.sin((54 + i * 72) / 180 * Math.PI) * r + y);
    }

    context.setFillStyle(this.data.fillColor)//设置填充颜色
    context.setStrokeStyle(this.data.fillColor)//设置描边颜色
    context.fill();
    context.stroke();//对当前路径进行描边  
    context.closePath();//关闭当前路径  
    context.draw(true);
  },
  /**
   * 绘制桃心
   */
  drawHeart: function (pointX, pointY) {
    var context = wx.createCanvasContext(&quot;canvas&quot;, this); 
    context.beginPath();//开始一个新的路径 


    context.translate(pointX, pointY);
    // 控制心形大小
    var size = this.data.radius / 20;

    for (let i = 0; i &lt; 30; i++) {
      var step = i / 30 * (Math.PI * 2);//设置心上面两点之间的角度，具体分成多少份，好像需要去试。
      var vector = {
        x: (15 * Math.pow(Math.sin(step), 3))*size,
        y: -(13 * Math.cos(step) - 5 * Math.cos(2 * step) - 2 * Math.cos(3 * step) - Math.cos(4 * step))*size
      }
      context.lineTo(vector.x, vector.y);
    }
    context.setFillStyle(this.data.fillColor)//设置填充颜色
    context.setStrokeStyle(this.data.fillColor)//设置描边颜色
    context.fill();
    context.stroke();//对当前路径进行描边  
    context.closePath();//关闭当前路径  
    context.translate(-pointX, -pointY);
    context.draw(true);

  },
  drawHeart2: function (pointX, pointY) {
    var context = wx.createCanvasContext(&quot;canvas&quot;, this);
    context.beginPath();//开始一个新的路径 


    // 将画布的原点（0,0），移动到(200,200)
    // 移动原点是为了能让整个心形显示出来
    context.translate(pointX, pointY);

    // t 代表弧度
    var t = 0;
    // vt 代表 t 的增量
    var vt = 0.01;
    // maxt 代表 t 的最大值
    var maxt = 2 * Math.PI;
    // 需要循环的次数
    var maxi = Math.ceil(maxt / vt);
    // 保存所有点的坐标的数组
    var pointArr = [];
    // 控制心形大小
    var size = this.data.radius/20;
    // x 用来暂时保存每次循环得到的 x 坐标
    var x = 0;
    // y 用来暂时保存每次循环得到的 y 坐标
    var y = 0;

    // 根据方程得到所有点的坐标
    for (var i = 0; i &lt;= maxi; i++) {
      // x=16 * (sin(t)) ^ 3;
      var x = 16 * Math.pow(Math.sin(t), 3);
      // y=13 * cos(t) - 5 * cos(2 * t) - 2 * cos(3 * t) - cos(4 * t)
      var y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
      t += vt;
      pointArr.push([x * size, -y * size]);
    }

    // 根据点的坐标，画出心形线
    context.moveTo(pointArr[0][0], pointArr[0][1]);
    // 把每个点连接起来
    for (var i = 1; i &lt; pointArr.length; i++) {
      x = pointArr[i][0];
      y = pointArr[i][1];
      context.lineTo(x, y);
    }



    context.setFillStyle(this.data.fillColor)//设置填充颜色
    context.setStrokeStyle(this.data.fillColor)//设置描边颜色
    context.fill();
    context.stroke();//对当前路径进行描边  
    context.closePath();//关闭当前路径  
    context.translate(-pointX, -pointY);
    context.draw(true);
  },
  colorRgb: function (sColor){
    var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;
      if (sColor &amp;&amp; reg.test(sColor)) {
        if (sColor.length === 4) {
          var sColorNew = &quot;#&quot;;
          for (var i = 1; i &lt; 4; i += 1) {
            sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
          }
          sColor = sColorNew;
        }
        //处理六位的颜色值
        var sColorChange = [];
        for (var i = 1; i &lt; 7; i += 2) {
          sColorChange.push(parseInt(&quot;0x&quot; + sColor.slice(i, i + 2)));
        }
        return sColorChange;
        // return &quot;RGB(&quot; + sColorChange.join(&quot;,&quot;) + &quot;)&quot;;
      } else {
        return sColor;
      }
  },

  onUnload: function () {
    clearInterval(this.interval)
  }
})</code></pre>]]></content>
      <categories>
        <category>全部文章</category>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>虚拟机共享文件夹做nginx网站根目录地址</title>
    <url>/2017/02/20/e8-99-9a-e6-8b-9f-e6-9c-ba-e5-85-b1-e4-ba-ab-e6-96-87-e4-bb-b6-e5-a4-b9-e5-81-9anginx-e7-bd-91-e7-ab-99-e6-a0-b9-e7-9b-ae-e5-bd-95-e5-9c-b0-e5-9d-80/</url>
    <content><![CDATA[<p>虚拟机共享文件夹做nginx网站根目录地址（有可能遇到404或No input file specified.错误）<br>进入共享文件夹发现文件夹下所有文件的所属用户组都是vboxsf而且无法更改（我改不了，如果你有办法更改；请告诉我） 解决方案如下</p>
<p>usermod -a -G vboxsf www</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>git服务器搭建</title>
    <url>/2016/12/02/git-e6-9c-8d-e5-8a-a1-e5-99-a8-e6-90-ad-e5-bb-ba/</url>
    <content><![CDATA[<p>在阿里云centos7中安装git服务器<br>1、查看git是否安装</p>
<p>git –version</p>
<p>未安装git的话请自行百度安装</p>
<p>2、查询系统中是否包含git用户  </p>
<p>查看系统中有哪些用户：cut -d : -f 1 /etc/passwd<br>查看哪些可以登录系统的用户：cat /etc/passwd | grep -v /sbin/nologin | cut -d : -f 1</p>
<p>3、包含git用户的话，则删除用户  </p>
<p>userdel -r git<br>注意：删除用户时请使用-r参数，否则下步新建用户时可能会出错</p>
<p>4、新建git用户  </p>
<p>useradd –home /home/git git<br>注意：新建用户时，请确保/home/git文件夹不存在，此命令的意义在于新建git用户并设置git用户的用户主目录</p>
<p>5、设置用户密码：  </p>
<p>passwd git</p>
<p>6、初始化一个空仓库  </p>
<p>cd /home/git<br>git init –bare sample.git</p>
<p>7、将仓库权限改为git用户  </p>
<p>chown -R git:git sample.git<br>注意：请添加-R参数</p>
<p>8、此时，git服务器已经搭建好了；在Windows系统中已经可以使用sourcetree来拉取仓库  </p>
<p>克隆仓库的url地址为：（将ip地址替换为你的git服务器的ip地址）<br><a href="mailto:git@192.168.0.1">git@192.168.0.1</a>:/home/git/sample.git</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云centos7.0开启3306端口和mysql远程连接权限</title>
    <url>/2016/06/21/e9-98-bf-e9-87-8c-e4-ba-91centos7-0-e5-bc-80-e5-90-af3306-e7-ab-af-e5-8f-a3-e5-92-8cmysql-e8-bf-9c-e7-a8-8b-e8-bf-9e-e6-8e-a5-e6-9d-83-e9-99-90/</url>
    <content><![CDATA[<p>开放3306端口：<br>centos7防火墙不是改成firewalld了吗？但我在阿里云centos7.0中却发现它仍然是iptables，所以开放端口还是得用iptable<br>vim /etc/sysconfig/iptables<br>在文件中添加如下代码：<br>-A INPUT -p tcp -m state –state NEW -m tcp –dport 3306 -j ACCEPT</p>
<p>保存后重启iptables<br>systemctl restart iptables.service</p>
<p>开放mysql远程连接权限：  </p>
<p>进入mysql：<br>mysql -uroot -p<br>use mysql;<br>update user set host=’%’ where user=’root’ and host=’localhost’;<br>FLUSH PRIVILEGES;</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>element-ui修改默认样式</title>
    <url>/2018/08/03/element-ui-e4-bf-ae-e6-94-b9-e9-bb-98-e8-ae-a4-e6-a0-b7-e5-bc-8f/</url>
    <content><![CDATA[<p>vue文件分为template、script和style；其中style默认有scoped属性 element-ui 默认的某些样式可能不符合我们的心意；当需要修改时； 新添加一个style，并且这个style不能含有scoped属性；需要注意的是，修改样式时，需要给class添加父元素限制，否则修改的样式就是全局的了 示例：</p>
<pre><code>&lt;style&gt;
  .main-header .el-submenu__title i {
    color: #fff;
  }
  .main-header&gt;.el-menu--horizontal&gt;.el-submenu.is-active .el-submenu__title{
    border-bottom: 0;
  }
&lt;/style&gt;
&lt;style scoped&gt;
  .el-header{
    padding: 0;
    background-color: #3c8dbc;
    color: #ffffff;
  }
&lt;/style&gt;</code></pre>]]></content>
      <categories>
        <category>vue</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>gogs随笔</title>
    <url>/2019/10/11/gogs%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<h4 id="安装gogs"><a href="#安装gogs" class="headerlink" title="安装gogs"></a>安装gogs</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name&#x3D;gogs --restart always --network my_net -v &#x2F;data&#x2F;docker&#x2F;gogs:&#x2F;data gogs&#x2F;gogs</span><br></pre></td></tr></table></figure>

<h4 id="git无密码ssh密钥登录"><a href="#git无密码ssh密钥登录" class="headerlink" title="git无密码ssh密钥登录"></a>git无密码ssh密钥登录</h4><ol>
<li><p>检查本地是否有ssh key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>本地创建ssh key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &lt;your_email@example.com&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在GitHub上添加ssh key（id_rsa.pub）</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>jquery绑定事件到动态添加的元素</title>
    <url>/2016/07/17/jquery-e7-bb-91-e5-ae-9a-e4-ba-8b-e4-bb-b6-e5-88-b0-e5-8a-a8-e6-80-81-e6-b7-bb-e5-8a-a0-e7-9a-84-e5-85-83-e7-b4-a0/</url>
    <content><![CDATA[<p>动态生成html元素<br>$(“.get_img_list”).click(function () {<br>    $(“.img_list_div”).html(‘<div class="myitem"><img src="/2016/07/17/jquery-e7-bb-91-e5-ae-9a-e4-ba-8b-e4-bb-b6-e5-88-b0-e5-8a-a8-e6-80-81-e6-b7-bb-e5-8a-a0-e7-9a-84-e5-85-83-e7-b4-a0/2552.jpeg"></div>‘);<br>});</p>
<p>给动态生成的元素绑定事件<br>$(“.img_list_div”).on(“click”,”.myitem”,function () {<br>    src    =  $(this).children(“img”).attr(“src”);<br>    console.log(src);<br>});</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>html中使用js控制图片的大小</title>
    <url>/2016/06/22/html-e4-b8-ad-e4-bd-bf-e7-94-a8js-e6-8e-a7-e5-88-b6-e5-9b-be-e7-89-87-e7-9a-84-e5-a4-a7-e5-b0-8f/</url>
    <content><![CDATA[<p><img src="/2016/06/22/html-e4-b8-ad-e4-bd-bf-e7-94-a8js-e6-8e-a7-e5-88-b6-e5-9b-be-e7-89-87-e7-9a-84-e5-a4-a7-e5-b0-8f/aaa.jpg" onload="if (this.width>140 || this.height>226) 
if (this.width/this.height>140/226) this.width=140; else this.height=226;"></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>jpush极光推送v3</title>
    <url>/2015/12/22/jpush-e6-9e-81-e5-85-89-e6-8e-a8-e9-80-81v3/</url>
    <content><![CDATA[<p>&lt;?php<br>namespace Home\Controller;<br>use Think\Controller;<br>class Jpush{</p>
<pre><code>private $app_key = &apos;*************&apos;;            //待发送的应用程序(appKey)，只能填一个。
private $master_secret = &apos;************&apos;;        //主密码
private $url = &quot;https://api.jpush.cn/v3/push&quot;;      //推送的地址

//若实例化的时候传入相应的值则按新的相应值进行
public function \_\_construct($app\_key=null, $master_secret=null,$url=null) {
    if ($app\_key) $this-&gt;app\_key = $app_key;
    if ($master\_secret) $this-&gt;master\_secret = $master_secret;
    if ($url) $this-&gt;url = $url;
}

/*  $receiver 接收者的信息
    all 字符串 该产品下面的所有用户. 对app_key下的所有用户推送消息
    tag(20个)Array标签组(并集): tag=&gt;array(&apos;昆明&apos;,&apos;北京&apos;,&apos;曲靖&apos;,&apos;上海&apos;);
    tag\_and(20个)Array标签组(交集): tag\_and=&gt;array(&apos;广州&apos;,&apos;女&apos;);
    alias(1000)Array别名(并集): alias=&gt;array(&apos;93d78b73611d886a74\*\*\*\*\*88497f501&apos;,&apos;606d05090896228f66ae10d1\*\*\*\*\*310&apos;);
    registration\_id(1000)注册ID设备标识(并集): registration\_id=&gt;array(&apos;20effc071de0b45c1a**********2824746e1ff2001bd80308a467d800bed39e&apos;);
*/
//$content 推送的内容。
//$m_type 推送附加字段的类型(可不填) http,tips,chat....
//$m_txt 推送附加字段的类型对应的内容(可不填) 可能是url,可能是一段文字。
//$m_time 保存离线时间的秒数默认为一天(可不传)单位为秒
public function send($receiver=&apos;all&apos;,$content=&apos;&apos;,$title=&apos;&apos;,$extras=&apos;&apos;,$m_time=&apos;86400&apos;){
    $base64=base64\_encode(&quot;$this-&gt;app\_key:$this-&gt;master_secret&quot;);
    $header=array(&quot;Authorization:Basic $base64&quot;,&quot;Content-Type:application/json&quot;);
    $data = array();
    $data\[&apos;platform&apos;\] = &apos;all&apos;;          //目标用户终端手机的平台类型android,ios,winphone
    $data\[&apos;audience&apos;\] = $receiver;      //目标用户

    $data\[&apos;notification&apos;\] = array( 
        //安卓自定义
        &quot;android&quot;=&gt;array(
            &quot;alert&quot;=&gt;$content,
            &quot;title&quot;=&gt;$title,
            &quot;builder_id&quot;=&gt;1,
            &quot;extras&quot;=&gt;$extras
        ),
        //ios的自定义
        &quot;ios&quot;=&gt;array(
             &quot;alert&quot;=&gt;$content,
            &quot;badge&quot;=&gt;&quot;1&quot;,
            &quot;sound&quot;=&gt;&quot;default&quot;,
            &quot;extras&quot;=&gt;$extras
        ),
    );

           //苹果自定义---为了弹出值方便调测
    $data\[&apos;message&apos;\] = array(
        &quot;msg_content&quot;=&gt;$content,
        &quot;extras&quot;=&gt;$extras
    );

    //附加选项
    $data\[&apos;options&apos;\] = array(
        &quot;sendno&quot;=&gt;time(),
        &quot;time\_to\_live&quot;=&gt;$m_time, //保存离线时间的秒数默认为一天
        &quot;apns_production&quot;=&gt;0,        //指定 APNS 通知发送环境：0开发环境，1生产环境。
    );
    $param = json_encode($data);
    $res = $this-&gt;push_curl($param,$header);

    if($res){       //得到返回值--成功已否后面判断
        return $res;
    }else{          //未得到返回值--返回失败
        return false;
    }
}

//推送的Curl方法
public function push_curl($param=&quot;&quot;,$header=&quot;&quot;) {
    if (empty($param)) { return false; }
    $postUrl = $this-&gt;url;
    $curlPost = $param;
    $ch = curl_init();                                      //初始化curl
    curl\_setopt($ch, CURLOPT\_URL,$postUrl);                 //抓取指定网页
    curl\_setopt($ch, CURLOPT\_HEADER, 0);                    //设置header
    curl\_setopt($ch, CURLOPT\_RETURNTRANSFER, 1);            //要求结果为字符串且输出到屏幕上
    curl\_setopt($ch, CURLOPT\_POST, 1);                      //post提交方式
    curl\_setopt($ch, CURLOPT\_POSTFIELDS, $curlPost);
    curl\_setopt($ch, CURLOPT\_HTTPHEADER,$header);           // 增加 HTTP Header（头）里的字段 
    curl\_setopt($ch, CURLOPT\_SSL_VERIFYPEER, FALSE);        // 终止从服务端进行验证
    curl\_setopt($ch, CURLOPT\_SSL_VERIFYHOST, FALSE);
    $data = curl_exec($ch);                                 //运行curl
    curl_close($ch);
    return $data;
}</code></pre><p>}<br>class PushController extends Controller{<br>    public function v3_ceshi($alias,$title,$msg,$data){<br>        if(!defined(‘appkeys’))define(‘appkeys’,’<strong>****</strong>‘);    //appkey值 极光portal上面提供<br>        if(!defined(‘masterSecret’))define(‘masterSecret’,’<strong><strong>**</strong></strong>‘);    //API MasterSecert值 极光portal上面提供<br>        if(empty($data)){<br>            $data   =   array(‘type’=&gt;’1’);<br>        }<br>        //require_once(‘./push_v3.php’);<br>        $obj = new jpush(appkeys,masterSecret);<br>        $user=array(<br>            ‘alias’=&gt;array($alias),<br>            //“registration_id”=&gt;array(“060e0db78e8”,),<br>        );<br>        $res=json_decode($obj-&gt;send($user,$msg,$title,$data));<br>//      to_json($res);<br>    }<br>}</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>jquery绑定click执行多次</title>
    <url>/2017/01/17/jquery-e7-bb-91-e5-ae-9aclick-e6-89-a7-e8-a1-8c-e5-a4-9a-e6-ac-a1/</url>
    <content><![CDATA[<p>用jquery绑定一个按钮click事件后，第一次点击后，一切正常，第二次点击，竟然执行两次，以后越来越多  </p>
<p>$(“”).click(function(){<br>    <strong><strong><strong><strong>***</strong></strong></strong></strong><br>    <strong><strong><strong><strong>***</strong></strong></strong></strong><br>    $(“”).unbind(‘click’);//在click事件执行函数中最后解除click事件的绑定<br>});</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>git相关操作</title>
    <url>/2016/11/14/git-e7-9b-b8-e5-85-b3-e6-93-8d-e4-bd-9c/</url>
    <content><![CDATA[<p>git 拉取master分支<br>git fetch origin master<br>git pull origin master</p>
<p>git推送master分支<br>git push origin master</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>js动态添加html内容，不修改已添加的数据</title>
    <url>/2015/12/13/js-e5-8a-a8-e6-80-81-e6-b7-bb-e5-8a-a0html-e5-86-85-e5-ae-b9-ef-bc-8c-e4-b8-8d-e4-bf-ae-e6-94-b9-e5-b7-b2-e6-b7-bb-e5-8a-a0-e7-9a-84-e6-95-b0-e6-8d-ae/</url>
    <content><![CDATA[<p>1、今天准备做一个api验证的页面，在js上遇到这样一个问题： <a href="https://i.loli.net/2018/08/09/5b6bdc4b7875d.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdc4b7875d.png" alt="undefined" title="undefined"></a> 如图：当点击添加参数后，需要动态的添加一栏参数输入框，一开始我用代码是这样的：</p>
<p>document.getElementById(‘params’).innerHTML=inner+’<div class="form-group"><label class="col-sm-2 control-label" style="padding-top: 5px;"></label><div class="col-sm-5"><input name="param\[\]" maxlength="300" class="form-control" placeholder="参数名"></div><div class="col-sm-5"><input name="value\[\]" maxlength="300" class="form-control" placeholder="参数值"></div></div>‘;</p>
<p>但是这样写的话会遇上一个问题，比如说，已经输入一栏参数数据了，但发现栏数不够，需要新增一栏，但点击添加参数后以前添加的参数数据就消失了。后台经过百度后，找到这样一种做法，js可以实现动态的添加html数据且不修改已添加html内容的数据：</p>
<p>var div = document.createElement(“div”);<br>div.innerHTML = ‘<div class="form-group"><label class="col-sm-2 control-label" style="padding-top: 5px;"></label><div class="col-sm-5"><input name="param\[\]" maxlength="300" class="form-control" placeholder="参数名"></div><div class="col-sm-5"><input name="value\[\]" maxlength="300" class="form-control" placeholder="参数值"></div></div>‘;<br>document.getElementById(‘params’).appendChild(div);</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>js生成随机数</title>
    <url>/2016/07/03/js-e7-94-9f-e6-88-90-e9-9a-8f-e6-9c-ba-e6-95-b0/</url>
    <content><![CDATA[<p>var chars = [‘0’,’1’,’2’,’3’,’4’,’5’,’6’,’7’,’8’,’9’,’A’,’B’,’C’,’D’,’E’,’F’,’G’,’H’,’I’,’J’,’K’,’L’,’M’,’N’,’O’,’P’,’Q’,’R’,’S’,’T’,’U’,’V’,’W’,’X’,’Y’,’Z’];</p>
<p>function generateMixed(n) {<br>     var res = “”;<br>     for(var i = 0; i &lt; n ; i ++) {<br>         var id = Math.ceil(Math.random()*35);<br>         res += chars[id];<br>     }<br>     return res;<br>}<br>num =   generateMixed(24);</p>
<p>如上所示，num便是生成的24位随机数</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>js截取字符串substring</title>
    <url>/2016/07/23/js-e6-88-aa-e5-8f-96-e5-ad-97-e7-ac-a6-e4-b8-b2substring/</url>
    <content><![CDATA[<p>var str  =   ‘1001000010’;<br>console.log(str.substr(0,4),str.substr(4,10));</p>
<p>如上述代码在执行后输出的结果是： 1001 000010<br>注意，参数stop的数字一定是要提取字符串最后一个字符的下标+1<br><a href="https://i.loli.net/2018/08/09/5b6bde1927f50.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bde1927f50.png" alt="undefined" title="undefined"></a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>mysql数据库查询去除重复</title>
    <url>/2016/06/24/mysql-e6-95-b0-e6-8d-ae-e5-ba-93-e6-9f-a5-e8-af-a2-e5-8e-bb-e9-99-a4-e9-87-8d-e5-a4-8d/</url>
    <content><![CDATA[<p><a href="https://i.loli.net/2018/08/09/5b6bddace2785.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bddace2785.png" alt="undefined" title="undefined"></a> 表中数据如上如所示， 要求查询出来的结果是： <a href="https://i.loli.net/2018/08/09/5b6bddbcbf86f.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bddbcbf86f.png" alt="undefined" title="undefined"></a> 第一步，查询出title相等的name</p>
<p>SELECT * FROM ceshi  GROUP BY name HAVING count(DISTINCT(title)) =1</p>
<p>其中函数DISTINCT是去重复函数，按name分组并且去完重复的title只有一条的说明该name所拥有的title都相同 第二步，查出name的所有数据</p>
<p>方法1：<br>SELECT *FROM ceshi where name in(SELECT `name` FROM ceshi  GROUP BY name HAVING count(DISTINCT(title)) =1 );</p>
<p>方法2：<br>SELECT A.* from (SELECT * FROM ceshi  GROUP BY name HAVING count(DISTINCT(title)) =1) as A LEFT JOIN ceshi AS B on A.name=B.name;</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>Linux定时任务自动备份MySQL数据库</title>
    <url>/2016/04/20/linux-e5-ae-9a-e6-97-b6-e4-bb-bb-e5-8a-a1-e8-87-aa-e5-8a-a8-e5-a4-87-e4-bb-bdmysql-e6-95-b0-e6-8d-ae-e5-ba-93/</url>
    <content><![CDATA[<p>1、新建文件夹back 2、使用vi编辑文件back.sh（注：不要在Windows系统中创建再上传，若使用Windows系统创建上传，请在Linux中使用vi打开并使用:set ff=unix） 3、编辑back.sh</p>
<p>mysqldump -uusername -ppassword DatabaseName | gzip &gt; /home/backup/DatabaseName_$(date +%Y%m%d_%H%M%S).sql.gz</p>
<p>把username、password和DatabaseName替换为实际的用户名、密码和数据库名称<br>4、给back.sh增加755权限。 5、执行该文件，测试能否使用 6、crontab -e编辑定时任务</p>
<p>*/1 * * * * /home/backup/bkDatabaseName.sh</p>
<p>上述代码为每分钟执行一次，可自行百度定时任务修改</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>js验证输入框是否为金钱（保留两位小数）</title>
    <url>/2016/07/11/js-e9-aa-8c-e8-af-81-e8-be-93-e5-85-a5-e6-a1-86-e6-98-af-e5-90-a6-e4-b8-ba-e9-87-91-e9-92-b1-ef-bc-88-e4-bf-9d-e7-95-99-e4-b8-a4-e4-bd-8d-e5-b0-8f-e6-95-b0-ef-bc-89/</url>
    <content><![CDATA[<p>//验证input标签输入的是否是金钱的数量（两位小数）<br>function clearNoNum(obj){<br>obj.value = obj.value.replace(/[^\d.]/g,””); //清除”数字”和”.”以外的字符<br>obj.value = obj.value.replace(/^\./g,””); //验证第一个字符是数字而不是<br>obj.value = obj.value.replace(/\.{2,}/g,”.”); //只保留第一个. 清除多余的<br>obj.value = obj.value.replace(“.”,”$#$”).replace(/\./g,””).replace(“$#$”,”.”);<br>obj.value = obj.value.replace(/^(\-)<em>(\d+)\.(\d\d).</em>$/,’$1$2.$3’); //只能输入两个小数<br>}<br><input id="packagefee" type="text" value="1" placeholder="请输入包装费" onkeyup="clearNoNum(this)" onblur="clearNoNum(this)"></p>
<p>ps:2016年10月21日更新 今天我女朋友对我说这个方法有点问题： 输入金钱并验证成功后，input失去焦点后；再重新获得焦点，这时去修改金钱中间数字的时候，输入第一个数字后光标焦点会自动跳转到金钱的最后，所以重新写了一下这个方法，特此更新</p>
<pre><code>    function clearNoNum(obj){
    value= obj.value.replace(/\[^\\d.\]/g,&quot;&quot;); //清除&quot;数字&quot;和&quot;.&quot;以外的字符
    if(obj.value!==value){
        obj.value   =   value;
    }
    value = obj.value.replace(/^\\./g,&quot;&quot;); //验证第一个字符是数字而不是
    if(obj.value!==value){
        obj.value   =   value;
    }
    value = obj.value.replace(/\\.{2,}/g,&quot;.&quot;); //只保留第一个. 清除多余的
        if(obj.value!==value){
    obj.value   =   value;
    }
    value = obj.value.replace(&quot;.&quot;,&quot;$#$&quot;).replace(/\\./g,&quot;&quot;).replace(&quot;$#$&quot;,&quot;.&quot;);
        if(obj.value!==value){
    obj.value   =   value;
    }
    value = obj.value.replace(/^(\\-)*(\\d+)\\.(\\d\\d).*$/,&apos;$1$2.$3&apos;); //只能输入两个小数
        if(obj.value!==value){
    obj.value   =   value;
    }
}</code></pre><p>备注： 这个方法也有问题： （1）如果输入的格式正确，光标不会跳转，但输入格式错误的话，光标还是会跳转到最后; （2）在原来小数点前加新小数点的话会将原小数点及小数点后数字删除<br>具体解决方案还没想到，想到了再更新 替换方案： 用户输入错误的话不将错误删除，而是返回错误提示信息即可</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>php获取某一文件下所有的文件名</title>
    <url>/2017/06/13/php-e8-8e-b7-e5-8f-96-e6-9f-90-e4-b8-80-e6-96-87-e4-bb-b6-e4-b8-8b-e6-89-80-e6-9c-89-e7-9a-84-e6-96-87-e4-bb-b6-e5-90-8d/</url>
    <content><![CDATA[<p>private function getDir($dir,$type=’’){<br>    $data = [];<br>    if (is_dir($dir)){<br>        if ($dh = opendir($dir)){<br>            while (($file=readdir($dh))!==false){<br>                if ($file!==’.’&amp;&amp;$file!==’..’){<br>                    if (is_dir($dir.’/‘.$file)){<br>                        $data[$file] = $this-&gt;getDir($dir.’/‘.$file);<br>                    }<br>                }<br>                if (is_file($dir.’/‘.$file)){<br>                    if ($type){<br>                        array_push($data,basename($file,’.png’));<br>                    }else{<br>                        array_push($data,basename($file));<br>                    }<br>                }</p>
<pre><code>        }
        closedir($dh);
    }
}
return $data;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>微信网页调试清除手机微信网页缓存</title>
    <url>/2017/01/16/e5-be-ae-e4-bf-a1-e7-bd-91-e9-a1-b5-e8-b0-83-e8-af-95-e6-b8-85-e9-99-a4-e6-89-8b-e6-9c-ba-e5-be-ae-e4-bf-a1-e7-bd-91-e9-a1-b5-e7-bc-93-e5-ad-98/</url>
    <content><![CDATA[<p>在微信打开地址：</p>
<p><a href="http://debugx5.qq.com/" target="_blank" rel="noopener">http://debugx5.qq.com/</a></p>
<p><a href="https://i.loli.net/2018/08/09/5b6bdf0626934.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdf0626934.png" alt="undefined" title="undefined"></a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>nginx使用https并做反向代理</title>
    <url>/2017/01/02/nginx-e4-bd-bf-e7-94-a8https-e5-b9-b6-e5-81-9a-e5-8f-8d-e5-90-91-e4-bb-a3-e7-90-86/</url>
    <content><![CDATA[<p>1、HTTPS证书可使用阿里云CAS免费证书；申请流程请自行摸索；这里假设你已经申请通过并下载好相关文件了<br>2、将下载的文件放入nginx安装目录中<br>3、nginx配置文件代码如下：</p>
<p>server {<br>  listen 443 ssl http2 default_server;<br>  server_name proxy.nasus.top;<br>  access_log /data/wwwlogs/proxy.nasus.top_nginx.log combined;</p>
<p>  ssl_certificate   cert/213989507530612.pem;#下载的证书文件<br>  ssl_certificate_key  cert/213989507530612.key;#下载的证书文件<br>  ssl_session_timeout 5m;<br>  ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<br>  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>  ssl_prefer_server_ciphers on;</p>
<p>  location / {<br>    proxy_pass <a href="http://127.0.0.1:8282;#反向代理地址">http://127.0.0.1:8282;#反向代理地址</a><br>    proxy_set_header X-Real-IP $remote_addr;<br>    proxy_set_header Host $host;<br>    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>    proxy_http_version 1.1;<br>    proxy_set_header Upgrade $http_upgrade;<br>    proxy_set_header Connection “upgrade”;<br>    rewrite /(.<em>) /$1 break;<br>    proxy_redirect off;<br>  }<br>}<br>server {<br>  listen 80;<br>  server_name proxy.nasus.top;<br>  rewrite ^(.</em>) https://$server_name$1 permanent;<br>}</p>
<p>4、负载均衡即是反向代理的一种应用<br>在配置文件的最前面加上如下代码：</p>
<p>upstream monitor_server {<br>  server 192.168.0.131:80;<br>  server 192.168.0.132:80;<br>}</p>
<p>修改server中的反向代理地址为：</p>
<p>proxy_pass <a href="http://monitor\_server;#反向代理地址" target="_blank" rel="noopener">http://monitor\_server;#反向代理地址</a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs安装</title>
    <url>/2017/01/10/nodejs-e5-ae-89-e8-a3-85/</url>
    <content><![CDATA[<p>1、安装nvm</p>
<p>curl -o- <a href="https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/creationix/nvm/v0.29.0/install.sh</a> | bash</p>
<p>2、nvm相关操作</p>
<p>nvm –version    查看nvm版本信息</p>
<p>nvm ls-remote    查看可安装的nodejs版本</p>
<p>nvm ls           查看已安装的nodejs版本</p>
<p>nvm install v6.9.4 安装nodejs6.9.4版本</p>
<p>nvm use v4.4.5   使用v4.4.5版本的nodejs</p>
<p>nvm alias default v6.3.0  设置v6.3.0为系统默认nodejs版本</p>
<p>nvm uninstall v4.4.5  卸载v4.4.5版本nodejs</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>PHP设计模式</title>
    <url>/2018/07/26/php-e8-ae-be-e8-ae-a1-e6-a8-a1-e5-bc-8f/</url>
    <content><![CDATA[<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><blockquote>
<p>适配器设计模式只是将某个对象的接口适配为另一个对象所期望的接口</p>
</blockquote>
<p>基类-》对象引用基类 适配器adapter继承基类，并实现新方法-》对象引用adapter类 例如；基类有设置和获取名称两个方法，现在需要活动名称的长度；这时新建一个adapter类继承基类，并实现新方法获取长度</p>
<pre><code>//设置名称并打印
class GetName{
    private $name;
    public function getName(){
        return $this-&gt;name;
    }
    public function setName($name){
        $this-&gt;name = $name;
    }
}


$user = new GetName();
$user-&gt;setName(&apos;adapter&apos;);
var_dump($user-&gt;getName());


//新需求，要打印名称的长度
class GetNameApater extends GetName{
    public function __construct(){
        parent::__contruct();
    }
    public function getNameLength(){
        return strlen($this-&gt;name);
    }
}
$user = new GetName();
$user-&gt;setName(&apos;adapter&apos;);
var_dump($user-&gt;getName());
var_dump($user-&gt;getNameLength());</code></pre><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote>
<p>建造者设计模式定义了处理其他对象的复杂构建的对象设计</p>
</blockquote>
<p>初始化对象时需要设置多个默认值或调用其他方法时</p>
<blockquote>
<p>建造者设计模式的目的是为了消除其他对象的复杂创建过程。使用建造者设计模式可以在某个对象的构造和配置方法改变时尽可能的减少重复更改代码</p>
</blockquote>
<pre><code>//初始化一个产品类
class product{
    protected $type;
    protected $num;
    protected $name;
    public function setType($type){
        $this-&gt;type = $type;
    }
    public function setNum($num){
        $this-&gt;num = $num;
    }
    public function setName($name){
        $this-&gt;name = $name;
    }
}
//使用方式
$product = new product();
$product-&gt;setType(&apos;type&apos;);
$product-&gt;setNum(10);
$product-&gt;setName(&apos;name&apos;);


//建造者模式
class productBuilder{
    protected $_product = NULL;
    protected $_configs = [];
    public function __construct($config){
        $this-&gt;_product = new product();
        $this-&gt;_configs = $config;
    }
    public function build(){
        $this-&gt;_product-&gt;setType($this-&gt;_configs[&apos;type&apos;]);
        $this-&gt;_product-&gt;setNum($this-&gt;_configs[&apos;num&apos;]);
        $this-&gt;_product-&gt;setName($this-&gt;_configs[&apos;name&apos;]);
    }
    public function getProduct(){
        return $this-&gt;_product;
    }
}

$builder = new productBuilder($configs);
$builder-&gt;build();
$product = $builder-&gt;getProduct();</code></pre><h3 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h3><blockquote>
<p>数据访问对象设计模式描述了如何创建提供透明访问任何数据源的对象 为了减少重复和抽象化数据，最好的方法是基于数据访问对象创建一个类</p>
</blockquote>
<pre><code>abstract class baseDAO{
    private $_connection;
    public function __construct(){
        $this-&gt;_connectDB(DB_USER,DB_PASS,DB_HOST,DB_DATABASE);
    }
    public function _connectDB($user,$pass,$host,$db){
        $this-&gt;_connection = mysql_connect($host,$user,$pass);
        mysql_select_db($db,$this-&gt;_connection);
    }
    public function fetch($value,$key = NULL){
        if(is_null($key)){
            $key = $this-&gt;_primaryKey;
        }
        $sql = &quot;select * from {$this-&gt;_tableName} where {$key}=&apos;{$value}&apos;&quot;;
        $results = mysql_query($sql,$this-&gt;_connection);

        $rows = [];
        while($result = mysql_fetch_array($results)){
            $rows[] = $result;
        }
        return $rows;
    }
    public function update($keyArray){
        $sql = &quot;update {$this-&gt;_tableName} set &quot;;
        $updates = [];
        foreach($keyArray as $column=&gt;$value){
            $updates[] = &quot;{$column}=&apos;{$value}&apos; &quot;;
        }
        $sql .= implode(&apos;,&apos;,$updates);
        $sql .= &quot;where {$this-&gt;_primaryKey}=&apos;{$keyArray[$this-&gt;_primaryKey]}&apos;&quot;
    }
}


class userDAO extends baseDAO{
    protected $_tableName = &apos;userTable&apos;;
    protected $_primaryKey = &apos;id&apos;;
    public function getUserByFirstName($name){
        $result = $this-&gt;fetch($name,&apos;firstname&apos;);
        return $result;
    }
}


define(&apos;DB_USER&apos;,&apos;user&apos;);
define(&apos;DB_PASS&apos;,&apos;pass&apos;);
define(&apos;DB_HOST&apos;,&apos;localhost&apos;);
define(&apos;DB_DATABASE&apos;,&apos;test&apos;);

$user = new userDAO();

$userDetailsArray = $user-&gt;fetch(1);

$updates = [&apos;id&apos; =&gt;  1,&apos;firstName&apos; =&gt; &apos;test&apos;];
$user-&gt;update($updates);

$allTestUser = $user-&gt;getUserByFirstName(&apos;test&apos;);</code></pre><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><blockquote>
<p>如果已有对象的部分内容或功能性发生改变，但是不需要修改原始对象的结构，那么使用装饰器设计模式最合适 当引入的需求要求在不影响现有基本代码稳定性的前提下对应用程序的内容或功能性进行很小的改动时，最好的做法就是创建装饰器对象</p>
</blockquote>
<pre><code>class CD{
    public $trackList;
    public function __construct(){
        $this-&gt;trackList = [];
    }
    public function addTrack($track){
        $this-&gt;trackList[] = $track;
    }
    public function getTrackList(){
        $output = &apos;&apos;;
        foreach($this-&gt;trackList as $num=&gt;$track){
            $output .= ($num+1).&quot;) {$track}. &quot;;
        }
        return $output;
    }
}

$tracksFromExternalSource = [&apos;What It Means&apos;,&apos;Brr&apos;,&apos;Goodbye&apos;];

$myCD = new CD();

foreach($tracksFromExternalSource as $track){
    $myCD-&gt;addTrack($track);
}

print &quot;The CD contains&quot;.$myCD-&gt;getTrackList();

//更改需求，要求输出的内容全部大写

class CDTrackListDecoratorCaps{
    private $_cd;
    public function __construct(CD $cd){
        $this-&gt;_cd = $cd;
    }
    public function makeCaps(){
        foreach($this-&gt;_cd-&gt;trackList as &amp;$strack){
            $track = strtoupper($track);
        }
    }
}

$myCD = new CD();

foreach($tracksFromExternalSource as $track){
    $myCD-&gt;addTrack($track);
}

$myCDCaps = new CDTrackListDecoratorCaps($myCD);
$myCDCaps-&gt;makeCaps();

print &quot;The CD contains the following tracks: &quot;.$myCD-&gt;getTrackList();</code></pre><h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><blockquote>
<p>通过分配或委托至其他对象，委托设计模式能够去除核心对象中的判决和复杂的功能性</p>
</blockquote>
<pre><code>class Playlist{
    private $_songs;
    public function __construct(){
        $this-&gt;_songs = [];
    }

    public function addSong($location,$title){
        $song = [&apos;location&apos;=&gt;$location,&apos;title&apos;=&gt;$title];
        $this-&gt;_songs[] = $song;
    }

    public function getM3U(){
        $m3u = &quot;#EXTM#U\n\n&quot;;

        foreach($this-&gt;_songs as $song){
            $m3u .= &quot;#EXTINF:-1,{$song[&apos;title&apos;]}\n&quot;;
            $m3u .= &quot;{$song[&apos;location&apos;]}\n&quot;;
        }

        return $m3u;
    }

    public function getPLS(){
        $pls = &quot;[playlist]\nNumberOfEntries=&quot;.count($this-&gt;_songs).&quot;\n\n&quot;;

        foreach($this-&gt;_songs as $songCount =&gt; $song){
            $counter = $songCount + 1;
            $pls .= &quot;File{$counter}={$song[&apos;location&apos;]}\n&quot;;
            $pls .= &quot;Length{$counter}=-1\n\n&quot;;
        }

        return $pls;

    }

}

$playlist = new Playlist();
$playlist-&gt;addSong(&apos;/home/music/brr.mp3&apos;,&apos;Brr&apos;);
$playlist-&gt;addSong(&apos;/home/music/goodbye.mp3&apos;,&apos;Goodbye&apos;);

if($externalRetrievedType == &apos;pls&apos;){
    $playlistCountent = $playlist-&gt;getPLS();
}else{
    $playlistCountent = $playlist-&gt;getM3U();
}


//使用委托模式

class newPlaylist{
    private $_songs;
    private $_typeObject;

    public function __construct($type){
        $this-&gt;_songs = [];
        $object = &quot;{$type}Playlist&quot;;
        $this-&gt;_typeObject = new $object;
    }
    public function addSong($location,$title){
        $song = [&apos;location&apos;=&gt;$location,&apos;title&apos;=&gt;$title];
        $this-&gt;_songs[] = $song;
    }
    public function getPlaylist(){
        $playlist = $this-&gt;_typeObject-&gt;getPlaylist($this-&gt;_songs);
        return $playlist;
    }
}

class m3uPlaylistDelegate{
    public function getPlaylist($songs){
        $m3u = &quot;#EXTM3U\n\n&quot;;

        foreach($songs as $song){
            $m3u .= &quot;#EXTINF:-1,{$song[&apos;title&apos;]}\n&quot;;
            $m3u .= &quot;{$song[&apos;location&apos;]}\n&quot;;
        }

        return $m3u;
    }
}

class plsPlaylistDelegate{
    public function getPlaylist($songs){
        $pls = &quot;[playlist]\nNumberOfEntries=&quot;.count($songs).&quot;\n\n&quot;;

        foreach($songs as $songCount =&gt; $song){
            $counter = $songCount + 1;
            $pls .= &quot;File{$counter}={$song[&apos;location&apos;]}\n&quot;;
            $pls .= &quot;Length{$counter}=-1\n\n&quot;;
        }

        return $pls;
    }
}

$externalRetrievedType = &apos;pls&apos;;
$playlist = new newPlaylist($externalRetrievedType);
$playlistCountent = $playlist-&gt;getPlaylist();</code></pre><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><blockquote>
<p>通过在必须的逻辑和方法的集合前创建简单的外观接口，外观设计模式隐藏了来自调用对象的复杂性 在程序中包含许多复杂的逻辑步骤和方法调用时，最佳的做法是创建一个机遇外观设计模式的对象</p>
</blockquote>
<pre><code>class CD{
    public $tracks = [];
    public $band = &apos;&apos;;
    public $title = &apos;&apos;;

    public function __construct($title,$band,$tracks){
        $this-&gt;title = $title,
        $this-&gt;band = $band;
        $this-&gt;tracks = $tracks
    }
}

$tracksFromExternalSource = [&apos;What It Means&apos;,&apos;Brr&apos;,&apos;Goodbye&apos;];
$title = &apos;Waste of a Rib&apos;;
$band = &apos;Never Again&apos;;

$cd = new CD($title,$band,$tracksFromExternalSource);

//使用外观模式

class CDUpperCase{
    public static function makeString(CD $cd){
        $cd-&gt;$type = strtoupper($cd-&gt;type);
    }
    public static function makeArray(CD $cd,$type){
        $cd-&gt;$type = array_map(&apos;strtoupper&apos;,$cd-&gt;$type);
    }
}
class CDMakeXML{
    public static function create(CD $cd){
        $doc = new DomDocument();

        $root = $doc-&gt;createElement(&apos;CD&apos;);
        $root = $doc-&gt;appendChild($root);

        $title = $doc-&gt;createElement(&apos;TITLE&apos;,$cd-&gt;title);
        $title = $root-&gt;appendChild($title);

        $band = $doc-&gt;createElement(&apos;BAND&apos;,$cd-&gt;band);
        $band = $root-&gt;appendChild($band);

        $tracks = $doc-&gt;createElement(&apos;TRACKS&apos;);
        $tracks = $root-&gt;appendChild($tracks);

        foreach($cd-&gt;tracks as $track){
            $track = $doc-&gt;createElement(&apos;TRACK&apos;,$track);
            $track = $tracks-&gt;appendChild($track);
        }

        return $doc-&gt;saveXML();
    }
}
//错误的使用方式
CDUpperCase::makeString($cd,&apos;title&apos;);
CDUpperCase::makeString($cd,&apos;band&apos;);
CDUpperCase::makeArray($cd,&apos;tracks&apos;);

print CDMakeXML::create($cd);

//正确的使用方式
class WebServiceFacade{
    public static function makeXMLCall(CD $cd){
        CDUpperCase::makeString($cd,&apos;title&apos;);
        CDUpperCase::makeString($cd,&apos;band&apos;);
        CDUpperCase::makeArray($cd,&apos;tracks&apos;);

        $xml = CDMakeXML::create($cd);
        return $xml;
    }
}

print WebServiceFacade::makeXMLCall($cd);</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><blockquote>
<p>工厂设计模式提供获取某个对象的新实例的一个接口，同时使调用代码避免确定实际实例化基类的步骤</p>
</blockquote>
<pre><code>//第一种类型的CD
class CD{
    public $title = &apos;&apos;;
    public $band = &apos;&apos;;
    public $tracks = [];

    public function __construct(){}

    public function setTitle($title){
        $this-&gt;title = $title;
    }
    public function setBand($band){
        $this-&gt;band = $band;
    }
    public function addTrack($track){
        $this-&gt;tracks[] = $track;
    }
}

//初始化方式
$tracksFromExternalSource = [&apos;What It Means&apos;,&apos;Brr&apos;,&apos;Goodbye&apos;];
$title = &apos;Waste of a Rib&apos;;
$band = &apos;Never Again&apos;;

$cd = new CD();
$cd-&gt;setTitle($title);
$cd-&gt;setBand($band);
foreach($tracksFromExternalSource as $track){
    $cd-&gt;addTrack($track);
}


//第二种类型的CD
class enhancedCD{
    public $title = &apos;&apos;;
    public $band = &apos;&apos;;
    public $tracks = [];

    public function __construct(){
        $this-&gt;tracks[] = &apos;DATA TRACK&apos;;
    }
    public function setTitle($title){
        $this-&gt;title = $title;
    }
    public function setBand($band){
        $this-&gt;band = $band;
    }
    public function addTrack($track){
        $this-&gt;tracks[] = $track;
    }
}

//用户工厂模式
class CDFactory{
    public static function create($type){
        $class = strtolower($type).&quot;CD&quot;;
        return new $class;
    }
}

$type = &apos;enhanced&apos;;

$cd = CDFactory::create($type);
$cd-&gt;setTitle($title);
$cd-&gt;setBand($band);
foreach($tracksFromExternalSource as $track){
    $cd-&gt;addTrack($track);
}</code></pre><h3 id="解释器模式-没懂"><a href="#解释器模式-没懂" class="headerlink" title="解释器模式 (没懂)"></a>解释器模式 (没懂)</h3><blockquote>
<p>解释器设计模式用于分析一个实体的关键元素，并且针对每个原色都提供自己的解释或相应的动作</p>
</blockquote>
<pre><code>class User{
    protected $_username = &apos;&apos;;
    public function __construct($username){
        $this-&gt;_username = $username;
    }
    public function getProfilePage(){
        $profile = &quot;&lt;h2&gt;I like Nerve Again!&lt;/h2&gt;&quot;;
        $profile .= &quot;I love all of their songs. My favorite CD:&lt;br /&gt;&quot;;
        $profile .= &quot;{ {myCD.getTitle}}&quot;;

        return $profile;
    }
}

class userCD{
    protected $_user = NULL;
    public function setUser($user){
        $this-&gt;_user = $user;
    }
    public function getTitle(){
        $title = &apos;Waste of a Rib&apos;;
        return $title;
    }
}

class userCDInterpreter{
    protected $_user = NULL;
    public function setUser($user){
        $this-&gt;_user = $user;
    }
    public function getInterpreted(){
        $prefile = $this-&gt;_user-&gt;getProfilePage();
        if(preg_match_all(&apos;/\{\{myCD\.(.*?)\}\}/&apos;,$profile,$triggers,PREG_SET_ORDER)){
            $replacements = [];

            foreach($triggers as $trigger){
                $replacements[] = $trigger[1];
            }

            $replacements = array_unique($replacements);

            $myCD = new userCD();
            $myCD-&gt;setUser($this-&gt;_user);

            foreach($replacements as $replacement){
                $profile = str_replace(&quot;{ {myCD.{$replacement}}}&quot;,call_user_func([$myCD,$replacement],$profile));
            }
        }
        return $profile;
    }
}

$username = &apos;test_name&apos;;

$user = new User($username);
$interpreter = new userCDInterpreter();
$interpreter-&gt;setUser($user);

print &quot;&lt;h1&gt;{$username}&apos;s Profile&lt;/h1&gt;&quot;;
print $interpreter-&gt;getInterpreted();</code></pre><h3 id="迭代器模式-（不懂）"><a href="#迭代器模式-（不懂）" class="headerlink" title="迭代器模式 （不懂）"></a>迭代器模式 （不懂）</h3><blockquote>
<p>迭代器设计模式可帮助构造特定对象，那些对象能够提供单一标准接口循环或迭代任何类型的可计数数据</p>
</blockquote>
<pre><code>class CD{
    public $band = &apos;&apos;;
    public $title = &apos;&apos;;
    public $trackList = [];

    public function __construct($band,$title){
        $this-&gt;band = $band;
        $this-&gt;title = $title;
    }

    public function addTrack($track){
        $this-&gt;trackList[] = $track;
    }
}

//迭代器类
class CDSearchByBandIterator implements Iterator{
    private $_CDs = [];
    private $_valid = FALSE;

    public function __construct($bandName){
        $db = mysql_connect(&apos;localhost&apos;,&apos;user&apos;,&apos;pass&apos;);
        mysql_select_db(&apos;test&apos;);

        $sql = &quot;select CD.id,CD.band,CD.title,tracks.tracknum, &quot;;
        $sql .= &quot;tracks.title as tracktitle &quot;;
        $sql .= &quot;from CD left join tracks on CD.id=tracks.cid where band=&apos;&quot;;
        $sql .= mysql_real_escape_string($bandName);
        $sql .= &quot;&apos; order by tracks.tracknum&quot;;
        $results = mysql_query($sql);

        $cdID = 0;
        $cd = NULL;

        while($result = mysql_fetch_array($results)){
            if($result[&apos;id&apos;] !== $cdID){
                if(!is_null($cd)){
                    $this-&gt;_CDs[] = $cd;
                }
                $cdID = $result[&apos;id&apos;];
                $cd = new CD($result[&apos;band&apos;],$result[&apos;title&apos;]);
            }
            $cd-&gt;addTrack($result[&apos;tracktitle&apos;]);
        }
        $this-&gt;_CDs[] = $cd;
    }
    public function next(){
        $this-&gt;_valid = (next($this-&gt;_CDs)===FALSE)?FALSE:TRUE;
    }
    public function rewind(){
        $this-&gt;_valid = (reset($this-&gt;_CDs)===FALSE)?FALSE:TRUE;
    }
    public function valid(){
        return $this-&gt;_valid;
    }
    public function current(){
        return current($this-&gt;CDs);
    }
    public function key(){
        return key($this-&gt;CDs);
    }
}</code></pre><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><blockquote>
<p>中介者设计模式用于开发一个对象，这个对象能够在类似对象相互之间不直接交互的情况下传送或调解对这些对象的集合的修改 处理具有类似属性并且属性需要保持同步的非耦合对象时，最佳的做法是使用基于中介者设计模式的对象</p>
</blockquote>
<pre><code>class CD{
    public $band = &apos;&apos;;
    public $title = &apos;&apos;;

    public function save(){
        var_dump($this);
    }

    public function changeBandName($newName){
        $this-&gt;band = $newName;
        $this-&gt;save();
    }
}

//中介者模式

class CD{
    public $band = &apos;&apos;;
    public $title = &apos;&apos;;
    protected $_mediator;

    public function __construct($mediator=null){
        $this-&gt;_mediator = $mediator;
    }
    public function save(){
        var_dump($this);
    }

    public function changeBandName($newName){
        if(!is_null($this-&gt;_mediator)){
            $this-&gt;_mediator-&gt;change($this,[&apos;band&apos;=&gt;$newName]);
        }
        $this-&gt;band = $newName;
        $this-&gt;save();
    }
}

class MP3Archive{
    public $band = &apos;&apos;;
    public $title = &apos;&apos;;
    protected $_mediator;

    public function __construct($mediator=null){
        $this-&gt;_mediator = $mediator;
    }

    public function save(){
        var_dump($this);
    }

    public function changeBandName($newName){
        if(!is_null($this-&gt;_mediator)){
            $this-&gt;_mediator-&gt;change($this,[&apos;band&apos;=&gt;$newName]);
        }
        $this-&gt;band = $newName;
        $this-&gt;save();
    }


}

class MusicContrainerMediator{
    protected $_containers = [];

    public function __construct(){
        $this-&gt;_containers[] = &apos;CD&apos;;
        $this-&gt;_containers[] = &apos;MP3Archive&apos;;
    }

    public function change($originalObject,$newValue){
        $title = $originalObject-&gt;title;
        $band = $originalObject-&gt;band;

        foreach($this-&gt;_containers as $container){
            if(!($changedObject instanceof $container)){
                $object = new $container;
                $object-&gt;title = $title;
                $object-&gt;band = $band;

                foreach($newValue as $key=&gt;$val){
                    $object-&gt;$key = $val;
                }

                $object-&gt;save();
            }
        }
    }
}

$titleFromDB = &apos;Waste of a Rib&apos;;
$bandFromDB = &apos;Never Again&apos;;

$mediator = new MusicContainerMediator();

$cd = new CD($mediator);
$cd-&gt;title = $titleFromDB;
$cd-&gt;band = $bandFromDB;

$cd-&gt;changeBandName(&apos;Maybe Once More&apos;);</code></pre><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><blockquote>
<p>观察者设计模式能够更便利地创建查看目标对象状态的对象，并且提供与核心对象非耦合的指定功能性</p>
</blockquote>
<pre><code>class CD{
    public $title = &apos;&apos;;
    public $band = &apos;&apos;;
    protected $_observers = [];

    public function __construct($title,$band){
        $this-&gt;title = $title;
        $this-&gt;band = $band;
    }

    public function attachObserver($type,$observer){
        $this-&gt;_observers[$type][] = $observer;
    }

    public function notifyObserver($type){
        if(isset($this-&gt;_observers[$type])){
            foreach($this-&gt;_observers[$type] as $observer){
                $observer-&gt;update($this);
            }
        }
    }

    public function buy(){
        $this-&gt;notifyObserver(&apos;purchased&apos;);
    }
}

class buyCDNotifyStreamObserver{
    public function update(CD $cd){
        $activity = &quot;The CD names {$cd-&gt;title} by &quot;;
        $activity .= &quot;{$cd-&gt;band} was just purchased. &quot;;
        activityStream::addNewItem($activity);
    }
}

class activityStream{
    public static function addNewItem($item){
        print $item;
    }
}

$title = &apos;Waste of a Rib&apos;;
$band = &apos;Never Again&apos;;
$cd = new CD($title,$band);

$observer = new buyCDNotifyStreamObserver();

$cd-&gt;attachObserver(&apos;purchased&apos;,$observer);
$cd-&gt;buy();</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><blockquote>
<p>原型设计模式创建对象的方式是赋值和克隆初始对象或原型，这种方式比创建新实例更为有效</p>
</blockquote>
<pre><code>class CD{
    public $band = &apos;&apos;;
    public $title = &apos;&apos;;
    public $trackList = [];

    public function __construct($id){
        $handle = mysql_connect(&apos;localhost&apos;,&apos;user&apos;,&apos;pass&apos;);
        mysql_select_db(&apos;CD&apos;,$handle);

        $query = &quot;select band,title from CDS where id = {$id}&quot;;

        $results = mysql_query($query,$handle);

        if($row = mysql_fetch_assoc($results)){
            $this-&gt;band = $row[&apos;band&apos;];
            $this-&gt;title = $row[&apos;title&apos;];
        }
    }

    public function buy(){
        var_dump($this);
    }
}

class MixtapeCD extends CD{
    public function __clone(){
        $this-&gt;title = &apos;Mixtape&apos;;
    }
}

$externalPurchaseInfoBandID = 12;
$bandMixProto = new MixtapeCD($externalPurchaseInfoBandID);

$externalPurchaseInfo = [];
$externalPurchaseInfo[] = [&apos;brrr&apos;,&apos;goodbye&apos;];
$externalPurchaseInfo[] = [&apos;what it means&apos;,&apos;brrr&apos;];

foreach($externalPurchaseInfo as $mixed){
    $cd = clone $bandMixProto;
    $cd-&gt;trackList = $mixed;
    $cd-&gt;buy();
}</code></pre><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><blockquote>
<p>代理设计模式构建了透明置于两个不同对象之内的一个对象，从而能够截取或代理这两个对象间的通信或访问</p>
</blockquote>
<pre><code>class CD{
    protected $_title = &apos;&apos;;
    protected $_band = &apos;&apos;;
    protected $_handle = null;

    public function __construct($title,$band){
        $this-&gt;_title = $title;
        $this-&gt;_band = $band;
    }
    public function buy(){
        $this-&gt;_connect();

        $query = &quot;update CDs set bought=1 where band=&apos;&quot;;
        $query .= mysql_real_escape_string($this-&gt;_band,$this-&gt;_handle);
        $query .= &quot; &apos;and title=&apos; &quot;;
        $query .= mysql_real_escape_string($this-&gt;_title,$this-&gt;_handle);
        $query .= &quot;&apos;&quot;;

        mysql_query($query,$this-&gt;_handle);
    }
    protected function _connect(){
        $this-&gt;_handle = mysql_connect(&apos;localhost&apos;,&apos;user&apos;,&apos;pass&apos;);
        mysql_select_db(&apos;CD&apos;,$this-&gt;_handle);
    }
}

$externalTitle = &apos;Waste of a Rib&apos;;
$externalBand = &apos;Never Again&apos;;

$cd = new CD($externalTitle,$externalBand);
$cd-&gt;buy();

//代理

class DallasNOCCDProxy extends CD{
    protected function _connect(){
        $this-&gt;_handle = mysql_connect(&apos;dallas&apos;,&apos;user&apos;,&apos;pass&apos;);
        mysql_select_db(&apos;CD&apos;);
    }
}

$externalTitle = &apos;Waste of a Rib&apos;;
$externalBand = &apos;Never Again&apos;;

$cd = new DallasNOCCDProxy($externalTitle,$externalBand);
$cd-&gt;buy();</code></pre><h3 id="单元素模式"><a href="#单元素模式" class="headerlink" title="单元素模式"></a>单元素模式</h3><blockquote>
<p>通过提供对自身共享实例的访问，单元素设计模式用于限制特定对象只能被创建一次</p>
</blockquote>
<pre><code>class InventoryConnection{
    protected static $_instance = NULL;
    protected $_handle = NULL;

    public static function getInstance(){
        if(!self::$_instance instanceof self){
            self::$_instance = new self;
        }
        return self::$_instance;
    }

    protected function __construct(){
        $this-&gt;_handle = mysql_connect(&apos;localhost&apos;,&apos;user&apos;,&apos;pass&apos;);
        mysql_select_db(&apos;CD&apos;,$this-&gt;_handle);
    }

    public function updateQuantity($band,$title,$number){
        $query = &quot;update CDs set amount=amount+&quot;.intval($number);
        $query .= &quot; where band=&apos;&quot;.mysql_real_escape_string($band).&quot;&apos;&quot;;
        $query .= &quot; and title=&apos;&quot;.mysql_real_excape_string($title).&quot;&apos;&quot;;

        mysql_query($query,$this-&gt;_handle);
    }
}

class CD{
    protected $_title = &apos;&apos;;
    protected $_band = &apos;&apos;;

    public function __construct($title,$band){
        $this-&gt;_title = $title;
        $this-&gt;_band = $band;
    }

    public function buy(){
        $inventory = InventoryConnection::getInstance();
        $inventory-&gt;updateQuantity($this-&gt;_band,$this-&gt;_title,-1);
    }
}

$boughtCDs = [];
$boughtCDs[] = [&apos;band&apos;=&gt;&apos;Never Again&apos;,&apos;Waste of a Rib&apos;];
$boughtCDs[] = [&apos;band&apos;=&gt;&apos;Therapee&apos;,&apos;Long Road&apos;];

foreach($boughtCDs as $boughtCD){
    $cd = new CD($boughtCD[&apos;title&apos;],$boughtCD[&apos;band&apos;]);
    $cd-&gt;buy();
}</code></pre><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><blockquote>
<p>策略设计模式帮助构建的对象不必自身包含逻辑，而是能够根据需要利用其它对象中的算法</p>
</blockquote>
<pre><code>class CD{
    public $title = &apos;&apos;;
    public $band = &apos;&apos;;
    public function __construct($title,$band){
        $this-&gt;title = $title;
        $this-&gt;band = $band;
    }
    public function getAsXML(){
        $doc = new DomDocument();
        $root = $doc-&gt;createElement(&apos;CD&apos;);
        $root = $doc-&gt;appendChild($root);
        $title = $doc-&gt;createElement(&apos;TITLE&apos;,$this-&gt;title);
        $title = $root-&gt;appendChild($title);
        $band = $doc-&gt;createElement(&apos;BAND&apos;,$this-&gt;band);
        $band = $root-&gt;appendChild($band);

        return $doc-&gt;saveXML();
    }
}

$externalBand = &apos;Never Again&apos;;
$externalTitle = &apos;Waste of a Rib&apos;;

$cd = new CD($externalTitle,$externalBand);

print $cd-&gt;getAsXML();

//策略模式
class CDusesStrategy{
    public $title = &apos;&apos;;
    public $band = &apos;&apos;;

    protected $_strategy;

    public function __construct($title,$band){
        $this-&gt;title = $title;
        $this-&gt;band = $band;
    }
    public function setStrategyContest($strategyObject){
        $this-&gt;_strategy = $strategyObject;
    }
    public function get(){
        return $this-&gt;_strategy-&gt;get($this);
    }
}

class CDAsXMLStrategy{
    public function get(CDusesStrategy $cd){
        $doc = new DomDocument();
        $root = $doc-&gt;createElement(&apos;CD&apos;);
        $root = $doc-&gt;appendChild($root);
        $title = $doc-&gt;createElement(&apos;TITLE&apos;,$this-&gt;title);
        $title = $root-&gt;appendChild($title);
        $band = $doc-&gt;createElement(&apos;BAND&apos;,$this-&gt;band);
        $band = $root-&gt;appendChild($band);

        return $doc-&gt;saveXML();
    }
}

class CDAsJSONStrategy{
    public function get(CDusesStrategy $cd){
        $json = [];
        $json[&apos;CD&apos;][&apos;title&apos;] = $cd-&gt;title;
        $json[&apos;CD&apos;];&apos;band&apos;] = $cd-&gt;band;

        return $json_encode($json);
    }
}

$cd = new CDusesStrategy($externalTitle,$externalBand);

$cd-&gt;setStrategyContext(new CDAsXMLStrategy());
print $cd-&gt;get();

$cd-&gt;setStrategyContext(new CDAsJSONStrategy());
print $cd-&gt;get($cd);</code></pre><h3 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h3><blockquote>
<p>模板设计模式创建了一个实施一组方法和功能的抽象对象，子类通常将这个对象作为模板用于自己的设计 创建 定义了设计的常规步骤，但实际逻辑留给子类进行详细说明的对象时</p>
</blockquote>
<pre><code>abstract class SaleItemTemplate{
    public $price = 0;
    public final function setPriceAdjustments(){
        $this-&gt;price += $this-&gt;taxAddition();
        $this-&gt;price += $this-&gt;oversizedAddition();
    }

    protected function oversizedAddition(){
        return 0;
    }

    abstract protected function taxAddition();
}

class CD extends SaleItemTemplate{
    public $band;
    public $title;

    public function __construct($band,$title,$price){
        $this-&gt;band = $band;
        $this-&gt;title = $title,
        $this-&gt;price = $price;
    }
    protected function taxAddition(){
        return round($this-&gt;price*.05,2);
    }


}

class BandEndorsedCaseOfCereal extends SaleItemTemplate{
    public $band;
    public function __construct($band,$price){
        $this-&gt;band = $band;
        $this-&gt;price = $price;
    }
    protected function taxAddItion(){
        return 0;
    }
    protected function oversizedAddition(){
        return round($this-&gt;price*.20,2);
    }
}

$externalTitle = &quot;Waste of a Rib&quot;:
$externalBand = &quot;Never Again&quot;;
$externalCDPrice = 12.99;
$externalCerealPrice = 90;

$cd = new CD($externalBand,$externalTitle,$externalCDPrice);
$cd-&gt;setPriceAdjustments();

print &apos;The total cost for CD item is: $&apos;.$cd-&gt;price.&apos;&lt;br /&gt;&apos;;

$cereal = new BandEndorsedCaseOfCereal($externalBand,$externalCerealPrice);
$cereal-&gt;setPriceAdjustments();

print &apos;The total cost for the Cereal case is: $&apos;.$creal-&gt;price;</code></pre><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3><blockquote>
<p>访问者设计模式构造了包含某个算法的截然不同的对象，在父对象以标准方式使用这些对象时就会将该算法应用于父对象</p>
</blockquote>
<pre><code>class CD{
    public $band;
    public $title;
    public $price;
    public function __construct($band,$title,$price){
        $this-&gt;band = $band;
        $this-&gt;title = $title;
        $this-&gt;price = $price;
    }
    public function buy(){

    }
    public function acceptVisitor($visitor){
        $visitor-&gt;visitCD($this);
    }
}

class CDVisitorLogPurchase{
    public function visitCD($cd){
        $logline = &quot;{$cd-&gt;title} by {$cd-&gt;band} was purchased for {$cd-&gt;price}&quot;;
        $logline .= &quot;at&quot; . sdate(&apos;r&apos;).&quot;\n&quot;;

        file_put_contents(&apos;/logs/purchases.log&apos;,$logline,FILE_APPEND);
    }
}

$externalBand = &apos;Never Again&apos;;
$externalTitle = &apos;Wate of a Rib&apos;;
$externalPrice = 9.99;

$cd = new CD($externalBand,$externalTitle,$externalPrice);
$cd-&gt;buy();
$cd-&gt;acceptVisitor(new CDVisitorLogPurchase());


class CDVisitorPopulateDiscountList{
    public function visitCD($cd){
        if($cd-&gt;price&lt;10){
            $this-&gt;_populateDiscountList($cd);
        }
    }
    protected function _populateDiscountList($cd){

    }
}</code></pre>]]></content>
      <categories>
        <category>PHP</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>nprogress网页进度条使用小记</title>
    <url>/2016/07/19/nprogress-e7-bd-91-e9-a1-b5-e8-bf-9b-e5-ba-a6-e6-9d-a1-e4-bd-bf-e7-94-a8-e5-b0-8f-e8-ae-b0/</url>
    <content><![CDATA[<p>在页面中加入如下代码：  </p>
<pre><code>&lt;script type=&quot;text&quot; id=&quot;splash-template&quot;&gt;
    &lt;div class=&quot;splash card&quot;&gt;
        &lt;div role=&quot;spinner&quot;&gt;
            &lt;div class=&quot;spinner-icon&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
        &lt;p class=&quot;lead&quot; style=&quot;text-align:center&quot;&gt;正在努力加载中...&lt;/p&gt;
        &lt;div class=&quot;progress_my&quot;&gt;
            &lt;div class=&quot;mybar&quot; role=&quot;bar&quot;&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/script&gt;</code></pre><p>引入下列css和js文件<br>&lt; p style=”line-height: 16px;”&gt;<img src="http://xupengfei.net/assets/72e1b72c/dialogs/attachment/fileTypeImages/icon_rar.gif" alt>)<a href="/ueditor/php/upload/file/20160719/1468922666672112.rar" title="nprogress.rar">nprogress.rar</a><br>具体效果请参考本站</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>mysql长时间未连接gone away</title>
    <url>/2016/07/05/mysql-e9-95-bf-e6-97-b6-e9-97-b4-e6-9c-aa-e8-bf-9e-e6-8e-a5gone-away/</url>
    <content><![CDATA[<p>项目介绍： 使用workerman作为yii2的一个扩展插件，将workerman代码放在verdor目录下 在web目录下放入start.php</p>
<p>&lt;?php<br>defined(‘YII_DEBUG’) or define(‘YII_DEBUG’, true);<br>defined(‘YII_ENV’) or define(‘YII_ENV’, ‘dev’);</p>
<p>require(__DIR__ . ‘/../../vendor/autoload.php’);<br>require(__DIR__ . ‘/../../vendor/yiisoft/yii2/Yii.php’);<br>require(__DIR__ . ‘/../../common/config/bootstrap.php’);<br>require(__DIR__ . ‘/../config/bootstrap.php’);<br>require(__DIR__ . ‘/../../vendor/workerman/Autoloader.php’);<br>require_once(‘../../vendor/protocolbuf/message/pb_message.php’);</p>
<p>require_once(‘../protos/pb_proto_myerror.php’);<br>require_once (‘../protos/pb_proto_version.php’);<br>$config = yii\helpers\ArrayHelper::merge(<br>    require(__DIR__ . ‘/../../common/config/main.php’),<br>    require(__DIR__ . ‘/../../common/config/main-local.php’),<br>    require(__DIR__ . ‘/../config/main.php’),<br>    require(__DIR__ . ‘/../config/main-local.php’)<br>);</p>
<p>$application = new yii\web\Application($config);</p>
<p>use Workerman\Worker;</p>
<p>$tcp_worker = new Worker(“tcp://0.0.0.0:1234”);</p>
<p>// 启动4个进程对外提供服务<br>$tcp_worker-&gt;count = 4;<br>$tcp_worker-&gt;onConnect = function($connection){<br>    global $text_worker, $global_uid;<br>    // 为这个链接分配一个uid<br>    $connection-&gt;uid = ++$global_uid;<br>    echo $connection-&gt;uid.” login\n”;<br>};<br>// 当客户端发来数据时<br>$tcp_worker-&gt;onMessage = function($connection, $data)<br>{<br>…………….</p>
<p>错误原因： 长时间没有连接，第二天接入时会报以下错误 SQLSTATE[HY000]: General error: 2006 MySQL server has gone away 进入mysql：</p>
<p>show global variables like ‘wait_timeout’;</p>
<p>set global wait_timeout=30*24*3600;</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>php合并图片添加文字描述，防止png透明色变成黑色</title>
    <url>/2018/12/13/php-e5-90-88-e5-b9-b6-e5-9b-be-e7-89-87-e6-b7-bb-e5-8a-a0-e6-96-87-e5-ad-97-e6-8f-8f-e8-bf-b0-ef-bc-8c-e9-98-b2-e6-ad-a2png-e9-80-8f-e6-98-8e-e8-89-b2-e7-bc-96-e7-a8-8b-e9-bb-91-e8-89-b2/</url>
    <content><![CDATA[<pre><code>$msg = &apos;AAAAAAAA&apos;;//文字描述
$bg = __DIR__.&apos;/bg.png&apos;;//背景图片
$target = __DIR__.&apos;/target.png&apos;;//要合成的图片
$dirname = __DIR__.&apos;/composite/&apos;.$this-&gt;create_token();//生成一个随机数

$background_image = imagecreatefromstring(file_get_contents($bg));
$target_image = imagecreatefromstring(file_get_contents($target));
list($target_width,$target_height,$target_type) = getimagesize($target);
list($background_width,$background_height,$background_type) = getimagesize($bg);
//防止透明色变黑色
imagesavealpha($background_image, true);
//将target图片放入背景图片上，尺寸为523*605
imagecopyresampled($background_image,$target_image,13,12,0,0,523,605,$target_width,$target_height);
//生成文字
$font = __DIR__.&apos;/composite/public/font.ttf&apos;;
$black = imagecolorallocate($background_image,0,0,0);
$fontSize = 20;
imagettftext($background_image,$fontSize,0,33,705,$black,$font,&apos;活动最终解释权&apos;);
imagettftext($background_image,$fontSize,0,33,735,$black,$font,&apos;归商家所有&apos;);
$fontSize = 10;
imagettftext($background_image,$fontSize,0,329,690,$black,$font,&apos;兑换码&apos;);
$fontSize = 25;
imagettftext($background_image,$fontSize,0,329,730,$black,$font,$msg);
imagettftext($background_image,$fontSize,0,330,730,$black,$font,$msg);
//保存图片
$header = &apos;image/png&apos;;
switch ($background_type){
case 1:
$dirname = $dirname.&apos;.gif&apos;;
$header = &apos;image/gif&apos;;
imagegif($background_image,$dirname);
break;
case 2:
$dirname = $dirname.&apos;.jpg&apos;;
$header = &apos;image/jpg&apos;;
imagejpeg($background_image,$dirname);
break;
case 3:
$dirname = $dirname.&apos;.png&apos;;
$header = &apos;image/png&apos;;
imagepng($background_image,$dirname);
break;
}
imagedestroy($target_image);
imagedestroy($background_image);
Http::header(&quot;Content-Type: $header&quot;);
$data = file_get_contents($dirname);
unlink($dirname);//删除图片文件
//$data就是图片数据
return $this-&gt;send($data);</code></pre>]]></content>
      <categories>
        <category>PHP</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>php socket读取发送数据</title>
    <url>/2016/10/31/php-socket-e8-af-bb-e5-8f-96-e5-8f-91-e9-80-81-e6-95-b0-e6-8d-ae/</url>
    <content><![CDATA[<p>协议：<br>####{‘type’:’测试’}<br>前四位为小端序，表示数据包(不含前4位)长度<br>后面为json数据包<br>workerman协议实现：<br>&lt;?php<br>namespace Protocols;<br>class JsonRX<br>{<br>    public static function input($recv_buffer)<br>    {<br>        // 接收到的数据还不够4字节，无法得知包的长度，返回0继续等待数据<br>        if(strlen($recv_buffer)&lt;4)<br>        {<br>            return 0;<br>        }<br>        // 利用unpack函数将首部4字节转换成数字，首部4字节即为整个数据包长度<br>        $unpack_data = unpack(‘Vtotal_length’, $recv_buffer);<br>        // 接收到的数据长度不够，返回0继续等待数据<br>      if(strlen($recv_buffer)&lt;$unpack_data[‘total_length’]+4){<br>         return 0;<br>      }<br>        return $unpack_data[‘total_length’]+4;<br>    }<br>    public static function decode($recv_buffer)<br>    {<br>        // 去掉首部4字节，得到包体Json数据<br>        $body_json_str = substr($recv_buffer, 4);<br>        // json解码<br>        return json_decode($body_json_str, true);<br>    }<br>    public static function encode($data)<br>    {<br>        // Json编码得到包体<br>        $body_json_str = json_encode($data);<br>        // 计算整个包的长度，包体字节数<br>        $total_length = strlen($body_json_str);var_dump($total_length);<br>        // 返回打包的数据<br>        return pack(‘V’,$total_length) . $body_json_str;<br>    }<br>}<br>原生测试代码数据实现（已知数据包长度）<br>&lt;?php<br>$data  =  json_encode([<br>   ‘cmd’  =&gt; 101,<br>   ‘response’ =&gt; [<br>      ‘page’ =&gt; 1,<br>      ‘page_size’    =&gt; 50,<br>      ‘board_id’ =&gt; 34,<br>   ]<br>]);<br>//发送的数据包<br>$send = pack(‘V’,strlen($data)).$data;<br>$ip = “127.0.0.1”;<br>$port = 8189;<br>//<br>$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)or die(“Could not create  socket\n”);<br>$connection = socket_connect($socket, $host, $port) or die(“Could not connet server\n”);<br>socket_write($socket, $send) or die(“Write failed\n”);<br>//读取前四位，获取数据包长度<br>$buff = @socket_read($socket, 4);<br>$unpack_data = unpack(‘Vtotal_length’, $buff);<br>$content_len   =  $unpack_data[‘total_length’];<br>$per_len = 20000;     //每次读多少字节<br>$no_read_len = $content_len;  //未读的字节（总字节大小）<br>$str = ‘’;<br>$len = 0;<br>while($len&lt;$content_len)<br>{<br>   $read = socket_read($socket, $per_len,PHP_BINARY_READ);<br>   $str .= $read;//读取的数据<br>   $len += strlen($read);   //总共读了多少字节<br>}<br>var_dump($len);<br>$data  =  json_decode($str,true);<br>var_dump($data);<br>socket_close($socket);</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>redis设置密码认证并开启远程访问</title>
    <url>/2016/12/19/redis-e8-ae-be-e7-bd-ae-e5-af-86-e7-a0-81-e8-ae-a4-e8-af-81-e5-b9-b6-e5-bc-80-e5-90-af-e8-bf-9c-e7-a8-8b-e8-ae-bf-e9-97-ae/</url>
    <content><![CDATA[<p>1、redis开启密码认证：</p>
<p>进入redis安装目录打开/etc/redis.conf文件<br>找到requirepass foobared这行；取消注释<br>将foobared改为你自己的密码</p>
<p>将redis重启后；新的redis链接就需要密码验权了</p>
<p>auth yourpass</p>
<p>2、redis开启远程访问：</p>
<p>打开redis.conf文件<br>找到bind 127.0.0.1<br>将其改为 bind 0.0.0.0</p>
<p>重启redis</p>
<p>备注：一定要把服务器的6379端口打开！！！</p>
<p>3、redis客户端管理软件我使用的是 Redis Desktop Manager<br><a href="https://redisdesktop.com/download" target="_blank" rel="noopener">下载地址：https://redisdesktop.com/download</a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>phpexcel导出数据内存一簇500错误</title>
    <url>/2016/03/31/phpexcel-e5-af-bc-e5-87-ba-e6-95-b0-e6-8d-ae-e5-86-85-e5-ad-98-e4-b8-80-e7-b0-87500-e9-94-99-e8-af-af/</url>
    <content><![CDATA[<p>在做一个微信项目，需要导出导入数据，使用了phpexcel少量数据测试的时候没有任何问题，但是上传了两千条数据的时候导入数据时还没有任何问题，但导出数据时却直接报了一个500错误，折腾了半天之后，发现可能是内存溢出的原因。百度了一下，完美解决，现在记录一下</p>
<p>require_once ‘PHPExcel.php’;  </p>
<p>//设定缓存模式为经gzip压缩后存入cache（还有多种方式请百度）<br>$cacheMethod = PHPExcel_CachedObjectStorageFactory::cache_in_memory_gzip;<br>$cacheSettings = array();<br>PHPExcel_Settings::setCacheStorageMethod($cacheMethod,$cacheSettings);  </p>
<p>$objPHPExcel = new PHPExcel();</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>supervisor使用</title>
    <url>/2019/05/05/supervisor-e4-bd-bf-e7-94-a8/</url>
    <content><![CDATA[<p>安装方式：</p>
<pre><code>easy_install 安装：
easy_install supervisor

pip 安装：
pip install supervisor

centos 安装
yum install supervisor

Debian / Ubuntu可以直接通过apt安装：
apt-get install supervisor</code></pre><p>运行</p>
<pre><code>supervisord -c /etc/supervisord.conf</code></pre><p>关闭</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisorctl shutdown</span><br></pre></td></tr></table></figure>

<p>如果没有conf文件，可执行下列命令生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure>

<p>1、web-ui配置</p>
<pre><code>vim /etc/supervisord.conf
找到
;[inet_http_server]         ; inet (TCP) server disabled by default
;port=127.0.0.1:9001        ; (ip_address:port specifier, *:port for all iface)
;username=user              ; (default is no username (open server))
;password=123               ; (default is no password (open server))
改为【其中*表示允许所有的ip访问】
[inet_http_server]         ; inet (TCP) server disabled by default
port=*:9001        ; (ip_address:port specifier, *:port for all iface)
username=user              ; (default is no username (open server))
password=123               ; (default is no password (open server))

修改成功后重启程序加载配置
supervisorctl reload</code></pre><p>2、supervisor相关命令</p>
<pre><code>supervisorctl status：查看所有进程的状态
supervisorctl stop es：停止es
supervisorctl start es：启动es
supervisorctl restart es: 重启es
supervisorctl update ：配置文件修改后可以使用该命令加载新的配置
supervisorctl reload: 重新启动配置中的所有程序</code></pre><p>3、具体配置</p>
<pre><code>#名称
[program:frp]
#脚本目录
directory=/home/frp
#脚本执行命令
command=/home/frp/frps -c ./frps.ini
#脚本运行的用户身份
user=root

修改成功后重启程序加载配置
supervisorctl reload</code></pre>]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>phpstorm在Ubuntu环境下的安装激活与汉化</title>
    <url>/2016/11/08/phpstorm-e5-9c-a8ubuntu-e7-8e-af-e5-a2-83-e4-b8-8b-e7-9a-84-e5-ae-89-e8-a3-85-e6-bf-80-e6-b4-bb-e4-b8-8e-e6-b1-89-e5-8c-96/</url>
    <content><![CDATA[<p>1、首先在Jetbrains官网（<a href="https://www.jetbrains.com/phpstorm/download/#section=linux-version）下载PhpStorm的tar包" target="_blank" rel="noopener">https://www.jetbrains.com/phpstorm/download/#section=linux-version）下载PhpStorm的tar包</a> 2、下载完成后，打开一个终端窗口．将工作目录切换到下载目录，然后解压下载好的tar.gz文件．</p>
<p>tar xvf PhpStorm-162.2380.11.tar.gz</p>
<p>3、在当前的工作目录下会生成一个新的目录，PhpStorm-162.2380.11．为了保持系统整洁有序，我们把这个目录移到/opt/目录下．</p>
<p>sudo mv PhpStorm-162.2380.11/ /worker/phpstorm/</p>
<p>4、现在，创建一个软链接．</p>
<p>sudo ln -s /opt/phpstorm/bin/phpstorm.sh /usr/local/bin/phpstorm</p>
<p>5、然后，在终端里输入phpstorm命令来启动PhpStorm程序．</p>
<p>phpstorm</p>
<p>6、激活phpstorm</p>
<p><a href="http://idea.lanyus.com/getkey?userName=lan+yu" target="_blank" rel="noopener">http://idea.lanyus.com/getkey?userName=lan+yu</a></p>
<p>userName可以更换</p>
<p><a href="https://i.loli.net/2018/08/09/5b6bdeaff2a2a.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdeaff2a2a.png" alt="undefined" title="undefined"></a> 7、汉化 将resources_cn.jar放到lib文件夹下即可 &lt; p style=”line-height: 16px;”&gt;<a href="/ueditor/php/upload/file/20161108/1478589349107274.zip" title="resources_cn.zip">resources_cn.zip</a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>thinkphp使用七牛上传图片</title>
    <url>/2016/04/18/thinkphp-e4-bd-bf-e7-94-a8-e4-b8-83-e7-89-9b-e4-b8-8a-e4-bc-a0-e5-9b-be-e7-89-87/</url>
    <content><![CDATA[<p>&lt;?php<br>namespace Home\Controller;<br>use Think\Controller;<br>class BaseController extends Controller{<br>    //本地配置参数<br>    protected $local_config    =   [<br>        ‘maxSize’    =&gt;    5242880,<br>        ‘rootPath’   =&gt;    ‘./Uploads/‘,<br>        ‘saveName’   =&gt;    array(‘uniqid’,’’),<br>        ‘autoSub’    =&gt;    true,<br>        ‘subName’    =&gt;    array(‘date’,’Ymd’),<br>    ];<br>    //七牛配置参数<br>    protected $qiniu_config    =   [<br>            ‘secretKey’ =&gt; ‘<strong>****</strong>‘,  //七牛SK  YKtjhUMus07YUkT0bTudC2D1Tnm62JaWJ3JJkrIC<br>            ‘accessKey’ =&gt; ‘<strong>****</strong>‘, //七牛AK  8f4JUUDc1GFeEOaGerbwpt1aM7XN1GFbiuLKY35T<br>            ‘domain’ =&gt; ‘<strong>****</strong>‘, //七牛空间地址URL<br>            ‘bucket’ =&gt; ‘<strong>****</strong>‘, //七牛空间名称<br>    ];</p>
<pre><code>protected function uploadOne($file){
    $upload = new \\Think\\Upload($this-&gt;local\_config,&apos;Qiniu&apos;,$this-&gt;qiniu\_config);
    $info = $upload-&gt;uploadOne($file);
    if (!$info) {
        return \[201, $upload-&gt;getError()\];
    }
    return \[200, $info\]; 
}
protected function uploads($files){
    $upload = new \\Think\\Upload($this-&gt;config);
    $info = $upload-&gt;upload($files);
    if (!$info) {
        return \[201, $upload-&gt;getError()\];
    }
    foreach ($info as $v) {
        $pArray\[\] = &quot;http://&quot;.$this-&gt;config\[&apos;driverConfig&apos;\]\[&apos;domain&apos;\].&quot;/&quot;.strtr($v\[&apos;name&apos;\], &apos;/&apos;, &apos;_&apos;);
    }
    return \[200, $pArray\];
}</code></pre><p>}</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>svn提交代码后自动更新到服务器</title>
    <url>/2015/12/11/svn-e6-8f-90-e4-ba-a4-e4-bb-a3-e7-a0-81-e5-90-8e-e8-87-aa-e5-8a-a8-e6-9b-b4-e6-96-b0-e5-88-b0-e6-9c-8d-e5-8a-a1-e5-99-a8/</url>
    <content><![CDATA[<p>在本地敲完代码后每次更新到服务器都用用ssh工具更新代码，一来这样更新代码十分繁琐，二来这样做就很难再找到以前的代码了。所以今天就在服务器上搭建了一个svn服务器并做了一个自动更新代码到测试服务器。 1、进入你的svn库中的hooks文件夹，拷贝一份post-commit.tmpl文件：</p>
<p>cp post-commit.tmpl post-commit</p>
<p>2、修改post-commit文件，将文件内容改为：</p>
<p>#!/bin/sh<br>export LANG=”zh_CN.UTF-8”<br>#更新到远程的服务器<br>#/home/xxx/svn.php 为svn.php在svn服务器上的存放地址<br>/usr/local/php/bin/php /home/xxx/svn.php</p>
<p>3、重新启动svn服务</p>
<p>killall svnserve<br>svnserve -d -r /home/svn/repositories</p>
<p>3、svn.php代码为</p>
<p>&lt;?php<br>/**</p>
<ul>
<li>svn钩子post-commit里执行的文件</li>
<li>存放在svn服务器上</li>
<li>/<br>$updateUrl = “<a href="http://xupengfei.net/update.php&quot;;//远程测试服务器上的update.php的地址" target="_blank" rel="noopener">http://xupengfei.net/update.php&quot;;//远程测试服务器上的update.php的地址</a><br>$ch = curl_init();<br>curl_setopt($ch, CURLOPT_URL, $updateUrl);<br>curl_setopt($ch, CURLOPT_HEADER, 0);<br>curl_exec($ch);<br>curl_close($ch);</li>
</ul>
<p>4、远程服务器update.php文件代码为：  </p>
<p>&lt;?php<br>/**</p>
<ul>
<li>svn服务器上的钩子需要模拟访问的文件，必须是外网可以访问的</li>
<li>存放在远程服务器上</li>
<li>/<br>error_reporting(E_ALL);<br>//设置下字符集，有不认识的字符，也会导致不可更新<br>putenv(“LC_CTYPE=zh_CN.UTF-8”);<br>//“/home/myweb/“ 为代码更新到的指定目录路径<br>$handle = popen(‘svn up –username yourname –password yourpassword /home/myweb/ 2&gt;&amp;1 –no-auth-cache’,’r’);<br>//echo “‘$handle’; “ . gettype($handle) . “\n”;<br>$read = stream_get_contents($handle);<br>//TODO 如果在$read中可以匹配到“error/conflict”，就应该发送邮件到管理员的邮箱了！<br>echo $read;<br>pclose($handle);</li>
</ul>
<p>5、在update.php文件中–no-auth-cache比较重要，如果没有该参数则会出现错误：———————————————————————– ATTENTION! Your password for authentication realm: /home/svn/repositories can only be stored to disk unencrypted! You are advised to configure your system so that Subversion can store passwords encrypted, if possible. See the documentation for details. You can avoid future appearances of this warning by setting the value of the ‘store-plaintext-passwords’ option to either ‘yes’ or ‘no’ in ‘/sbin/.subversion/servers’. ———————————————————————– Store password unencrypted (yes/no)? svn: Can’t read stdin: End of file found 6、在使用之前记得对服务器要更新的目录先做一次检出</p>
<p>svn co svn://115.28.39.17/ aaa</p>
<p>如果出现错误；则是因为检出时使用的root权限，而web访问则是没有权限的 svn: Can’t open file ‘/home/web/svn/myweb/aaa/115.28.39.17/.svn/lock’: Permission denied 解决方法</p>
<p>chmod o+w aaa/.svn -R</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>virtualbox centos7共享文件夹</title>
    <url>/2017/01/09/virtualbox-centos7-e5-85-b1-e4-ba-ab-e6-96-87-e4-bb-b6-e5-a4-b9/</url>
    <content><![CDATA[<p>1、这不是最小化安装；请安装个桌面；最小化安装系统后的设置我不会； 2、安装增强功能后报错；按序执行以下命令</p>
<p>yum update<br>yum install gcc<br>yum install kernel<br>yum install kernel-devel</p>
<p>3、再次安装增强功能<br>4、设置共享文件夹；在centos目录/media/中可看到设置的共享文件</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>vue使用axios</title>
    <url>/2018/08/14/vue-e4-bd-bf-e7-94-a8axios/</url>
    <content><![CDATA[<h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><pre><code>npm install --save axios vue-axios</code></pre><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><pre><code>import Vue from &apos;vue&apos;
import axios from &apos;axios&apos;
import VueAxios from &apos;vue-axios&apos;

Vue.use(VueAxios, axios)</code></pre><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><pre><code>Vue.axios.get(api).then((response) =&gt; {
  console.log(response.data)
})

this.axios.get(api).then((response) =&gt; {
  console.log(response.data)
})

this.$http.get(api).then((response) =&gt; {
  console.log(response.data)
})</code></pre><h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><p>1、<a href="https://www.npmjs.com/package/vue-axios" target="_blank" rel="noopener" title="vue-axios">vue-axios</a> 2、<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener" title="Axios 中文说明">Axios 中文说明</a></p>
]]></content>
      <categories>
        <category>vue</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>ubuntu修改hosts文件</title>
    <url>/2016/06/30/ubuntu-e4-bf-ae-e6-94-b9hosts-e6-96-87-e4-bb-b6/</url>
    <content><![CDATA[<p>获取root权限<br>修改/etc/hosts</p>
<p>127.0.0.1 localhost</p>
<p>保存重启网络</p>
<p>/etc/init.d/networking restart</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>vue-cli项目只能在本机上查看，局域网其他设备无法查看</title>
    <url>/2018/02/27/vue-cli-e9-a1-b9-e7-9b-ae-e5-8f-aa-e8-83-bd-e5-9c-a8-e6-9c-ac-e6-9c-ba-e4-b8-8a-e6-9f-a5-e7-9c-8b-ef-bc-8c-e5-b1-80-e5-9f-9f-e7-bd-91-e5-85-b6-e4-bb-96-e8-ae-be-e5-a4-87-e6-97-a0-e6-b3-95-e6-9f-a5/</url>
    <content><![CDATA[<p>解决方式如下： config文件夹下的index.js文件中的module.exports下面的dev下面的host:’localhost’ 改为 host:’0.0.0.0’ 页面出现Invalid Host header错误，内网穿透工具用frp 在vue-cli版本为2.x的情况下修改webpack.dev.conf.js中的devServer对象加入disableHostCheck: true即可转发成功</p>
<pre><code>devServer: {
  disableHostCheck: true,
}</code></pre><p>vue-cli版本3.0的情况下修改vue.config.js的配置</p>
<pre><code>module.exports = {
  devServer: {
    disableHostCheck: true
  }
}</code></pre>]]></content>
      <categories>
        <category>vue</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>vuex 各模块的简单记录</title>
    <url>/2018/08/13/vuex-e5-90-84-e6-a8-a1-e5-9d-97-e7-9a-84-e7-ae-80-e5-8d-95-e8-ae-b0-e5-bd-95/</url>
    <content><![CDATA[<blockquote>
<p>在各个模块中，只有getters有返回值；commit和dispatch没有返回值</p>
</blockquote>
<h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>getters 接收两个可选参数；第一个参数为state，第二个参数为其他getters</p>
<pre><code>const getters = {
  getCache:function (state,rootGetters) {
    return function (key) {
      var cache_data = localStorage.getItem(key)
      var data = JSON.parse(Base64.decode(cache_data))
      if (data.timeout===0||data.timeout&gt;(new Date()).getTime()){
        return data.data;
      }
      localStorage.removeItem(key);
      return null;
    }
  }
}

//调用方式
//1、vue中调用
uuid = this.$store.getters[&apos;getCache&apos;]  //modules中的getters则使用[&quot;模块名/方法名&quot;]
//2、其他模块中调用
var cache_uuid = rootGetters[&apos;getCache&apos;](&apos;uuid&apos;)</code></pre><h2 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h2>]]></content>
      <categories>
        <category>vue</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2.0URL美化</title>
    <url>/2016/01/20/yii2-0url-e7-be-8e-e5-8c-96/</url>
    <content><![CDATA[<p>在config文件夹打开main.php，在components里面加上如下代码：</p>
<p>//URL美化配置<br>/*****start******/<br>‘urlManager’=&gt;   [<br>    ‘enablePrettyUrl’   =&gt;   true,<br>    ‘showScriptName’    =&gt;   false,<br>    ‘suffix’            =&gt;   ‘.html’,<br>    ‘rules’             =&gt;   [],<br>],<br>/*****end******/</p>
<p>在web文件夹中添加.htaccess文件 文件内容为：</p>
<p>RewriteEngine on</p>
<h1 id="如果是一个目录或者文件，就访问目录或文件"><a href="#如果是一个目录或者文件，就访问目录或文件" class="headerlink" title="如果是一个目录或者文件，就访问目录或文件"></a>如果是一个目录或者文件，就访问目录或文件</h1><p> RewriteCond %{REQUEST_FILENAME} !-d</p>
<h1 id="如果文件存在，就直接访问文件，不进行下面的RewriteRule"><a href="#如果文件存在，就直接访问文件，不进行下面的RewriteRule" class="headerlink" title="如果文件存在，就直接访问文件，不进行下面的RewriteRule"></a>如果文件存在，就直接访问文件，不进行下面的RewriteRule</h1><p> RewriteCond %{REQUEST_FILENAME} !-f</p>
<p> RewriteRule . index.php</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>vue使用swiper时滑动不到第二页</title>
    <url>/2016/12/26/vue-e4-bd-bf-e7-94-a8swiper-e6-97-b6-e6-bb-91-e5-8a-a8-e4-b8-8d-e5-88-b0-e7-ac-ac-e4-ba-8c-e9-a1-b5/</url>
    <content><![CDATA[<p>template:’<br>    <div class="m_slide swiper-container"><br>    <div class="content swiper-wrapper"><br>        <template v-for="(item,index) in banner"><br>            <div class="swiper-slide"><a v-bind:href="item.link\_url"><img v-bind:src="item.banner\_img"></a></div><br>        </template><br>    </div><br>    <div class="slide_d swiper-pagination"><br>    </div><br>    </div><br>‘,<br>mounted:function(){<br>    new Swiper(“.swiper-container”, {<br>    pagination: ‘.swiper-pagination’,</p>
<pre><code>observer:true,//修改swiper自己或子元素时，自动初始化swiper
observeParents:true,//修改swiper的父元素时，自动初始化swiper
});</code></pre><p>}</p>
<p>经测试；手动填写要循环的内容是可以滑动的；所以在初始化swiper时；将observer和observerParents属性赋值为true即可</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>vux 新建项目</title>
    <url>/2018/01/16/vux-e6-96-b0-e5-bb-ba-e9-a1-b9-e7-9b-ae/</url>
    <content><![CDATA[<p>1、npm i -g vue-cli</p>
<p>2、vue init webpack vux-project</p>
<p>3、cd vux-project</p>
<p>4、npm install vux –save</p>
<p>5、npm install vux-loader –save-dev</p>
<p>6、npm install stylus –save-dev</p>
<p>7、npm install less less-loader –save-dev</p>
<p>8、配置build/webpack.base.conf.js文件：<br>    const vuxLoader = require(‘vux-loader’)<br>    const webpackConfig = originalConfig // 原来的 module.exports 代码赋值给变量 webpackConfig<br>    module.exports = vuxLoader.merge(webpackConfig, {<br>        plugins: [‘vux-ui’]<br>    })</p>
<p>9、npm run dev</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii-adminlte和自己写的js和css文件同时引用</title>
    <url>/2016/05/25/yii-adminlte-e5-92-8c-e8-87-aa-e5-b7-b1-e5-86-99-e7-9a-84js-e5-92-8ccss-e6-96-87-e4-bb-b6-e5-90-8c-e6-97-b6-e5-bc-95-e7-94-a8/</url>
    <content><![CDATA[<p><a href="https://i.loli.net/2018/08/09/5b6bdd59cbbc3.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdd59cbbc3.png" alt="undefined" title="undefined"></a> AppAsset文件不变，复制一份修改名称为MyAPPAsset，文件代码如下：</p>
<p>&lt;?php<br>namespace backend\assets;</p>
<p>use yii\web\AssetBundle;</p>
<p>class MyAppAsset extends AssetBundle<br>{<br>    public $sourcePath = ‘@vendor/almasaeed2010/adminlte’;<br>    public $css = [<br>        ‘plugins/datatables/dataTables.bootstrap.css’,<br>    ];<br>    public $js = [<br>    ];<br>    public $depends = [<br>        ‘dmstr\web\AdminLteAsset’,<br>    ];<br>}</p>
<p>在需要引用的文件内添加如下代码：</p>
<p>backend\assets\MyAppAsset::register($this);</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>wamp虚拟主机设置</title>
    <url>/2016/11/14/wamp-e8-99-9a-e6-8b-9f-e4-b8-bb-e6-9c-ba-e8-ae-be-e7-bd-ae/</url>
    <content><![CDATA[<p>httpd-vhosts.conf</p>
<p>&lt;VirtualHost *:80&gt;<br>    ServerAdmin webmaster@localhost<br>    DocumentRoot “D:/wamp/www/kayun/frontend/web”<br>    ServerName localhost<br>    ErrorLog “logs/localhost-error.log”<br>    CustomLog “logs/localhost-access.log” common<br><br>&lt;Directory “D:/wamp/www/kayun/frontend/web”&gt;<br>    AllowOverride All<br>    Order allow,deny<br>    Allow from all<br></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii表单radioList样式设置</title>
    <url>/2015/12/03/yii-e8-a1-a8-e5-8d-95radiolist-e6-a0-b7-e5-bc-8f-e8-ae-be-e7-bd-ae/</url>
    <content><![CDATA[<p>今天在用yii2.0做用户个人信息设置时遇到这样一个问题，关于radioList： <a href="https://i.loli.net/2018/08/09/5b6bdb1623c87.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/08/09/5b6bdb1623c87.png" alt></a> 做了这样一个表单，代码如下：</p>
<?php $form = ActiveForm::begin(\['id' => 'form-user-site','options'=>\['class'=>'form-horizontal','role'=>"form"\],'fieldConfig' => \[
                'template' => "{label}\\n<div class="\\"col-sm-6\\"">{input}</div>\\n{hint}\\n{error}",
                'labelOptions' => \['class' => 'control-label col-sm-3'\],
            \]\]); ?>
<pre><code>&lt;?= $form-&gt;field($model, &apos;user_email&apos;)-&gt;label(&apos;用户邮箱&apos;) ?&gt;
&lt;?= $form-&gt;field($model, &apos;nickname&apos;)-&gt;label(&apos;用户昵称&apos;) ?&gt;
&lt;?= $form-&gt;field($model, &apos;sex&apos;)-&gt;inline(true)-&gt;radioList(\[&apos;0&apos;=&gt;&apos;保密&apos;,&apos;1&apos;=&gt;&apos;男&apos;,&apos;2&apos;=&gt;&apos;女&apos;\])-&gt;label(&apos;用户性别&apos;) ?&gt;
&lt;?= $form-&gt;field($model, &apos;user_QQ&apos;)-&gt;label(&apos;用户QQ&apos;) ?&gt;
&lt;?= $form-&gt;field($model, &apos;user_city&apos;)-&gt;label(&apos;所在城市&apos;) ?&gt;
&lt;?= $form-&gt;field($model, &apos;user_birthday&apos;)-&gt;label(&apos;用户生日&apos;) ?&gt;
&lt;?= $form-&gt;field($model, &apos;user_signature&apos;)-&gt;label(&apos;个性签名&apos;) ?&gt;
&lt;div class=&quot;form-group field-usersiteform-user_email&quot;&gt;
    &lt;div class=&quot;col-sm-3&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;col-sm-6&quot;&gt;
        &lt;?= Html::submitButton(&apos;修改&apos;, \[&apos;class&apos;=&gt;&apos;btn btn-primary&apos;\]); ?&gt;
    &lt;/div&gt;
&lt;/div&gt;</code></pre><?php ActiveForm::end(); ?>

<p>但通过图片可以看出用户性别一栏样式不正确：<br><a href="https://i.loli.net/2018/08/09/5b6bdb4b6067b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/08/09/5b6bdb4b6067b.png" alt></a> 查看源码后可以看出radioList和其他input样式不同，没有class=’col-sm-6’。 后经百度发现： 使用 $form-&gt;field生成的textarea跟checkbox是不一样的,应该说.checkbox,checkboxList,radio,radioList这四个跟其它的input都不一样 在多次测试后发现以下代码可使radioList与其他input样式一致：</p>
<?= $form->field($model, 'sex')->inline(true)->radioList(\['0'=>'保密','1'=>'男','2'=>'女'\],\['template' => '{label}<div class="col-sm-6">{input}</div>{hint}{error}'\])->label('用户性别') ?>]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2.0无限极分类的实现</title>
    <url>/2015/12/18/yii2-0-e6-97-a0-e9-99-90-e6-9e-81-e5-88-86-e7-b1-bb-e7-9a-84-e5-ae-9e-e7-8e-b0/</url>
    <content><![CDATA[<p><a href="https://i.loli.net/2018/08/09/5b6bdc7252bf6.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdc7252bf6.png" alt="undefined" title="undefined"></a> 如图，在项目文档上加上链接，yii自带的代码是：</p>
<p>$this-&gt;params[‘breadcrumbs’][] = ‘项目文档’;</p>
<p>给他加上链接为：</p>
<p>$this-&gt;params[‘breadcrumbs’][] = [‘label’=&gt;’项目文档’,’url’=&gt;[‘doc/index’]];</p>
<p>在链接中加上参数为：</p>
<p>$this-&gt;params[‘breadcrumbs’][] = [‘label’=&gt;’项目文档’,’url’=&gt;[‘doc/index’,’id’=&gt;6]];</p>
<p>其中id为参数名，6为参数值</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>win10中的bash on ubuntu卸载</title>
    <url>/2017/01/05/win10-e4-b8-ad-e7-9a-84bash-on-ubuntu-e5-8d-b8-e8-bd-bd/</url>
    <content><![CDATA[<p>怎么安装bash on ubuntu我就不说了；网上一搜一大把 下面说说怎么卸载：</p>
<p>在cmd中运行如下命令<br>lxrun /uninstall<br>输入y继续</p>
<p>lxrun /uninstall /full</p>
<p>重新安装的话只需要重新运行bash就可以了</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 图片上传预览功能</title>
    <url>/2015/12/05/yii2-e5-9b-be-e7-89-87-e4-b8-8a-e4-bc-a0-e9-a2-84-e8-a7-88-e5-8a-9f-e8-83-bd/</url>
    <content><![CDATA[<p>1、下载bootstrap-fileinput，下载地址：<a href="https://github.com/kartik-v/bootstrap-fileinput" target="_blank" rel="noopener">https://github.com/kartik-v/bootstrap-fileinput</a> 2、将其放入项目的静态资源目录内。 3、在需要使用的页面注册css和js，代码如下：</p>
<?php

use frontend\\assets\\AppAsset; 
AppAsset::register($this);
$this->registerCssFile('@web/statics/inputfile/css/fileinput.css',\['depends'=>\['frontend\\assets\\AppAsset'\]\]); 
$this->registerJsFile('@web/statics/inputfile/js/fileinput.js',\['depends'=>\['frontend\\assets\\AppAsset'\]\]);
$this->registerJsFile('@web/statics/inputfile/js/fileinput\_locale\_zh.js',\['depends'=>\['frontend\\assets\\AppAsset'\]\]);
$this->registerJs("$('#file-0').fileinput({
            'allowedFileExtensions' : \['jpg', 'png','gif'\],'showCaption':false,
        });");
?>

<p>4、在form表单中使用：</p>
<?php $form = ActiveForm::begin(\['id' => 'form-user-upload','options'=>\['class'=>'form-horizontal','role'=>"form"\],'fieldConfig' => \[
                'template' => "<div class="\\"col-sm-9\\"">{input}</div>",
            \]\]);  ?>
<pre><code>&lt;?= $form-&gt;field($model, &apos;user_image&apos;)-&gt;input(&apos;file&apos;,\[&apos;class&apos;=&gt;&apos;file&apos;,&apos;id&apos;=&gt;&apos;file-0&apos;\]) ?&gt;</code></pre><?php ActiveForm::end(); ?>

<p>5、效果图如下：<br><a href="https://i.loli.net/2018/08/09/5b6bdbd2e22df.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdbd2e22df.png" alt="undefined" title="undefined"></a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2在登陆时增加登录时间，退出时间等参数</title>
    <url>/2015/12/08/yii2-e5-9c-a8-e7-99-bb-e9-99-86-e6-97-b6-e5-a2-9e-e5-8a-a0-e7-99-bb-e5-bd-95-e6-97-b6-e9-97-b4-ef-bc-8c-e9-80-80-e5-87-ba-e6-97-b6-e9-97-b4-e7-ad-89-e5-8f-82-e6-95-b0/</url>
    <content><![CDATA[<p>在你的项目中的config下的main.php中增加如下代码：</p>
<p>return [<br>    ……<br>    ‘components’ =&gt; [<br>        …………<br>        ‘user’ =&gt; [<br>            ‘identityClass’ =&gt; ‘common\models\User’,<br>            ‘enableAutoLogin’ =&gt; true,<br>            ‘on beforeLogin’=&gt;function($event){<br>                $user=$event-&gt;identity;<br>                $user-&gt;last_login_time    =    time();<br>                …….<br>                $user-&gt;save();<br>            },<br>            ‘on beforeLogout’=&gt;function($event){<br>                $user=$event-&gt;identity;<br>                $user-&gt;logout_time    =    time();<br>                …….<br>                $user-&gt;save();<br>            }<br>        ],<br>       ……<br>    ],<br>    …….<br>];</p>
<p>除了afterLogin，beforeLogout外，还有beforeLogin和afterLogout</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2-dynamicform插件动态添加yii2-widget-select2插件时无法正常工作</title>
    <url>/2020/01/10/yii2-dynamicform-e6-8f-92-e4-bb-b6-e5-8a-a8-e6-80-81-e6-b7-bb-e5-8a-a0yii2-widget-select2-e6-8f-92-e4-bb-b6-e6-97-b6-e6-97-a0-e6-b3-95-e6-ad-a3-e5-b8-b8-e5-b7-a5-e4-bd-9c/</url>
    <content><![CDATA[<p>修改yii2-dynamic-form.js文件，从第419行开始，将代码替换掉</p>
<pre><code>// &quot;kartik-v/yii2-widget-select2&quot;
var $hasSelect2 = $(widgetOptionsRoot.widgetItem).find(&apos;[data-krajee-select2]&apos;);
if ($hasSelect2.length &gt; 0) {
    $hasSelect2.each(function() {
        var id = $(this).attr(&apos;id&apos;);
        var configSelect2 = eval($(this).attr(&apos;data-krajee-select2&apos;));
        // $(this).select2(&apos;destroy&apos;);
        if ($(this).data(&apos;select2&apos;)) { $(this).select2(&apos;destroy&apos;); }
        $.when($(&apos;#&apos; + id).select2(configSelect2)).done(initS2Loading(id));
        $(&apos;#&apos; + id).on(&apos;select2-open&apos;, function() {
            initS2Open(id)
        });
        if ($(this).attr(&apos;data-krajee-depdrop&apos;)) {
            $(this).on(&apos;depdrop.beforeChange&apos;, function(e,i,v) {
                var configDepdrop = eval($(this).attr(&apos;data-krajee-depdrop&apos;));
                var loadingText = (configDepdrop.loadingText)? configDepdrop.loadingText : &apos;Loading ...&apos;;
                $(&apos;#&apos; + id).select2(&apos;data&apos;, {text: loadingText});
            });
            $(this).on(&apos;depdrop.change&apos;, function(e,i,v,c) {
                $(&apos;#&apos; + id).select2(&apos;val&apos;, $(&apos;#&apos; + id).val());
            });
        }
    });
}</code></pre>]]></content>
      <categories>
        <category>PHP</category>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2在nginx下的URL美化</title>
    <url>/2017/02/20/yii2-e5-9c-a8nginx-e4-b8-8b-e7-9a-84url-e7-be-8e-e5-8c-96/</url>
    <content><![CDATA[<p>在nginx配置文件中添加如下代码；在网站根目录添加.htaccess文件</p>
<p>location / {<br>    # Redirect everything that isn’t a real file to index.php<br>    try_files $uri $uri/ /index.php$is_args$args;<br>}</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2基础后台构建</title>
    <url>/2016/05/15/yii2-e5-9f-ba-e7-a1-80-e5-90-8e-e5-8f-b0-e6-9e-84-e5-bb-ba/</url>
    <content><![CDATA[<p>说明：<br>    使用了yii-admin和yii-adminlte<br>1、正常安装yii2，过程请自行百度 2、URL美化设置     在\backend\config\main.php中或\common\config\main-local.php中的components数组中添加如下代码：</p>
<pre><code>&apos;urlManager&apos; =&gt; \[
    &apos;enablePrettyUrl&apos; =&gt; true,
    &apos;showScriptName&apos; =&gt; false,
    &apos;suffix&apos;            =&gt;    &apos;.html&apos;,
    &apos;rules&apos; =&gt; \[
    \],
\],</code></pre><p>3、在\backend\web\目录中添加.htaccess文件，否则可能会报403错误</p>
<p><img src="http://xupengfei.net/assets/72e1b72c/dialogs/attachment/fileTypeImages/icon_rar.gif" alt>)<a href="/ueditor/php/upload/file/20160628/1467093929241616.rar" title="htaccess.rar">htaccess.rar</a> 4、因为使用了composer来下载yii-admin和yii-adminlte，但国内下载的时候网速真不敢让人恭维，所以需要对composer进行一些设置使用国内的镜像 进入yii目录，执行如下命令：</p>
<p>composer config repo.packagist composer <a href="https://packagist.phpcomposer.com" target="_blank" rel="noopener">https://packagist.phpcomposer.com</a></p>
<p>5、使用composer安装yii-adminlte： 进入yii根目录：</p>
<p>composer require dmstr/yii2-adminlte-asset “2.*”</p>
<p>将vendor/dmstr/yii2-adminlte-asset/example-views/yiisoft/yii2-app目录下的layouts和site复制到对应项目的view目录下 6、使用composer安装yii-admin：</p>
<p>composer require mdmsoft/yii2-admin “~2.0”</p>
<p>7、配置数据库，在main.php配置文件中添加如下代码：</p>
<pre><code>&apos;db&apos; =&gt; \[
    &apos;class&apos; =&gt; &apos;yii\\db\\Connection&apos;,
    &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yiiadmin&apos;,
    &apos;username&apos; =&gt; &apos;root&apos;,
    &apos;password&apos; =&gt; &apos;&apos;,
    &apos;charset&apos; =&gt; &apos;utf8&apos;,
\],</code></pre><p>运行vendor/yiisoft/yii2/rbac/migrations/schema-mysql.sql和vendor\mdmsoft\yii2-admin\migrations\schema-mysql.sql文件中的sql语句创建数据表 8、yii-admin配置： 在main.php中添加如下代码：</p>
<p>components数组外添加如下代码：<br>        ‘language’  =&gt;   ‘zh-CN’,<br>        ‘modules’ =&gt; [<br>            ‘admin’ =&gt; [<br>                ‘class’ =&gt; ‘mdm\admin\Module’,<br>    //          ‘layout’ =&gt; ‘right-menu’, // it can be ‘@path/to/your/layout’.<br>                ‘mainLayout’ =&gt; ‘@backend/views/layouts/main.php’,<br>                ‘menus’ =&gt; [<br>    //              ‘assignment’ =&gt; [<br>    //                  ‘label’ =&gt; ‘aaa’ // 更改label<br>    //              ],<br>    //              ‘route’ =&gt; null, // 禁用菜单<br>                ]<br>             ],<br>        ],</p>
<pre><code>&apos;aliases&apos; =&gt; \[
    &apos;@mdm/admin&apos; =&gt; &apos;@vendor/mdmsoft/yii2-admin&apos;,
\],

&apos;as access&apos; =&gt; \[
    &apos;class&apos; =&gt; &apos;mdm\\admin\\components\\AccessControl&apos;,
    &apos;allowActions&apos; =&gt; \[</code></pre><p>//          ‘admin/*’<br>        ]<br>    ],<br>components数组内添加如下代码：<br>                //权限配置<br>        ‘authManager’ =&gt; [<br>            ‘class’ =&gt; ‘yii\rbac\DbManager’,<br>        ],</p>
<p>9、进入\backend\view\layout文件夹下left.php文件： 在section中添加如下代码：</p>
<pre><code>&lt;?php 
    use mdm\\admin\\components\\MenuHelper; 
    $callback = function($menu){ 
        $data = json_decode($menu\[&apos;data&apos;\], true); 
        $items = $menu\[&apos;children&apos;\]; 
        $return = \[ 
            &apos;label&apos; =&gt; $menu\[&apos;name&apos;\], 
            &apos;url&apos; =&gt; \[$menu\[&apos;route&apos;\]\], 
        \]; 
        //处理我们的配置 
        if ($data) { 
            //visible 
            isset($data\[&apos;visible&apos;\]) &amp;&amp; $return\[&apos;visible&apos;\] = $data\[&apos;visible&apos;\]; 
            //icon 
            isset($data\[&apos;icon&apos;\]) &amp;&amp; $data\[&apos;icon&apos;\] &amp;&amp; $return\[&apos;icon&apos;\] = $data\[&apos;icon&apos;\]; 
            //other attribute e.g. class... 
            $return\[&apos;options&apos;\] = $data; 
        } 
        //没配置图标的显示默认图标 
        (!isset($return\[&apos;icon&apos;\]) || !$return\[&apos;icon&apos;\]) &amp;&amp; $return\[&apos;icon&apos;\] = &apos;fa fa-circle-o&apos;; 
        $items &amp;&amp; $return\[&apos;items&apos;\] = $items; 
        return $return; 
    }; 
    //这里我们对一开始写的菜单menu进行了优化
    echo dmstr\\widgets\\Menu::widget( \[ 
        &apos;options&apos; =&gt; \[&apos;class&apos; =&gt; &apos;sidebar-menu&apos;\], 
        &apos;items&apos; =&gt; MenuHelper::getAssignedMenu(Yii::$app-&gt;user-&gt;id, null, $callback), 
    \] ); 
?&gt;</code></pre>]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>YII2数据库出现SQLSTATE[HY000] [2002]</title>
    <url>/2015/12/06/yii2-e6-95-b0-e6-8d-ae-e5-ba-93-e5-87-ba-e7-8e-b0sqlstatehy000-2002/</url>
    <content><![CDATA[<p>yii2.0操作数据库时出现如下错误：<br><a href="https://i.loli.net/2018/08/09/5b6bdc0267480.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdc0267480.png" alt="undefined" title="undefined"></a> 通过百度之后发现问题出现原因是在php.ini文件中未指定mysql.sock(或mysqld.sock)文件路径导致的PDO无法链接数据库。 解决方案： 1、找到自己的php.ini文件（可通过phpinfo()查询Loaded Configuration File对应的路径） 2、查询自己数据库使用的是mysql.sock还是mysqld.sock： 可通过以下命令查找：</p>
<p> mysqladmin -uroot -p -hlocalhost version</p>
<p><a href="https://i.loli.net/2018/08/09/5b6bdc15bb03f.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdc15bb03f.png" alt="undefined" title="undefined"></a> 3.打开php.ini文件，修改一下三行代码： 未修改代码：</p>
<p>pdo_mysql.default_socket=<br>mysql.default_socket =<br>mysqli.default_socket =</p>
<p>已修改代码：</p>
<p>pdo_mysql.default_socket=/var/lib/mysql/mysql.sock<br>mysql.default_socket =/var/lib/mysql/mysql.sock<br>mysqli.default_socket =/var/lib/mysql/mysql.sock</p>
<p>4、重启Apache即可。</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2打印AR操作的sql语句，非debug方式</title>
    <url>/2016/05/24/yii2-e6-89-93-e5-8d-b0ar-e6-93-8d-e4-bd-9c-e7-9a-84sql-e8-af-ad-e5-8f-a5-ef-bc-8c-e9-9d-9edebug-e6-96-b9-e5-bc-8f/</url>
    <content><![CDATA[<p>$query = User::find()<br>  -&gt;where([‘id’=&gt;[1,2,3,4])<br>  -&gt;select([‘username’])</p>
<p>// get the AR raw sql in YII2<br>$commandQuery = clone $query;<br>echo $commandQuery-&gt;createCommand()-&gt;getRawSql();</p>
<p>$users = $query-&gt;all();</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 数据库事务处理</title>
    <url>/2017/02/22/yii2-e6-95-b0-e6-8d-ae-e5-ba-93-e4-ba-8b-e5-8a-a1-e5-a4-84-e7-90-86/</url>
    <content><![CDATA[<pre><code>//事务开始
$transaction = \\Yii::$app-&gt;db-&gt;beginTransaction();
try {
    。。。
    。。。

    //事务执行
    $transaction-&gt;commit();
}catch (\\Exception $e){
    //事务回滚
    $transaction-&gt;rollBack();
}</code></pre>]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 批量插入数据</title>
    <url>/2016/06/14/yii2-e6-89-b9-e9-87-8f-e6-8f-92-e5-85-a5-e6-95-b0-e6-8d-ae/</url>
    <content><![CDATA[<p>代码如下：<br>$totalCount    =    100;<br>$count    =    0;<br>$data    =    [];<br>while($count &lt; $totalCount){<br>    $data[] =   [‘名字’.$count,’地址’.$count];<br>    $count++;<br>}<br>Yii::$app-&gt;db-&gt;createCommand()-&gt;batchInsert(‘`user`‘,[‘name’,’address’],$data)-&gt;execute();</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2查询SQL错误</title>
    <url>/2016/03/09/yii2-e6-9f-a5-e8-af-a2sql-e9-94-99-e8-af-af/</url>
    <content><![CDATA[<p>$model    =    new Model();<br>$model-&gt;name    =    ‘abc’;<br>$model-&gt;save();<br>var_dump($model-&gt;getErrors());</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 日期选择框使用</title>
    <url>/2015/12/03/yii2-e6-97-a5-e6-9c-9f-e9-80-89-e6-8b-a9-e6-a1-86-e4-bd-bf-e7-94-a8/</url>
    <content><![CDATA[<p>1、在做个人信息提交时，在生日一栏需要使用日期选择，如下图： <a href="https://i.loli.net/2018/08/09/5b6bdb81c97bd.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdb81c97bd.png" alt="undefined" title="undefined"></a> 2、查询后得知yii有一个组件可以使用，但我是在本地Windows系统上使用，所以网上查询的方法总是不可以使用，最后很无奈，决定直接使用bootstrap的日期时间选择器DateTimePicker。下载地址：<a href="http://www.bootcss.com/p/bootstrap-datetimepicker/index.htm" target="_blank" rel="noopener">http://www.bootcss.com/p/bootstrap-datetimepicker/index.htm</a> 3、将下载好的包放在你的yii项目中，我将其放在frontend\web\statics文件夹下，为方便使用将文件夹改名为datetimepicker： 4、在需要使用日期选择的页面直接使用： 页面注册css和js为：</p>
<?php

use frontend\\assets\\AppAsset; 
AppAsset::register($this);
$this->registerCssFile('@web/statics/datetimepicker/css/bootstrap-datetimepicker.min.css',\['depends'=>\['frontend\\assets\\AppAsset'\]\]); 
$this->registerJsFile('@web/statics/datetimepicker/js/bootstrap-datetimepicker.js',\['depends'=>\['frontend\\assets\\AppAsset'\]\]);
$this->registerJsFile('@web/statics/datetimepicker/js/locales/bootstrap-datetimepicker.zh-CN.js',\['depends'=>\['frontend\\assets\\AppAsset'\]\]);
$this->registerJs("$('#usersiteform-user_birthday').datetimepicker({format: 'yyyy-mm-dd',startView: 2,minView: 2,autoclose:true});");
?>

<p>调用日期选择为：</p>
<?= $form->field($model, 'user_birthday')->input('text',\['readonly'=>'readonly','data-provide'=>'datepicker','data-date-format'=>'yyyy-mm-dd','data-date-language'=>'zh-CN'\])->label('用户生日') ?>

<p>5、效果图如下： <a href="https://i.loli.net/2018/08/09/5b6bdba2e08e0.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdba2e08e0.png" alt="undefined" title="undefined"></a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 表单隐藏域</title>
    <url>/2016/06/30/yii2-e8-a1-a8-e5-8d-95-e9-9a-90-e8-97-8f-e5-9f-9f/</url>
    <content><![CDATA[<?= $form->field($model, 'name')->hiddenInput()->label(false) ?>

<p>以上代码为在form表单中使用一个name为‘name’的隐藏域</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2数据库操作</title>
    <url>/2016/10/09/yii2-e6-95-b0-e6-8d-ae-e5-ba-93-e6-93-8d-e4-bd-9c/</url>
    <content><![CDATA[<p>复杂查询：</p>
<p>where([‘and’,[‘user_id’=&gt;$id],[‘&gt;’,’create_time’,time()-3600*48]])-&gt;orderBy(‘create_time’)</p>
<p>关联操作查询：</p>
<p>/*</p>
<ul>
<li>查询用户48小时内的消息记录</li>
<li>/<br>public function getMsgList($id){<br>  $data   =   self::find()-&gt;joinWith(‘user’)-&gt;joinWith(‘adminUser’)-&gt;where([‘and’,[‘user_id’=&gt;$id],[‘&gt;’,’create_time’,time()-3600*48]])-&gt;orderBy(‘create_time’)-&gt;asArray()-&gt;all();<br>  return $data;<br>}</li>
</ul>
<p>/*</p>
<ul>
<li>关联模型user表</li>
<li>/<br>public function getUser(){<br>  return $this-&gt;hasOne(User::className(),[‘id（user表id）’=&gt;’user_id（本类id）’]);<br>}<br>/*</li>
<li>关联模型后台用户表</li>
<li>/<br>public function getAdminUser(){<br>  return $this-&gt;hasOne(AdminUser::className(),[‘id’=&gt;’admin_user’]);<br>}</li>
</ul>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2 view文件中加载指定js文件内容</title>
    <url>/2017/03/07/yii2-view-e6-96-87-e4-bb-b6-e4-b8-ad-e5-8a-a0-e8-bd-bd-e6-8c-87-e5-ae-9ajs-e6-96-87-e4-bb-b6-e5-86-85-e5-ae-b9/</url>
    <content><![CDATA[<p>yii2 在view文件中加载当前目录指定js文件内容，将其注册到本文件中而非引用js文件</p>
<p>$data = \backend\models\area\Area::find()-&gt;select(“code as id,area as text”)-&gt;asArray()-&gt;all();<br>$data = \yii\helpers\Json::htmlEncode($data);</p>
<p>$this-&gt;registerJs(“var data = {$data};”);<br>$this-&gt;registerJs($this-&gt;render(‘area.js’));</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2高级版添加新应用</title>
    <url>/2015/12/23/yii2-e9-ab-98-e7-ba-a7-e7-89-88-e6-b7-bb-e5-8a-a0-e6-96-b0-e5-ba-94-e7-94-a8/</url>
    <content><![CDATA[<p>1、复制frontend下的所有文件到api文件夹，批量替换frontend为api 2、打开\common\config\bootstrap.php，复制包含frontend的那一行，并将frontend改为api，为应用增加别名 3、打开\environments\index.php，复制包含frontend的行，改为api，Development和Production下的setWritable和setCookieValidationKey都要做相应复制和修改 4、复制\environments\dev和\environments\prod文件夹下的frontend到相同目录下，改名为api 5、运行CMD 进入安装目录中，执行init或在安装目录中运行init.bat，选择 0 开发模式进行安装 6、通过浏览器访问你指定的网址 <a href="https://i.loli.net/2018/08/09/5b6bdcc6210ea.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bdcc6210ea.png" alt="undefined" title="undefined"></a></p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2设置keywords和descripition</title>
    <url>/2015/12/27/yii2-e8-ae-be-e7-bd-aekeywords-e5-92-8cdescripition/</url>
    <content><![CDATA[<p>在yii2中设置keywords和descripition的方法为： 1、在需要设置的页面中添加如下代码： 第一种方法：</p>
<p>$this-&gt;registerMetaTag(array(“name”=&gt;”keywords”,”content”=&gt;”keywords关键词”);<br>$this-&gt;registerMetaTag(array(“name”=&gt;”descripition”,”content”=&gt;”descripition内容”);</p>
<p>第二种方法：</p>
<p>$this-&gt;metaTags[]=”<meta name="keywords" content="keywords关键词">“;<br>$this-&gt;metaTags[]=”<meta name="descripition" content="descripition内容">“;</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2网页内添加js代码</title>
    <url>/2016/10/11/yii2-e7-bd-91-e9-a1-b5-e5-86-85-e6-b7-bb-e5-8a-a0js-e4-bb-a3-e7-a0-81/</url>
    <content><![CDATA[<div class="click_me">点我弹出OK</div>  
<?php $this->beginBlock('test') ?>
    $(function($) {
    $('.click_me').click(function() {
    alert('OK');
    });
    });
<?php $this->endBlock() ?>
<?php $this->registerJs($this->blocks\['test'\], \\yii\\web\\View::POS_END); ?>

<p>将上述代码加入网页所在php文件即可</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>yii2session</title>
    <url>/2015/12/23/yii2session/</url>
    <content><![CDATA[<p>今天在使用session时发现一个问题，设置session变量名为6，值为true，每次设置完后输出结果正确，刷新之后再次调用该session则为null： 测试代码如下：</p>
<p>$session = Yii::$app-&gt;session;<br>if($session-&gt;get(6)){<br>    echo ‘获取到session’.$session-&gt;get(6);<br>}else{<br>    $session-&gt;set(6,true);<br>    echo ‘设置session’.$session-&gt;get(6);<br>}</p>
<p>执行结果永远是else中的，很明显出现错误，在百度上查询很久，没有遇上相同的问题，快放弃的时候，试了一下设置字符串’6’，还是不行，最后用’a6’却成功了，想了一下，才发现，在php中设置变量名是不能以数字开头的，session的变量名他也是变量啊，不能拿窝头不当干粮啊，所以session设置变量时不能以数字开头</p>
<p>$session = Yii::$app-&gt;session;<br>if($session-&gt;get(‘a6’)){<br>    echo ‘获取到session’.$session-&gt;get(‘a6’);<br>}else{<br>    $session-&gt;set(‘a6’,true);<br>    echo ‘设置session’.$session-&gt;get(‘a6’);<br>}</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>阿里云centos7.0安装golang1.7.1</title>
    <url>/2016/10/27/e9-98-bf-e9-87-8c-e4-ba-91centos7-0-e5-ae-89-e8-a3-85golang1-7-1/</url>
    <content><![CDATA[<p>一下为我阿里云服务器信息： <a href="https://i.loli.net/2018/08/09/5b6bde45c3e53.png" target="_blank" rel="noopener" title="undefined"><img src="https://i.loli.net/2018/08/09/5b6bde45c3e53.png" alt="undefined" title="undefined"></a> 下载golang1.7.1对应版本：</p>
<p>go1.7.1.linux-amd64.tar.gz</p>
<h1 id="tar-zxvf-go1-7-1-linux-amd64-tar-gz-C-usr-local"><a href="#tar-zxvf-go1-7-1-linux-amd64-tar-gz-C-usr-local" class="headerlink" title="tar zxvf go1.7.1.linux-amd64.tar.gz -C /usr/local"></a>tar zxvf go1.7.1.linux-amd64.tar.gz -C /usr/local</h1><p>新建GOPATH目录  </p>
<h1 id="mkdir-p-mnt-wwwroot-gofile"><a href="#mkdir-p-mnt-wwwroot-gofile" class="headerlink" title="mkdir -p /mnt/wwwroot/gofile"></a>mkdir -p /mnt/wwwroot/gofile</h1><h1 id="vim-etc-profile"><a href="#vim-etc-profile" class="headerlink" title="vim /etc/profile"></a>vim /etc/profile</h1><p>export GOROOT=/usr/local/go<br>export GOBIN=$GOROOT/bin<br>export PATH=$PATH:$GOBIN<br>export GOPATH=/mnt/wwwroot/gofile<br>:wq保存  </p>
<p>使其生效<br>#source /etc/profile  </p>
<p>查看是否配置成功  </p>
<h1 id="go-version"><a href="#go-version" class="headerlink" title="go version"></a>go version</h1><p>go version go1.7.1 linux/amd64  </p>
<p>简单测试：  </p>
<h1 id="cd-mnt-wwwroot-gofile"><a href="#cd-mnt-wwwroot-gofile" class="headerlink" title="cd /mnt/wwwroot/gofile"></a>cd /mnt/wwwroot/gofile</h1><h1 id="vim-hello-go"><a href="#vim-hello-go" class="headerlink" title="vim hello.go"></a>vim hello.go</h1><p>package main<br>import “fmt”<br>func main() {<br>    fmt.Println(“Hello, 世界”)<br>}  </p>
<h1 id="go-run-hello-go"><a href="#go-run-hello-go" class="headerlink" title="go run hello.go"></a>go run hello.go</h1><p>Hello, 世界</p>
]]></content>
      <categories>
        <category>全部文章</category>
      </categories>
  </entry>
  <entry>
    <title>flag包基本使用</title>
    <url>/2020/03/31/golang/flag%E5%8C%85%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>flag包实现了命令行参数的解析</p>
<h2 id="flag参数类型"><a href="#flag参数类型" class="headerlink" title="flag参数类型"></a>flag参数类型</h2><p>flag包支持的命令行参数类型有<code>bool</code>、<code>int</code>、<code>int64</code>、<code>uint</code>、<code>uint64</code>、<code>float</code> <code>float64</code>、<code>string</code>、<code>duration</code>。</p>
<table>
<thead>
<tr>
<th>字符串flag</th>
<th>合法字符串</th>
</tr>
</thead>
<tbody><tr>
<td>整数flag</td>
<td>1234、0664、0x1234等类型，也可以是负数。</td>
</tr>
<tr>
<td>浮点数flag</td>
<td>合法浮点数</td>
</tr>
<tr>
<td>bool类型flag</td>
<td>1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。</td>
</tr>
<tr>
<td>时间段flag</td>
<td>任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us”、“µs”、”ms”、”s”、”m”、”h”。</td>
</tr>
</tbody></table>
<h2 id="三种定义方式"><a href="#三种定义方式" class="headerlink" title="三种定义方式"></a>三种定义方式</h2><h3 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type()"></a>flag.Type()</h3><p>基本格式：其中 Type指针 可以是 Int、String，Bool 等；返回一个相应类型的指针</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag.Type(flag名, 默认值, 帮助信息)*Type</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">var ip &#x3D; flag.Int(&quot;flagname&quot;, 1234, &quot;help message for flagname&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数 ：flag名称为flagname</p>
</li>
<li><p>第二个参数 ：flagname默认值为1234</p>
</li>
<li><p>第三个参数 ：flagname的提示信息</p>
<p>返回的ip是指针类型，所以这种方式获取的值应该<code>fmt.Println(*ip)</code></p>
</li>
</ul>
<h3 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar()"></a>flag.TypeVar()</h3><p>基本格式：将 flag 绑定到一个变量上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">var flagValue int</span><br><span class="line">flag.IntVar(&amp;flagValue, &quot;flagname&quot;, 1234, &quot;help message for flagname&quot;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一个参数 ：接收flagname的实际值的</p>
</li>
<li><p>第二个参数 ：flag名称为flagname</p>
</li>
<li><p>第三个参数 ：flagname默认值为1234</p>
</li>
<li><p>第四个参数 ：flagname的提示信息</p>
<p>这种方式获取ip的值<code>fmt.Println(ip)</code>就可以了</p>
</li>
</ul>
<h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>自定义一个用于flag的类型（满足Value接口）并将该类型用于flag解析，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag.Var(&amp;flagVal, &quot;name&quot;, &quot;help message for flagname&quot;)</span><br></pre></td></tr></table></figure>

<p>对这种flag，默认值就是该变量的初始值</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义一个类型，用于增加该类型方法</span><br><span class="line">type interval []time.Duration</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 格式化flag.value</span><br><span class="line">func (i *interval) String() string &#123;</span><br><span class="line">    return fmt.Sprint(*i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Set is the method to set the flag value, part of the flag.Value interface.</span><br><span class="line">&#x2F;&#x2F; Set&#39;s argument is a string to be parsed to set the flag.</span><br><span class="line">&#x2F;&#x2F; It&#39;s a comma-separated list, so we split it.</span><br><span class="line">func (i *interval) Set(value string) error &#123;</span><br><span class="line">    &#x2F;&#x2F; If we wanted to allow the flag to be set multiple times,</span><br><span class="line">    &#x2F;&#x2F; accumulating values, we would delete this if statement.</span><br><span class="line">    &#x2F;&#x2F; That would permit usages such as</span><br><span class="line">    &#x2F;&#x2F;	-deltaT 10s -deltaT 15s</span><br><span class="line">    &#x2F;&#x2F; and other combinations.</span><br><span class="line">    if len(*i) &gt; 0 &#123;</span><br><span class="line">        return errors.New(&quot;interval flag already set&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    for _, dt :&#x3D; range strings.Split(value, &quot;,&quot;) &#123;</span><br><span class="line">        duration, err :&#x3D; time.ParseDuration(dt)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        *i &#x3D; append(*i, duration)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Define a flag to accumulate durations. Because it has a special type,</span><br><span class="line">&#x2F;&#x2F; we need to use the Var function and therefore create the flag during</span><br><span class="line">&#x2F;&#x2F; init.</span><br><span class="line">var intervalFlag interval</span><br><span class="line">func init() &#123;</span><br><span class="line">    &#x2F;&#x2F; Tie the command-line flag to the intervalFlag variable and</span><br><span class="line">    &#x2F;&#x2F; set a usage message.</span><br><span class="line">    flag.Var(&amp;intervalFlag, &quot;deltaT&quot;, &quot;comma-separated list of intervals to use between events&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="flag-Parse"><a href="#flag-Parse" class="headerlink" title="flag.Parse()"></a>flag.Parse()</h2><p>通过以上两种方法定义好命令行flag参数后，需要通过调用<code>flag.Parse()</code>来对命令行参数进行解析。</p>
<p>支持的命令行参数格式有以下几种：</p>
<ul>
<li><code>-flag xxx</code> （使用空格，一个<code>-</code>符号）</li>
<li><code>--flag xxx</code> （使用空格，两个<code>-</code>符号）</li>
<li><code>-flag=xxx</code> （使用等号，一个<code>-</code>符号）</li>
<li><code>--flag=xxx</code> （使用等号，两个<code>-</code>符号）</li>
</ul>
<p>其中，布尔类型的参数必须使用等号的方式指定。</p>
<p>Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。</p>
<p>如果bool类型的参数在命令行中用了<code>-flag false</code>这种形式时，其后的参数都会被当做非flag（non-flag）参数</p>
<h2 id="flag其他函数"><a href="#flag其他函数" class="headerlink" title="flag其他函数"></a>flag其他函数</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag.Args()  &#x2F;&#x2F;以[]string类型返回命令行参数后的其他参数</span><br><span class="line">flag.NArg()  &#x2F;&#x2F;返回命令行参数后的其他参数个数</span><br><span class="line">flag.NFlag() &#x2F;&#x2F;返回使用的命令行参数个数</span><br></pre></td></tr></table></figure>



<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F;定义命令行参数方式1</span><br><span class="line">	var name string</span><br><span class="line">	var age int</span><br><span class="line">	var married bool</span><br><span class="line">	var delay time.Duration</span><br><span class="line">	flag.StringVar(&amp;name, &quot;name&quot;, &quot;张三&quot;, &quot;姓名&quot;)</span><br><span class="line">	flag.IntVar(&amp;age, &quot;age&quot;, 18, &quot;年龄&quot;)</span><br><span class="line">	flag.BoolVar(&amp;married, &quot;married&quot;, false, &quot;婚否&quot;)</span><br><span class="line">	flag.DurationVar(&amp;delay, &quot;d&quot;, 0, &quot;延迟的时间间隔&quot;)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;解析命令行参数</span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(name, age, married, delay)</span><br><span class="line">	&#x2F;&#x2F;返回命令行参数后的其他参数</span><br><span class="line">	fmt.Println(flag.Args())</span><br><span class="line">	&#x2F;&#x2F;返回命令行参数后的其他参数个数</span><br><span class="line">	fmt.Println(flag.NArg())</span><br><span class="line">	&#x2F;&#x2F;返回使用的命令行参数个数</span><br><span class="line">	fmt.Println(flag.NFlag())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; These examples demonstrate more intricate uses of the flag package.</span><br><span class="line">package flag_test</span><br><span class="line">import (</span><br><span class="line">    &quot;errors&quot;</span><br><span class="line">    &quot;flag&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;strings&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; Example 1: A single string flag called &quot;species&quot; with default value &quot;gopher&quot;.</span><br><span class="line">var species &#x3D; flag.String(&quot;species&quot;, &quot;gopher&quot;, &quot;the species we are studying&quot;)</span><br><span class="line">&#x2F;&#x2F; Example 2: Two flags sharing a variable, so we can have a shorthand.</span><br><span class="line">&#x2F;&#x2F; The order of initialization is undefined, so make sure both use the</span><br><span class="line">&#x2F;&#x2F; same default value. They must be set up with an init function.</span><br><span class="line">var gopherType string</span><br><span class="line">func init() &#123;</span><br><span class="line">    const (</span><br><span class="line">        defaultGopher &#x3D; &quot;pocket&quot;</span><br><span class="line">        usage         &#x3D; &quot;the variety of gopher&quot;</span><br><span class="line">    )</span><br><span class="line">    flag.StringVar(&amp;gopherType, &quot;gopher_type&quot;, defaultGopher, usage)</span><br><span class="line">    flag.StringVar(&amp;gopherType, &quot;g&quot;, defaultGopher, usage+&quot; (shorthand)&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Example 3: A user-defined flag type, a slice of durations.</span><br><span class="line">type interval []time.Duration</span><br><span class="line">&#x2F;&#x2F; String is the method to format the flag&#39;s value, part of the flag.Value interface.</span><br><span class="line">&#x2F;&#x2F; The String method&#39;s output will be used in diagnostics.</span><br><span class="line">func (i *interval) String() string &#123;</span><br><span class="line">    return fmt.Sprint(*i)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Set is the method to set the flag value, part of the flag.Value interface.</span><br><span class="line">&#x2F;&#x2F; Set&#39;s argument is a string to be parsed to set the flag.</span><br><span class="line">&#x2F;&#x2F; It&#39;s a comma-separated list, so we split it.</span><br><span class="line">func (i *interval) Set(value string) error &#123;</span><br><span class="line">    &#x2F;&#x2F; If we wanted to allow the flag to be set multiple times,</span><br><span class="line">    &#x2F;&#x2F; accumulating values, we would delete this if statement.</span><br><span class="line">    &#x2F;&#x2F; That would permit usages such as</span><br><span class="line">    &#x2F;&#x2F;	-deltaT 10s -deltaT 15s</span><br><span class="line">    &#x2F;&#x2F; and other combinations.</span><br><span class="line">    if len(*i) &gt; 0 &#123;</span><br><span class="line">        return errors.New(&quot;interval flag already set&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    for _, dt :&#x3D; range strings.Split(value, &quot;,&quot;) &#123;</span><br><span class="line">        duration, err :&#x3D; time.ParseDuration(dt)</span><br><span class="line">        if err !&#x3D; nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">        *i &#x3D; append(*i, duration)</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Define a flag to accumulate durations. Because it has a special type,</span><br><span class="line">&#x2F;&#x2F; we need to use the Var function and therefore create the flag during</span><br><span class="line">&#x2F;&#x2F; init.</span><br><span class="line">var intervalFlag interval</span><br><span class="line">func init() &#123;</span><br><span class="line">    &#x2F;&#x2F; Tie the command-line flag to the intervalFlag variable and</span><br><span class="line">    &#x2F;&#x2F; set a usage message.</span><br><span class="line">    flag.Var(&amp;intervalFlag, &quot;deltaT&quot;, &quot;comma-separated list of intervals to use between events&quot;)</span><br><span class="line">&#125;</span><br><span class="line">func Example() &#123;</span><br><span class="line">    &#x2F;&#x2F; All the interesting pieces are with the variables declared above, but</span><br><span class="line">    &#x2F;&#x2F; to enable the flag package to see the flags defined there, one must</span><br><span class="line">    &#x2F;&#x2F; execute, typically at the start of main (not init!):</span><br><span class="line">    &#x2F;&#x2F;	flag.Parse()</span><br><span class="line">    &#x2F;&#x2F; We don&#39;t run it here because this is not a main function and</span><br><span class="line">    &#x2F;&#x2F; the testing suite has already parsed the flags.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="os-Args"><a href="#os-Args" class="headerlink" title="os.Args"></a>os.Args</h2><p><code>os.Args</code>是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。</p>
<p>如果你只是简单的想要获取命令行参数，可以像下面的代码示例一样使用<code>os.Args</code>来获取命令行参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;os.Args demo</span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F;os.Args是一个[]string</span><br><span class="line">	if len(os.Args) &gt; 0 &#123;</span><br><span class="line">		for index, arg :&#x3D; range os.Args &#123;</span><br><span class="line">			fmt.Printf(&quot;args[%d]&#x3D;%v\n&quot;, index, arg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将上面的代码执行<code>go build -o &quot;args_demo&quot;</code>编译之后，执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;args_demo a b c d</span><br><span class="line">args[0]&#x3D;.&#x2F;args_demo</span><br><span class="line">args[1]&#x3D;a</span><br><span class="line">args[2]&#x3D;b</span><br><span class="line">args[3]&#x3D;c</span><br><span class="line">args[4]&#x3D;d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Context源码分析</title>
    <url>/2020/03/31/golang/context%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h3><p>对服务器传入的请求应该创建上下文，而对服务器的传出调用应该接受上下文。它们之间的函数调用链必须传递上下文，或者可以使用<code>WithCancel</code>、<code>WithDeadline</code>、<code>WithTimeout</code>或<code>WithValue</code>创建的派生上下文。当一个上下文被取消时，它派生的所有上下文也被取消。</p>
<p><code>context.Context</code>是一个接口，该接口定义了四个需要实现的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Context interface &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok bool)</span><br><span class="line">    Done() &lt;-chan struct&#123;&#125;</span><br><span class="line">    Err() error</span><br><span class="line">    Value(key interface&#123;&#125;) interface&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到Context是一个interface，在golang里面，interface是一个使用非常广泛的结构，它可以接纳任何类型。Context定义很简单，一共4个方法，我们需要能够很好的理解这几个方法</p>
<ol>
<li>Deadline方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</li>
<li>Done方法返回一个只读的chan，类型为struct{}，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过Done方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。之后，Err 方法会返回一个错误，告知为什么 Context 被取消。</li>
<li>Err方法返回当前 <code>context</code> 结束的原因，只会在<code>Done</code>返回的Chan被关闭时才会返回非空的值。<ul>
<li>如果当前 <code>Context</code> 被取消就会返回 <code>Canceled</code> 的错误</li>
<li>如果当前 <code>Context</code> 超时就会返回 <code>DeadlineExceeded</code> 错误</li>
</ul>
</li>
<li>Value方法获取该Context上绑定的值，是一个键值对，所以要通过一个Key才可以获取对应的值，这个值一般是线程安全的。对于同一个上下文来说，多次调用<code>Value</code> 并传入相同的<code>Key</code>会返回相同的结果，该方法仅用于传递跨API和进程间跟请求域的数据</li>
</ol>
<h4 id="源码提供的四个-Context-实现"><a href="#源码提供的四个-Context-实现" class="headerlink" title="源码提供的四个 Context 实现"></a>源码提供的四个 <code>Context</code> 实现</h4><ol>
<li><p><code>emptyCtx</code> 完全空的 <code>Context</code> ，实现的函数也都是返回nil，仅仅是实现了 <code>Context</code> 的接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; emptyCtx永远不会被取消，没有值，也没有截止日期。It is not</span><br><span class="line">&#x2F;&#x2F; struct&#123;&#125;, 因为这种类型的变量必须有不同的地址。</span><br><span class="line">type emptyCtx int</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Deadline() (deadline time.Time, ok bool) &#123;</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Done() &lt;-chan struct&#123;&#125; &#123;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Err() error &#123;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*emptyCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *emptyCtx) String() string &#123;</span><br><span class="line">	switch e &#123;</span><br><span class="line">	case background:</span><br><span class="line">		return &quot;context.Background&quot;</span><br><span class="line">	case todo:</span><br><span class="line">		return &quot;context.TODO&quot;</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;unknown empty Context&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><code>cancelCtx</code> 继承自 <code>Context</code> ，同时也实现了 <code>canceler</code> 接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; cancelCtx可以被取消。当取消时，它也取消了所有的子节点</span><br><span class="line">&#x2F;&#x2F; 实现canceler。</span><br><span class="line">type cancelCtx struct &#123;</span><br><span class="line">	Context</span><br><span class="line"></span><br><span class="line">	mu       sync.Mutex            &#x2F;&#x2F; protects following fields</span><br><span class="line">	done     chan struct&#123;&#125;         &#x2F;&#x2F; created lazily, closed by first cancel call</span><br><span class="line">	children map[canceler]struct&#123;&#125; &#x2F;&#x2F; set to nil by the first cancel call</span><br><span class="line">	err      error                 &#x2F;&#x2F; set to non-nil by the first cancel call</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) Done() &lt;-chan struct&#123;&#125; &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	if c.done &#x3D;&#x3D; nil &#123;</span><br><span class="line">		c.done &#x3D; make(chan struct&#123;&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	d :&#x3D; c.done</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	return d</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) Err() error &#123;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	err :&#x3D; c.err</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type stringer interface &#123;</span><br><span class="line">	String() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func contextName(c Context) string &#123;</span><br><span class="line">	if s, ok :&#x3D; c.(stringer); ok &#123;</span><br><span class="line">		return s.String()</span><br><span class="line">	&#125;</span><br><span class="line">	return reflectlite.TypeOf(c).String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *cancelCtx) String() string &#123;</span><br><span class="line">	return contextName(c.Context) + &quot;.WithCancel&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cancel closes c.done, cancels each of c&#39;s children, and, if</span><br><span class="line">&#x2F;&#x2F; removeFromParent is true, removes c from its parent&#39;s children.</span><br><span class="line">&#x2F;&#x2F;核心是关闭c.done</span><br><span class="line">&#x2F;&#x2F;同时会设置c.err &#x3D; err, c.children &#x3D; nil</span><br><span class="line">&#x2F;&#x2F;依次遍历c.children，每个child分别cancel</span><br><span class="line">&#x2F;&#x2F;如果设置了removeFromParent，则将c从其parent的children中删除</span><br><span class="line">func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">	if err &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(&quot;context: internal error: missing cancel error&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	if c.err !&#x3D; nil &#123;</span><br><span class="line">		c.mu.Unlock()</span><br><span class="line">		return &#x2F;&#x2F; already canceled</span><br><span class="line">	&#125;</span><br><span class="line">	c.err &#x3D; err</span><br><span class="line">	if c.done &#x3D;&#x3D; nil &#123;</span><br><span class="line">		c.done &#x3D; closedchan</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		close(c.done)</span><br><span class="line">	&#125;</span><br><span class="line">	for child :&#x3D; range c.children &#123;</span><br><span class="line">		&#x2F;&#x2F; NOTE: acquiring the child&#39;s lock while holding parent&#39;s lock.</span><br><span class="line">		child.cancel(false, err)</span><br><span class="line">	&#125;</span><br><span class="line">	c.children &#x3D; nil</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	if removeFromParent &#123;</span><br><span class="line">		removeChild(c.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，所有的children都存在一个map中；Done方法会返回其中的done channel， 而另外的cancel方法会关闭Done channel并且逐层向下遍历，关闭children的channel，并且将当前canceler从parent中移除</p>
</li>
<li><p><code>timerCtx</code> 继承自 <code>cancelCtx</code> ，增加了 <code>timeout</code> 机制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; A timerCtx carries a timer and a deadline. It embeds a cancelCtx to</span><br><span class="line">&#x2F;&#x2F; implement Done and Err. It implements cancel by stopping its timer then</span><br><span class="line">&#x2F;&#x2F; delegating to cancelCtx.cancel.</span><br><span class="line">type timerCtx struct &#123;</span><br><span class="line">	cancelCtx</span><br><span class="line">	timer *time.Timer &#x2F;&#x2F; Under cancelCtx.mu.</span><br><span class="line"></span><br><span class="line">	deadline time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *timerCtx) Deadline() (deadline time.Time, ok bool) &#123;</span><br><span class="line">	return c.deadline, true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *timerCtx) String() string &#123;</span><br><span class="line">	return contextName(c.cancelCtx.Context) + &quot;.WithDeadline(&quot; +</span><br><span class="line">		c.deadline.String() + &quot; [&quot; +</span><br><span class="line">		time.Until(c.deadline).String() + &quot;])&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *timerCtx) cancel(removeFromParent bool, err error) &#123;</span><br><span class="line">	c.cancelCtx.cancel(false, err)</span><br><span class="line">	if removeFromParent &#123;</span><br><span class="line">		&#x2F;&#x2F; Remove this timerCtx from its parent cancelCtx&#39;s children.</span><br><span class="line">		removeChild(c.cancelCtx.Context, c)</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	if c.timer !&#x3D; nil &#123;</span><br><span class="line">		c.timer.Stop()</span><br><span class="line">		c.timer &#x3D; nil</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p><code>valueCtx</code> 存储键值对的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; A valueCtx carries a key-value pair. It implements Value for that key and</span><br><span class="line">&#x2F;&#x2F; delegates all other calls to the embedded Context.</span><br><span class="line">type valueCtx struct &#123;</span><br><span class="line">	Context</span><br><span class="line">	key, val interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; stringify tries a bit to stringify v, without using fmt, since we don&#39;t</span><br><span class="line">&#x2F;&#x2F; want context depending on the unicode tables. This is only used by</span><br><span class="line">&#x2F;&#x2F; *valueCtx.String().</span><br><span class="line">func stringify(v interface&#123;&#125;) string &#123;</span><br><span class="line">	switch s :&#x3D; v.(type) &#123;</span><br><span class="line">	case stringer:</span><br><span class="line">		return s.String()</span><br><span class="line">	case string:</span><br><span class="line">		return s</span><br><span class="line">	&#125;</span><br><span class="line">	return &quot;&lt;not Stringer&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *valueCtx) String() string &#123;</span><br><span class="line">	return contextName(c.Context) + &quot;.WithValue(type &quot; +</span><br><span class="line">		reflectlite.TypeOf(c.key).String() +</span><br><span class="line">		&quot;, val &quot; + stringify(c.val) + &quot;)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *valueCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;</span><br><span class="line">	if c.key &#x3D;&#x3D; key &#123;</span><br><span class="line">		return c.val</span><br><span class="line">	&#125;</span><br><span class="line">	return c.Context.Value(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="Background-和TODO"><a href="#Background-和TODO" class="headerlink" title="Background()和TODO()"></a>Background()和TODO()</h3><ol>
<li>Background，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context，它不能被取消。它是一个emptyCtx的实例。可以认为所有的Context是树的结构，Background是树的根，当任一Context被取消的时候，那么继承它的Context 都将被回收。</li>
<li>TODO，如果我们不知道该使用什么Context的时候，可以使用这个，但是实际应用中，暂时还没有使用过这个TODO</li>
</ol>
<p>他们两个本质上都是emptyCtx结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var (</span><br><span class="line">	background &#x3D; new(emptyCtx)</span><br><span class="line">	todo       &#x3D; new(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Background返回一个非空的上下文。它从来没有被取消过，没有</span><br><span class="line">&#x2F;&#x2F; 值，并且没有最后期限。它通常由主函数使用，</span><br><span class="line">&#x2F;&#x2F; 初始化和测试，并作为传入的顶级上下文</span><br><span class="line">&#x2F;&#x2F; 请求。</span><br><span class="line">func Background() Context &#123;</span><br><span class="line">	return background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; TODO返回一个非nil的空上下文。代码应该使用上下文。待办事项时</span><br><span class="line">&#x2F;&#x2F; 不清楚使用哪个上下文，或者还没有可用的上下文(因为</span><br><span class="line">&#x2F;&#x2F; 还没有扩展到接受上下文参数)。</span><br><span class="line">func TODO() Context &#123;</span><br><span class="line">	return todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="With-系列函数"><a href="#With-系列函数" class="headerlink" title="With 系列函数"></a><code>With</code> 系列函数</h3><h4 id="WithCancel"><a href="#WithCancel" class="headerlink" title="WithCancel"></a><code>WithCancel</code></h4><p>初始化一个cancelCtx的同时，还执行了propagateCancel方法，最后返回一个cancel function</p>
<p>传递一个父<code>Context</code>作为参数，返回子<code>Context</code>，以及一个取消函数用来取消<code>Context</code></p>
<p><code>WithCancel</code>返回带有新<code>Done</code>通道的父节点的副本。当调用返回的<code>cancel</code>函数或当关闭父上下文的<code>Done</code>通道时，将关闭返回上下文的<code>Done</code>通道，无论先发生什么情况。</p>
<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WithCancel returns a copy of parent with a new Done channel. The returned</span><br><span class="line">&#x2F;&#x2F; context&#39;s Done channel is closed when the returned cancel function is called</span><br><span class="line">&#x2F;&#x2F; or when the parent context&#39;s Done channel is closed, whichever happens first.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Canceling this context releases resources associated with it, so code should</span><br><span class="line">&#x2F;&#x2F; call cancel as soon as the operations running in this Context complete.</span><br><span class="line">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">	c :&#x3D; newCancelCtx(parent)</span><br><span class="line">	propagateCancel(parent, &amp;c)</span><br><span class="line">	return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WithDeadline"><a href="#WithDeadline" class="headerlink" title="WithDeadline"></a><code>WithDeadline</code></h4><p>和WithCancel差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消</p>
<p>取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用cancel。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WithDeadline returns a copy of the parent context with the deadline adjusted</span><br><span class="line">&#x2F;&#x2F; to be no later than d. If the parent&#39;s deadline is already earlier than d,</span><br><span class="line">&#x2F;&#x2F; WithDeadline(parent, d) is semantically equivalent to parent. The returned</span><br><span class="line">&#x2F;&#x2F; context&#39;s Done channel is closed when the deadline expires, when the returned</span><br><span class="line">&#x2F;&#x2F; cancel function is called, or when the parent context&#39;s Done channel is</span><br><span class="line">&#x2F;&#x2F; closed, whichever happens first.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Canceling this context releases resources associated with it, so code should</span><br><span class="line">&#x2F;&#x2F; call cancel as soon as the operations running in this Context complete.</span><br><span class="line">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) &#123;</span><br><span class="line">	if cur, ok :&#x3D; parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line">		&#x2F;&#x2F; The current deadline is already sooner than the new one.</span><br><span class="line">		return WithCancel(parent)</span><br><span class="line">	&#125;</span><br><span class="line">	c :&#x3D; &amp;timerCtx&#123;</span><br><span class="line">		cancelCtx: newCancelCtx(parent),</span><br><span class="line">		deadline:  d,</span><br><span class="line">	&#125;</span><br><span class="line">	propagateCancel(parent, c)</span><br><span class="line">	dur :&#x3D; time.Until(d)</span><br><span class="line">	if dur &lt;&#x3D; 0 &#123;</span><br><span class="line">		c.cancel(true, DeadlineExceeded) &#x2F;&#x2F; deadline has already passed</span><br><span class="line">		return c, func() &#123; c.cancel(false, Canceled) &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	c.mu.Lock()</span><br><span class="line">	defer c.mu.Unlock()</span><br><span class="line">	if c.err &#x3D;&#x3D; nil &#123;</span><br><span class="line">		c.timer &#x3D; time.AfterFunc(dur, func() &#123;</span><br><span class="line">			c.cancel(true, DeadlineExceeded)</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	return c, func() &#123; c.cancel(true, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WithTimeout"><a href="#WithTimeout" class="headerlink" title="WithTimeout"></a><code>WithTimeout</code></h4><p>WithTimeout和WithDeadline基本上一样，这个表示是超时自动取消，是多少时间后自动取消Context的意思。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Canceling this context releases resources associated with it, so code should</span><br><span class="line">&#x2F;&#x2F; call cancel as soon as the operations running in this Context complete:</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 	func slowOperationWithTimeout(ctx context.Context) (Result, error) &#123;</span><br><span class="line">&#x2F;&#x2F; 		ctx, cancel :&#x3D; context.WithTimeout(ctx, 100*time.Millisecond)</span><br><span class="line">&#x2F;&#x2F; 		defer cancel()  &#x2F;&#x2F; releases resources if slowOperation completes before timeout elapses</span><br><span class="line">&#x2F;&#x2F; 		return slowOperation(ctx)</span><br><span class="line">&#x2F;&#x2F; 	&#125;</span><br><span class="line">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) &#123;</span><br><span class="line">	return WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WithValue"><a href="#WithValue" class="headerlink" title="WithValue"></a><code>WithValue</code></h4><p><code>WithValue</code>函数能够将请求作用域的数据与 Context 对象建立关系</p>
<p><code>WithValue</code>返回父节点的副本，其中与key关联的值为val。</p>
<p>仅对API和进程间传递请求域的数据使用上下文值，而不是使用它来传递可选参数给函数。</p>
<p>所提供的键必须是可比较的，并且不应该是<code>string</code>类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。<code>WithValue</code>的用户应该为键定义自己的类型。为了避免在分配给interface{}时进行分配，上下文键通常具有具体类型<code>struct{}</code>。或者，导出的上下文关键变量的静态类型应该是指针或接口。</p>
<p>WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到，这是我们实际用经常要用到的技巧，一般我们想要通过上下文来传递数据时，可以通过这个方法，如我们需要tarce追踪系统调用栈的时候。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; WithValue returns a copy of parent in which the value associated with key is</span><br><span class="line">&#x2F;&#x2F; val.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; Use context Values only for request-scoped data that transits processes and</span><br><span class="line">&#x2F;&#x2F; APIs, not for passing optional parameters to functions.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; The provided key must be comparable and should not be of type</span><br><span class="line">&#x2F;&#x2F; string or any other built-in type to avoid collisions between</span><br><span class="line">&#x2F;&#x2F; packages using context. Users of WithValue should define their own</span><br><span class="line">&#x2F;&#x2F; types for keys. To avoid allocating when assigning to an</span><br><span class="line">&#x2F;&#x2F; interface&#123;&#125;, context keys often have concrete type</span><br><span class="line">&#x2F;&#x2F; struct&#123;&#125;. Alternatively, exported context key variables&#39; static</span><br><span class="line">&#x2F;&#x2F; type should be a pointer or interface.</span><br><span class="line">func WithValue(parent Context, key, val interface&#123;&#125;) Context &#123;</span><br><span class="line">	if key &#x3D;&#x3D; nil &#123;</span><br><span class="line">		panic(&quot;nil key&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	if !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">		panic(&quot;key is not comparable&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="propagateCancel-方法"><a href="#propagateCancel-方法" class="headerlink" title="propagateCancel 方法"></a><code>propagateCancel</code> 方法</h3><p>propagateCancel 的含义就是传递cancel，从当前传入的parent开始（包括该parent），向上查找最近的一个可以被cancel的parent， 如果找到的parent已经被cancel，则将方才传入的child树给cancel掉，否则，将child节点直接连接为找到的parent的children中（Context字段不变，即向上的父亲指针不变，但是向下的孩子指针变直接了）； 如果没有找到最近的可以被cancel的parent，即其上都不可被cancel，则启动一个goroutine等待传入的parent终止，则cancel传入的child树，或者等待传入的child终结。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; propagateCancel arranges for child to be canceled when parent is.</span><br><span class="line">&#x2F;&#x2F; 当父进程被取消时，propagateCancel会安排子进程被取消</span><br><span class="line">func propagateCancel(parent Context, child canceler) &#123;</span><br><span class="line">	if parent.Done() &#x3D;&#x3D; nil &#123;</span><br><span class="line">		return &#x2F;&#x2F; parent is never canceled</span><br><span class="line">	&#125;</span><br><span class="line">	if p, ok :&#x3D; parentCancelCtx(parent); ok &#123;</span><br><span class="line">		p.mu.Lock()</span><br><span class="line">		if p.err !&#x3D; nil &#123;</span><br><span class="line">			&#x2F;&#x2F; parent has already been canceled</span><br><span class="line">			child.cancel(false, p.err)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			if p.children &#x3D;&#x3D; nil &#123;</span><br><span class="line">				p.children &#x3D; make(map[canceler]struct&#123;&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			p.children[child] &#x3D; struct&#123;&#125;&#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		p.mu.Unlock()</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-parent.Done():</span><br><span class="line">				child.cancel(false, parent.Err())</span><br><span class="line">			case &lt;-child.Done():</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Context-使用原则和技巧"><a href="#Context-使用原则和技巧" class="headerlink" title="Context 使用原则和技巧"></a><code>Context</code> 使用原则和技巧</h3><ul>
<li>推荐以参数的方式显示传递Context，不要放到结构体中；parent Context一般为Background</li>
<li>应该把Context作为第一个参数传递给入口请求和出口请求链路上的每一个函数，放在第一位，变量名建议都统一，如ctx</li>
<li>给一个函数方法传递Context的时候，不要传递nil，如果不知道传递什么，就使用context.TODO()</li>
<li>Context的Value相关方法应该传递请求域的必要数据，不应该用于传递可选参数</li>
<li>Context是线程安全的，可以放心的在多个goroutine中传递</li>
<li>可以把一个 Context 对象传递给任意个数的 gorotuine，对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</li>
</ul>
<h3 id="常用方法示例"><a href="#常用方法示例" class="headerlink" title="常用方法示例"></a>常用方法示例</h3><ol>
<li><p><code>WithCancel</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func gen(ctx context.Context) &lt;-chan int &#123;</span><br><span class="line">		dst :&#x3D; make(chan int)</span><br><span class="line">		n :&#x3D; 1</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for &#123;</span><br><span class="line">				select &#123;</span><br><span class="line">				case &lt;-ctx.Done():</span><br><span class="line">					return &#x2F;&#x2F; return结束该goroutine，防止泄露</span><br><span class="line">				case dst &lt;- n:</span><br><span class="line">					n++</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">		return dst</span><br><span class="line">	&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">	ctx, cancel :&#x3D; context.WithCancel(context.Background())</span><br><span class="line">	defer cancel() &#x2F;&#x2F; 当我们取完需要的整数后调用cancel</span><br><span class="line"></span><br><span class="line">	for n :&#x3D; range gen(ctx) &#123;</span><br><span class="line">		fmt.Println(n)</span><br><span class="line">		if n &#x3D;&#x3D; 5 &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的示例代码中，<code>gen</code>函数在单独的goroutine中生成整数并将它们发送到返回的通道。 gen的调用者在使用生成的整数之后需要取消上下文，以免<code>gen</code>启动的内部goroutine发生泄漏。</p>
</li>
<li><p><code>WithDeadline</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	d :&#x3D; time.Now().Add(50 * time.Millisecond)</span><br><span class="line">	ctx, cancel :&#x3D; context.WithDeadline(context.Background(), d)</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。</span><br><span class="line">	&#x2F;&#x2F; 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。</span><br><span class="line">	defer cancel()</span><br><span class="line"></span><br><span class="line">	select &#123;</span><br><span class="line">	case &lt;-time.After(1 * time.Second):</span><br><span class="line">		fmt.Println(&quot;overslept&quot;)</span><br><span class="line">	case &lt;-ctx.Done():</span><br><span class="line">		fmt.Println(ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，定义了一个50毫秒之后过期的deadline，然后我们调用<code>context.WithDeadline(context.Background(), d)</code>得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个select让主程序陷入等待：等待1秒后打印<code>overslept</code>退出或者等待ctx过期后退出。 因为ctx50秒后就过期，所以<code>ctx.Done()</code>会先接收到值，上面的代码会打印ctx.Err()取消原因</p>
</li>
<li><p><code>WithTimeout</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line"></span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; context.WithTimeout</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func worker(ctx context.Context) &#123;</span><br><span class="line">LOOP:</span><br><span class="line">	for &#123;</span><br><span class="line">		fmt.Println(&quot;db connecting ...&quot;)</span><br><span class="line">		time.Sleep(time.Millisecond * 10) &#x2F;&#x2F; 假设正常连接数据库耗时10毫秒</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done(): &#x2F;&#x2F; 50毫秒后自动调用</span><br><span class="line">			break LOOP</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;worker done!&quot;)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 设置一个50毫秒的超时</span><br><span class="line">	ctx, cancel :&#x3D; context.WithTimeout(context.Background(), time.Millisecond*50)</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go worker(ctx)</span><br><span class="line">	time.Sleep(time.Second * 5)</span><br><span class="line">	cancel() &#x2F;&#x2F; 通知子goroutine结束</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>WithValue</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line"></span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; context.WithValue</span><br><span class="line"></span><br><span class="line">type TraceCode string</span><br><span class="line"></span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func worker(ctx context.Context) &#123;</span><br><span class="line">	key :&#x3D; TraceCode(&quot;TRACE_CODE&quot;)</span><br><span class="line">	traceCode, ok :&#x3D; ctx.Value(key).(string) &#x2F;&#x2F; 在子goroutine中获取trace code</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		fmt.Println(&quot;invalid trace code&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">LOOP:</span><br><span class="line">	for &#123;</span><br><span class="line">		fmt.Printf(&quot;worker, trace code:%s\n&quot;, traceCode)</span><br><span class="line">		time.Sleep(time.Millisecond * 10) &#x2F;&#x2F; 假设正常连接数据库耗时10毫秒</span><br><span class="line">		select &#123;</span><br><span class="line">		case &lt;-ctx.Done(): &#x2F;&#x2F; 50毫秒后自动调用</span><br><span class="line">			break LOOP</span><br><span class="line">		default:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;worker done!&quot;)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	&#x2F;&#x2F; 设置一个50毫秒的超时</span><br><span class="line">	ctx, cancel :&#x3D; context.WithTimeout(context.Background(), time.Millisecond*50)</span><br><span class="line">	&#x2F;&#x2F; 在系统的入口中设置trace code传递给后续启动的goroutine实现日志数据聚合</span><br><span class="line">	ctx &#x3D; context.WithValue(ctx, TraceCode(&quot;TRACE_CODE&quot;), &quot;12512312234&quot;)</span><br><span class="line">	wg.Add(1)</span><br><span class="line">	go worker(ctx)</span><br><span class="line">	time.Sleep(time.Second * 5)</span><br><span class="line">	cancel() &#x2F;&#x2F; 通知子goroutine结束</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(&quot;over&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ol>
<p>参考链接：</p>
<ol>
<li><a href="https://studygolang.com/static/pkgdoc/" target="_blank" rel="noopener">https://studygolang.com/static/pkgdoc/</a></li>
<li><a href="https://www.liwenzhou.com/posts/Go/go_context/" target="_blank" rel="noopener">https://www.liwenzhou.com/posts/Go/go_context/</a></li>
<li><a href="https://www.jianshu.com/p/e5df3cd0708b" target="_blank" rel="noopener">https://www.jianshu.com/p/e5df3cd0708b</a></li>
<li><a href="https://blog.csdn.net/u011957758/article/details/82948750" target="_blank" rel="noopener">https://blog.csdn.net/u011957758/article/details/82948750</a></li>
</ol>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang学习</tag>
      </tags>
  </entry>
  <entry>
    <title>gin binding返回自定义错误信息</title>
    <url>/2020/03/31/golang/gin%E4%BD%BF%E7%94%A8bind%E8%BF%94%E5%9B%9E%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h3 id="使用ShouldBind示例"><a href="#使用ShouldBind示例" class="headerlink" title="使用ShouldBind示例"></a>使用<code>ShouldBind</code>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个结构体绑定请求数据</span><br><span class="line">type RequestUserLogin struct &#123;</span><br><span class="line">	Username string &#96;form:&quot;username&quot; json:&quot;username&quot; xml:&quot;username&quot; binding:&quot;required&quot;&#96;</span><br><span class="line">	Password string &#96;form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data :&#x3D; new(RequestUserLogin)</span><br><span class="line">if err :&#x3D; c.ShouldBind(data); err !&#x3D; nil &#123;</span><br><span class="line">	c.JSON(http.StatusForbidden, gin.H&#123;&quot;error&quot;: err.Error()&#125;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到的错误提示大概时这样子的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;error&quot;:&quot;Key: &#39;RequestAdminUserLogin.Password&#39; Error:Field validation for &#39;Password&#39; failed on the &#39;required&#39; tag&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="该怎么样给api提供一个友好的错误信息呢？"><a href="#该怎么样给api提供一个友好的错误信息呢？" class="headerlink" title="该怎么样给api提供一个友好的错误信息呢？"></a>该怎么样给api提供一个友好的错误信息呢？</h3><ol>
<li><p>首先，判断<code>ShouldBind</code>返回的底层类型是什么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(reflect.TypeOf(err))</span><br></pre></td></tr></table></figure>

<p>打印的信息是：<code>validator.ValidationErrors</code></p>
</li>
<li><p>让我们看看<code>validator.ValidationErrors</code>究竟是什么</p>
<p>通过查看源码我们可以看到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type ValidationErrors []FieldError</span><br></pre></td></tr></table></figure>

<p>原来它是一个<code>FieldError</code>类型的切片；</p>
</li>
<li><p>查看<code>FieldError</code>类型</p>
<p>源码上是这样子说的：<code>FieldError</code>包含获取错误信息的所有方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; FieldError contains all functions to get error details</span><br><span class="line">type FieldError interface &#123;</span><br><span class="line"></span><br><span class="line">	Tag() string</span><br><span class="line"></span><br><span class="line">	ActualTag() string</span><br><span class="line"></span><br><span class="line">	Namespace() string</span><br><span class="line"></span><br><span class="line">	StructNamespace() string</span><br><span class="line"></span><br><span class="line">	Field() string</span><br><span class="line"></span><br><span class="line">	StructField() string</span><br><span class="line"></span><br><span class="line">	Value() interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">	Param() string</span><br><span class="line"></span><br><span class="line">	Kind() reflect.Kind</span><br><span class="line"></span><br><span class="line">	Type() reflect.Type</span><br><span class="line"></span><br><span class="line">	Translate(ut ut.Translator) string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>让我打印下<code>FieldError</code>看下吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fmt.Println(field.Tag(), field.ActualTag(), field.Namespace(), field.StructNamespace(), field.Field(), field.StructField(), field.Value(), field.Param(), field.Kind(), field.Type())</span><br></pre></td></tr></table></figure>

<p>得到的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">required required RequestAdminUserLogin.Password RequestAdminUserLogin.Password Password Password &quot;&quot; string string</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="让我们自定义一个友好的错误信息吧"><a href="#让我们自定义一个友好的错误信息吧" class="headerlink" title="让我们自定义一个友好的错误信息吧"></a>让我们自定义一个友好的错误信息吧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个结构体绑定请求数据</span><br><span class="line">type RequestUserLogin struct &#123;</span><br><span class="line">	Username string &#96;form:&quot;username&quot; json:&quot;username&quot; xml:&quot;username&quot; binding:&quot;required&quot;&#96;</span><br><span class="line">	Password string &#96;form:&quot;password&quot; json:&quot;password&quot; xml:&quot;password&quot; binding:&quot;required&quot;&#96;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func getParamError(err validator.ValidationErrors) map[string]string &#123;</span><br><span class="line">	result :&#x3D; make(map[string]string, 0)</span><br><span class="line">	for _, v :&#x3D; range err &#123;</span><br><span class="line">		if field, ok :&#x3D; v.(validator.FieldError); ok &#123;</span><br><span class="line">			result[field.Field()] &#x3D; field.Tag()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data :&#x3D; new(RequestUserLogin)</span><br><span class="line">if err :&#x3D; c.ShouldBind(data); err !&#x3D; nil &#123;</span><br><span class="line">    result :&#x3D; getParamError(err.(validator.ValidationErrors))</span><br><span class="line">	c.JSON(http.StatusForbidden, gin.H&#123;&quot;error&quot;: result&#125;)</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;error&quot;: &#123;</span><br><span class="line">        &quot;Password&quot;: &quot;required&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，你可以通过<code>getParamError</code>自由自在的返回你想要的错误信息了</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang学习</tag>
      </tags>
  </entry>
  <entry>
    <title>sync包基本使用</title>
    <url>/2020/03/31/golang/sync%E5%8C%85%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>sync包提供了基本的同步基元，如互斥锁。除了Once和WaitGroup类型，大部分都是适用于低水平程序线程，高水平的同步使用channel通信更好一些。</p>
<p>本包的类型的值不应被拷贝。</p>
<p>主要类型有：Locker, Cond, Map, Mutex, Once, Pool,RWMutex, WaitGroup</p>
<h2 id="Locker"><a href="#Locker" class="headerlink" title="Locker"></a>Locker</h2><p>Locker接口代表一个可以加锁和解锁的对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; A Locker represents an object that can be locked and unlocked.</span><br><span class="line">type Locker interface &#123;</span><br><span class="line">	Lock()</span><br><span class="line">	Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>Once是只执行一次动作的对象。</p>
<p>Once 是一个可以被多次调用但是只执行一次，若每次调用Do时传入参数f不同，但是只有第一个才会被执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var once sync.Once</span><br><span class="line">onceBody :&#x3D; func() &#123;</span><br><span class="line">    fmt.Println(&quot;Only once&quot;)</span><br><span class="line">&#125;</span><br><span class="line">done :&#x3D; make(chan bool)</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">    go func() &#123;</span><br><span class="line">        once.Do(onceBody)</span><br><span class="line">        done &lt;- true</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line">for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">    &lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果你执行这段代码会发现，虽然调用了10次，但是只执行了1次。</span><br><span class="line">&#x2F;&#x2F; Output:</span><br><span class="line">Only once</span><br></pre></td></tr></table></figure>

<h3 id="Do方法"><a href="#Do方法" class="headerlink" title="Do方法"></a>Do方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (o *Once) Do(f func())</span><br></pre></td></tr></table></figure>

<p>Do方法当且仅当第一次被调用时才执行函数f。换句话说，给定变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var once Once</span><br></pre></td></tr></table></figure>

<p>如果once.Do(f)被多次调用，只有第一次调用会执行f，即使f每次调用Do 提供的f值不同。需要给每个要执行仅一次的函数都建立一个Once类型的实例。</p>
<p>Do用于必须刚好运行一次的初始化。因为f是没有参数的，因此可能需要使用闭包来提供给Do方法调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config.once.Do(func() &#123; config.init(filename) &#125;)</span><br></pre></td></tr></table></figure>

<p>因为只有f返回后Do方法才会返回，f若引起了Do的调用，会导致死锁。</p>
<h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><h3 id="type-Mutex"><a href="#type-Mutex" class="headerlink" title="type Mutex"></a>type Mutex</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Mutex struct &#123;</span><br><span class="line">    &#x2F;&#x2F; 包含隐藏或非导出字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mutex是一个互斥锁，可以创建为其他结构体的字段；零值为解锁状态。Mutex类型的锁和线程无关，可以由不同的线程加锁和解锁。 <strong>第一次使用后不得复制 Mutex</strong> 。</p>
<h4 id="func-Mutex-Lock"><a href="#func-Mutex-Lock" class="headerlink" title="func (*Mutex) Lock"></a>func (*Mutex) Lock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (m *Mutex) Lock()</span><br></pre></td></tr></table></figure>

<p>Lock方法锁住m，如果m已经加锁，则阻塞直到m解锁。</p>
<h4 id="func-Mutex-Unlock"><a href="#func-Mutex-Unlock" class="headerlink" title="func (*Mutex) Unlock"></a>func (*Mutex) Unlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (m *Mutex) Unlock()</span><br></pre></td></tr></table></figure>

<p>Unlock方法解锁m，如果m未加锁会导致运行时错误。锁和线程无关，可以由不同的线程加锁和解锁。</p>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type SafeInt struct &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	Num int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	waitNum :&#x3D; 10 &#x2F;&#x2F; 设置等待的个数（继续往下看）</span><br><span class="line"></span><br><span class="line">	count :&#x3D; SafeInt&#123;&#125;</span><br><span class="line"></span><br><span class="line">	done :&#x3D; make(chan bool)</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; 0; i &lt; waitNum; i++ &#123;</span><br><span class="line">		go func(i int) &#123;</span><br><span class="line">			fmt.Print(i)</span><br><span class="line">			count.Lock() &#x2F;&#x2F; 加锁，防止其它例程修改 count</span><br><span class="line">			count.Num &#x3D; count.Num + i</span><br><span class="line">			fmt.Print(&quot;    &quot;,count.Num, &quot; \n&quot;)</span><br><span class="line">			count.Unlock()</span><br><span class="line"></span><br><span class="line">			done &lt;- true</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i :&#x3D; 0; i &lt; waitNum; i++ &#123;</span><br><span class="line">		&lt;-done</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">9    9 </span><br><span class="line">0    9 </span><br><span class="line">2    11 </span><br><span class="line">7    18 </span><br><span class="line">8    26 </span><br><span class="line">4    30</span><br><span class="line">3    33</span><br><span class="line">6    39</span><br><span class="line">5    44</span><br><span class="line">1    45</span><br><span class="line"></span><br><span class="line">多次输出结果不一致，但和是45</span><br></pre></td></tr></table></figure>



<h2 id="读写互斥锁"><a href="#读写互斥锁" class="headerlink" title="读写互斥锁"></a>读写互斥锁</h2><h3 id="type-RWMutex"><a href="#type-RWMutex" class="headerlink" title="type RWMutex"></a>type RWMutex</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type RWMutex struct &#123;</span><br><span class="line">    &#x2F;&#x2F; 包含隐藏或非导出字段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RWMutex是读写互斥锁。该锁可以被同时多个读取者持有或唯一个写入者持有。RWMutex可以创建为其他结构体的字段；零值为解锁状态。RWMutex类型的锁也和线程无关，可以由不同的线程加读取锁/写入和解读取锁/写入锁。</p>
<h4 id="func-RWMutex-Lock"><a href="#func-RWMutex-Lock" class="headerlink" title="func (*RWMutex) Lock"></a>func (*RWMutex) Lock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (rw *RWMutex) Lock()</span><br></pre></td></tr></table></figure>

<p>Lock方法将rw锁定为写入状态，禁止其他线程读取或者写入。</p>
<h4 id="func-RWMutex-Unlock"><a href="#func-RWMutex-Unlock" class="headerlink" title="func (*RWMutex) Unlock"></a>func (*RWMutex) Unlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (rw *RWMutex) Unlock()</span><br></pre></td></tr></table></figure>

<p>Unlock方法解除rw的写入锁状态，如果m未加写入锁会导致运行时错误。</p>
<h4 id="func-RWMutex-RLock"><a href="#func-RWMutex-RLock" class="headerlink" title="func (*RWMutex) RLock"></a>func (*RWMutex) RLock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (rw *RWMutex) RLock()</span><br></pre></td></tr></table></figure>

<p>RLock方法将rw锁定为读取状态，禁止其他线程写入，但不禁止读取。</p>
<h4 id="func-RWMutex-RUnlock"><a href="#func-RWMutex-RUnlock" class="headerlink" title="func (*RWMutex) RUnlock"></a>func (*RWMutex) RUnlock</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (rw *RWMutex) RUnlock()</span><br></pre></td></tr></table></figure>

<p>Runlock方法解除rw的读取锁状态，如果m未加读取锁会导致运行时错误。</p>
<h4 id="func-RWMutex-RLocker"><a href="#func-RWMutex-RLocker" class="headerlink" title="func (*RWMutex) RLocker"></a>func (*RWMutex) RLocker</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (rw *RWMutex) RLocker() Locker</span><br></pre></td></tr></table></figure>

<p>Rlocker方法返回一个互斥锁，通过调用rw.Rlock和rw.Runlock实现了Locker接口。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var m *sync.RWMutex</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	m &#x3D; new(sync.RWMutex)</span><br><span class="line">	wg.Add(2)</span><br><span class="line">	go write(1)</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	go read(2)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">func write(i int) &#123;</span><br><span class="line">	fmt.Println(i, &quot;写开始.&quot;)</span><br><span class="line">	m.Lock()</span><br><span class="line">	fmt.Println(i, &quot;正在写入中......&quot;)</span><br><span class="line">	time.Sleep(3 * time.Second)</span><br><span class="line">	m.Unlock()</span><br><span class="line">	fmt.Println(i, &quot;写入结束.&quot;)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line">func read(i int) &#123;</span><br><span class="line">	fmt.Println(i, &quot;读开始.&quot;)</span><br><span class="line">	m.RLock()</span><br><span class="line">	fmt.Println(i, &quot;正在读取中......&quot;)</span><br><span class="line">	time.Sleep(1 * time.Second)</span><br><span class="line">	m.RUnlock()</span><br><span class="line">	fmt.Println(i, &quot;读取结束.&quot;)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="并发等待"><a href="#并发等待" class="headerlink" title="并发等待"></a>并发等待</h2><h3 id="type-WaitGroup"><a href="#type-WaitGroup" class="headerlink" title="type WaitGroup"></a>type WaitGroup</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type WaitGroup struct &#123;</span><br><span class="line">    &#x2F;&#x2F; 包含隐藏或非导出字段</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计数器增加 delta，delta 可以是负数。</span><br><span class="line">func (wg *WaitGroup) Add(delta int)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 计数器减少 1</span><br><span class="line">func (wg *WaitGroup) Done()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待直到计数器归零。如果计数器小于 0，则该操作会引发 panic。</span><br><span class="line">func (wg *WaitGroup) Wait()</span><br></pre></td></tr></table></figure>

<p>WaitGroup用于等待一组线程的结束。父线程调用Add方法来设定应等待的线程的数量。每个被等待的线程在结束时应调用Done方法。同时，主线程里可以调用Wait方法阻塞至所有线程结束。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var wg sync.WaitGroup</span><br><span class="line">var urls &#x3D; []string&#123;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.golang.org&#x2F;&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.google.com&#x2F;&quot;,</span><br><span class="line">    &quot;http:&#x2F;&#x2F;www.somestupidname.com&#x2F;&quot;,</span><br><span class="line">&#125;</span><br><span class="line">for _, url :&#x3D; range urls &#123;</span><br><span class="line">    &#x2F;&#x2F; Increment the WaitGroup counter.</span><br><span class="line">    wg.Add(1)</span><br><span class="line">    &#x2F;&#x2F; Launch a goroutine to fetch the URL.</span><br><span class="line">    go func(url string) &#123;</span><br><span class="line">        &#x2F;&#x2F; Decrement the counter when the goroutine completes.</span><br><span class="line">        defer wg.Done()</span><br><span class="line">        &#x2F;&#x2F; Fetch the URL.</span><br><span class="line">        http.Get(url)</span><br><span class="line">    &#125;(url)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Wait for all HTTP fetches to complete.</span><br><span class="line">wg.Wait()</span><br></pre></td></tr></table></figure>

<h4 id="func-WaitGroup-Add"><a href="#func-WaitGroup-Add" class="headerlink" title="func (*WaitGroup) Add"></a>func (*WaitGroup) Add</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (wg *WaitGroup) Add(delta int)</span><br></pre></td></tr></table></figure>

<p>Add方法向内部计数加上delta，delta可以是负数；如果内部计数器变为0，Wait方法阻塞等待的所有线程都会释放，如果计数器小于0，方法panic。注意Add加上正数的调用应在Wait之前，否则Wait可能只会等待很少的线程。一般来说本方法应在创建新的线程或者其他应等待的事件之前调用。</p>
<h4 id="func-WaitGroup-Done"><a href="#func-WaitGroup-Done" class="headerlink" title="func (*WaitGroup) Done"></a>func (*WaitGroup) Done</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (wg *WaitGroup) Done()</span><br></pre></td></tr></table></figure>

<p>Done方法减少WaitGroup计数器的值，应在线程的最后执行。</p>
<h4 id="func-WaitGroup-Wait"><a href="#func-WaitGroup-Wait" class="headerlink" title="func (*WaitGroup) Wait"></a>func (*WaitGroup) Wait</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (wg *WaitGroup) Wait()</span><br></pre></td></tr></table></figure>

<p>Wait方法阻塞直到WaitGroup计数器减为0。</p>
<h2 id="Cond"><a href="#Cond" class="headerlink" title="Cond"></a>Cond</h2><p>sync.Cond用于goroutine之间的协作，用于协程的挂起和唤醒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Cond struct &#123;</span><br><span class="line">	noCopy noCopy  &#x2F;&#x2F; noCopy可以嵌入到结构中，在第一次使用后不可复制,使用go vet作为检测使用</span><br><span class="line"> </span><br><span class="line">	L Locker &#x2F;&#x2F; 根据需求初始化不同的锁，如*Mutex 和 *RWMutex</span><br><span class="line"> </span><br><span class="line">	notify  notifyList  &#x2F;&#x2F; 通知列表,调用Wait()方法的goroutine会被放入list中,每次唤醒,从这里取出</span><br><span class="line">	checker copyChecker &#x2F;&#x2F; 复制检查,检查cond实例是否被复制</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="func-NewCond"><a href="#func-NewCond" class="headerlink" title="func NewCond"></a>func NewCond</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func NewCond(l Locker) *Cond</span><br></pre></td></tr></table></figure>

<p>使用锁l创建一个*Cond。</p>
<h4 id="func-Cond-Broadcast"><a href="#func-Cond-Broadcast" class="headerlink" title="func (*Cond) Broadcast"></a>func (*Cond) Broadcast</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (c *Cond) Broadcast() &#123;</span><br><span class="line">    &#x2F;&#x2F; 检查c是否是被复制的，如果是就panic</span><br><span class="line">	c.checker.check()</span><br><span class="line">	&#x2F;&#x2F; 唤醒等待队列中所有的goroutine</span><br><span class="line">	runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Broadcast唤醒所有等待c的线程。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。</p>
<p>功能：唤醒等待队列中的所有goroutine</p>
<h4 id="func-Cond-Signal"><a href="#func-Cond-Signal" class="headerlink" title="func (*Cond) Signal"></a>func (*Cond) Signal</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (c *Cond) Signal() &#123;</span><br><span class="line">       &#x2F;&#x2F; 检查c是否是被复制的，如果是就panic</span><br><span class="line">	c.checker.check()</span><br><span class="line">	&#x2F;&#x2F; 通知等待列表中的一个 </span><br><span class="line">	runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Signal唤醒等待c的一个线程（如果存在）。调用者在调用本方法时，建议（但并非必须）保持c.L的锁定。</p>
<p>功能：唤醒等待队列中的一个goroutine，一般都是任意唤醒队列中的一个goroutine</p>
<h4 id="func-Cond-Wait"><a href="#func-Cond-Wait" class="headerlink" title="func (*Cond) Wait"></a>func (*Cond) Wait</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (c *Cond) Wait() &#123;</span><br><span class="line">        &#x2F;&#x2F; 检查c是否是被复制的，如果是就panic</span><br><span class="line">	c.checker.check()</span><br><span class="line">	&#x2F;&#x2F; 将当前goroutine加入等待队列</span><br><span class="line">	t :&#x3D; runtime_notifyListAdd(&amp;c.notify)</span><br><span class="line">	&#x2F;&#x2F; 解锁</span><br><span class="line">	c.L.Unlock()</span><br><span class="line">	&#x2F;&#x2F; 等待队列中的所有的goroutine执行等待唤醒操作</span><br><span class="line">	runtime_notifyListWait(&amp;c.notify, t)</span><br><span class="line">	c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Wait自行解锁c.L并阻塞当前线程，在之后线程恢复执行时，Wait方法会在返回前锁定c.L。和其他系统不同，Wait除非被Broadcast或者Signal唤醒，不会主动返回。</p>
<p>因为线程中Wait方法是第一个恢复执行的，而此时c.L未加锁。调用者不应假设Wait恢复时条件已满足，相反，调用者应在循环中等待：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c.L.Lock()</span><br><span class="line">for !condition() &#123;</span><br><span class="line">    c.Wait()</span><br><span class="line">&#125;</span><br><span class="line">... make use of condition ...</span><br><span class="line">c.L.Unlock()</span><br></pre></td></tr></table></figure>

<p>功能： 必须获取该锁之后才能调用Wait()方法，Wait方法在调用时会释放底层锁Locker，并且将当前goroutine挂起，直到另一个goroutine执行Signal或者Broadcase，该goroutine才有机会重新唤醒，并尝试获取Locker，完成后续逻辑。</p>
<p>也就是在等待被唤醒的过程中是不占用锁Locker的，这样就可以有多个goroutine可以同时处于Wait(等待被唤醒的状态)</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">	locker :&#x3D; new(sync.Mutex)</span><br><span class="line">	cond :&#x3D; sync.NewCond(locker)</span><br><span class="line"> </span><br><span class="line">	for i :&#x3D; 0 ; i &lt; 30 ; i++ &#123;</span><br><span class="line">		go func(x int) &#123;</span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			fmt.Println(x,&quot; 获取锁&quot;)</span><br><span class="line">			defer cond.L.Unlock()</span><br><span class="line">			cond.Wait()</span><br><span class="line">			fmt.Println(x,&quot; 被唤醒&quot;)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(&quot;Signal...&quot;)</span><br><span class="line">	cond.Signal()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	cond.Signal()</span><br><span class="line">	time.Sleep(time.Second*3)</span><br><span class="line">	cond.Broadcast()</span><br><span class="line"> </span><br><span class="line">	fmt.Println(&quot;Broadcast...&quot;)</span><br><span class="line">	time.Sleep(time.Minute)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>Golang中sync.Pool用来提高对象复用几率，减少gc的压力，减少内存分配，它是线程安全的，常用来存储并复用临时对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Pool struct &#123;</span><br><span class="line">	noCopy noCopy   &#x2F;&#x2F;该对象不能被copy使用</span><br><span class="line"> </span><br><span class="line">	local     unsafe.Pointer &#x2F;&#x2F; [p]poolLocal,固定长度</span><br><span class="line">	localSize uintptr        &#x2F;&#x2F;本地缓冲池poolLocal的数量</span><br><span class="line"> </span><br><span class="line">	New func() interface&#123;&#125;  &#x2F;&#x2F;用户自定义的用于生成对象的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Pool是一个可以分别存取的临时对象的集合。</p>
<p>Pool中保存的任何item都可能随时不做通告的释放掉。如果Pool持有该对象的唯一引用，这个item就可能被回收。</p>
<p>Pool可以安全的被多个线程同时使用。</p>
<p>Pool的目的是缓存申请但未使用的item用于之后的重用，以减轻GC的压力。也就是说，让创建高效而线程安全的空闲列表更容易。但Pool并不适用于所有空闲列表。</p>
<p>Pool的合理用法是用于管理一组静静的被多个独立并发线程共享并可能重用的临时item。Pool提供了让多个线程分摊内存申请消耗的方法。</p>
<p>Pool的一个好例子在fmt包里。该Pool维护一个动态大小的临时输出缓存仓库。该仓库会在过载（许多线程活跃的打印时）增大，在沉寂时缩小。</p>
<p>另一方面，管理着短寿命对象的空闲列表不适合使用Pool，因为这种情况下内存申请消耗不能很好的分配。这时应该由这些对象自己实现空闲列表。</p>
<h4 id="func-Pool-Get"><a href="#func-Pool-Get" class="headerlink" title="func (*Pool) Get"></a>func (*Pool) Get</h4><p>作用：从Pool中获取一个对象，如果获取不到并且New函数不为空，则通过New创建一个对象并返回。否则返回nil</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (p *Pool) Get() interface&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Get方法从池中选择任意一个item，删除其在池中的引用计数，并提供给调用者。Get方法也可能选择无视内存池，将其当作空的。调用者不应认为Get的返回这和传递给Put的值之间有任何关系。</p>
<p>假使Get方法没有取得item：如p.New非nil，Get返回调用p.New的结果；否则返回nil。</p>
<h4 id="func-Pool-Put"><a href="#func-Pool-Put" class="headerlink" title="func (*Pool) Put"></a>func (*Pool) Put</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (p *Pool) Put(x interface&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>Put方法将x放入池中。</p>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang学习</tag>
      </tags>
  </entry>
  <entry>
    <title>GRPC安装及简单使用</title>
    <url>/2021/09/06/golang/grpc/</url>
    <content><![CDATA[<h3 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装<code>protoc</code></h3><p>地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a></p>
<h3 id="安装protoc-gen-go"><a href="#安装protoc-gen-go" class="headerlink" title="安装protoc-gen-go"></a>安装<code>protoc-gen-go</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure>

<h3 id="安装grpc包"><a href="#安装grpc包" class="headerlink" title="安装grpc包"></a>安装<code>grpc</code>包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;grpc&#x2F;grpc-go.git $GOPATH&#x2F;src&#x2F;google.golang.org&#x2F;grpc</span><br><span class="line"></span><br><span class="line">cd $GOPATH&#x2F;src&#x2F;grpc&#x2F;cmd&#x2F;protoc-gen-go-grpc</span><br><span class="line">go install</span><br></pre></td></tr></table></figure>

<h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><ul>
<li>创建项目目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir hello-world</span><br><span class="line">mkdir -p hello-world&#x2F;cmd</span><br><span class="line">mkdir -p hello-world&#x2F;protos</span><br><span class="line">mkdir -p hello-world&#x2F;sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">目录结构</span><br><span class="line">└─hello-world</span><br><span class="line">    ├─cmd</span><br><span class="line">    ├─protos</span><br><span class="line">    └─sh</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑<code>proto</code>文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; vim hello-world&#x2F;cmd&#x2F;hello-world.proto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">syntax&#x3D;&quot;proto3&quot;;</span><br><span class="line">package protos;</span><br><span class="line"></span><br><span class="line">option go_package&#x3D;&quot;.&#x2F;protos&quot;;</span><br><span class="line"></span><br><span class="line">service HelloWorld&#123;</span><br><span class="line">	rpc Send(SendRequest) returns(SendResponse)&#123;&#125;</span><br><span class="line">	rpc Count(CountRequest) returns (CountResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SendRequest&#123;</span><br><span class="line">	string msg &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SendResponse&#123;</span><br><span class="line">	int32 code &#x3D; 1;</span><br><span class="line">	string msg &#x3D; 2;</span><br><span class="line">	repeated SendRequest data &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CountRequest&#123;</span><br><span class="line">	int32 a &#x3D; 1;</span><br><span class="line">	int32 b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message CountResponse&#123;</span><br><span class="line">	int32 code &#x3D; 1;</span><br><span class="line">	string msg &#x3D; 2;</span><br><span class="line">	int32 sum &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑代码生成脚本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; vim hello-world&#x2F;sh&#x2F;gen.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line"></span><br><span class="line">protoDir&#x3D;&quot;..&#x2F;protos&quot;</span><br><span class="line">outDir&#x3D;&quot;..&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">protoc -I $&#123;protoDir&#125;&#x2F; $&#123;protoDir&#125;&#x2F;*proto --go_out&#x3D;$&#123;outDir&#125;</span><br><span class="line">protoc -I $&#123;protoDir&#125;&#x2F; $&#123;protoDir&#125;&#x2F;*proto --go-grpc_out&#x3D;$&#123;outDir&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>生成服务端和客户端代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hello-world&#x2F;sh</span><br><span class="line">.&#x2F;gen.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑服务端代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; vim hello-world&#x2F;cmd&#x2F;server.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	pb &quot;app&#x2F;protos&quot;</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line"></span><br><span class="line">	&quot;google.golang.org&#x2F;grpc&quot;</span><br><span class="line">	&quot;google.golang.org&#x2F;grpc&#x2F;reflection&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	port &#x3D; &quot;:50051&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type server struct &#123;</span><br><span class="line">	pb.UnimplementedHelloWorldServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *server) Send(ctx context.Context, request *pb.SendRequest) (*pb.SendResponse, error) &#123;</span><br><span class="line">	fmt.Println(&quot;client send msg: &quot;, request.Msg)</span><br><span class="line">	return &amp;pb.SendResponse&#123;</span><br><span class="line">		Code: 0,</span><br><span class="line">		Msg:  &quot;success&quot;,</span><br><span class="line">		Data: []*pb.SendRequest&#123;</span><br><span class="line">			&amp;pb.SendRequest&#123;</span><br><span class="line">				Msg: request.Msg + &quot; response&quot;,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *server) Count(ctx context.Context, request *pb.CountRequest) (*pb.CountResponse, error) &#123;</span><br><span class="line">	fmt.Println(&quot;client count A:&quot;, request.A, &quot; client count B: &quot;, request.B)</span><br><span class="line">	return &amp;pb.CountResponse&#123;</span><br><span class="line">		Code: 0,</span><br><span class="line">		Msg:  &quot;success&quot;,</span><br><span class="line">		Sum: request.A + request.B,</span><br><span class="line">	&#125;,nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	listen, err :&#x3D; net.Listen(&quot;tcp&quot;, port)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		log.Fatalf(&quot;listener error: $v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s :&#x3D; grpc.NewServer()</span><br><span class="line">	pb.RegisterHelloWorldServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	reflection.Register(s)</span><br><span class="line"></span><br><span class="line">	if err :&#x3D; s.Serve(listen); err !&#x3D; nil &#123;</span><br><span class="line">		log.Fatalf(&quot;failed to serve: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑客户端代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	pb &quot;app&#x2F;protos&quot;</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;google.golang.org&#x2F;grpc&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">	address &#x3D; &quot;localhost:50051&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	conn, err :&#x3D; grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		log.Fatalf(&quot;did not connect: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer conn.Close()</span><br><span class="line"></span><br><span class="line">	c :&#x3D; pb.NewHelloWorldClient(conn)</span><br><span class="line"></span><br><span class="line">	ctx, cancel :&#x3D; context.WithTimeout(context.Background(), time.Second)</span><br><span class="line">	defer cancel()</span><br><span class="line"></span><br><span class="line">	r, err :&#x3D; c.Send(ctx, &amp;pb.SendRequest&#123;</span><br><span class="line">		Msg: &quot;Hello World&quot;,</span><br><span class="line">	&#125;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		log.Fatalf(&quot;send error: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;send response&quot;, r)</span><br><span class="line"></span><br><span class="line">	countResponse,err :&#x3D; c.Count(ctx, &amp;pb.CountRequest&#123;</span><br><span class="line">		A:5,</span><br><span class="line">		B:10,</span><br><span class="line">	&#125;)</span><br><span class="line">	if err !&#x3D; nil &#123;</span><br><span class="line">		log.Fatalf(&quot;count error: %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;count response&quot;, countResponse)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>运行服务端和客户端</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hello-world</span><br><span class="line"></span><br><span class="line">go mod init</span><br><span class="line"></span><br><span class="line">go mod tidy</span><br><span class="line"></span><br><span class="line">go run cmd&#x2F;server.go</span><br><span class="line"></span><br><span class="line">go run cmd&#x2F;client.go</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>grpcui</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装</span><br><span class="line">go get github.com&#x2F;fullstorydev&#x2F;grpcui</span><br><span class="line">go install github.com&#x2F;fullstorydev&#x2F;grpcui&#x2F;cmd&#x2F;grpcui</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line">grpcui -plaintext localhost:12345</span><br><span class="line"></span><br><span class="line">## localhost:12345 为 grpc 服务端监听地址</span><br></pre></td></tr></table></figure>



<h4 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h4><ul>
<li><a href="https://github.com/fullstorydev/grpcui" target="_blank" rel="noopener">https://github.com/fullstorydev/grpcui</a></li>
<li><a href="https://github.com/grpc/grpc-go" target="_blank" rel="noopener">https://github.com/grpc/grpc-go</a></li>
</ul>
]]></content>
      <categories>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang学习</tag>
      </tags>
  </entry>
  <entry>
    <title>4.配置免密登陆</title>
    <url>/2021/12/30/k8s/4.%E9%85%8D%E7%BD%AE%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</url>
    <content><![CDATA[<h4 id="1-生成密钥"><a href="#1-生成密钥" class="headerlink" title="1.生成密钥"></a>1.生成密钥</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<h4 id="2-将密钥部署到目标机器"><a href="#2-将密钥部署到目标机器" class="headerlink" title="2.将密钥部署到目标机器"></a>2.将密钥部署到目标机器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id -i root@192.168.0.1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>1.安装centos国内源</title>
    <url>/2021/12/30/k8s/1.%E5%AE%89%E8%A3%85centos%E5%9B%BD%E5%86%85%E6%BA%90/</url>
    <content><![CDATA[<h3 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>

<h3 id="2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d"><a href="#2-下载新的-CentOS-Base-repo-到-etc-yum-repos-d" class="headerlink" title="2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/"></a>2.下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo</span><br></pre></td></tr></table></figure>

<h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3.配置"></a>3.配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i -e &#39;&#x2F;mirrors.cloud.aliyuncs.com&#x2F;d&#39; -e &#39;&#x2F;mirrors.aliyuncs.com&#x2F;d&#39; &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</span><br></pre></td></tr></table></figure>

<h3 id="4-运行yum-makecache生成缓存"><a href="#4-运行yum-makecache生成缓存" class="headerlink" title="4.运行yum makecache生成缓存"></a>4.运行<code>yum makecache</code>生成缓存</h3><h4 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h4><ul>
<li><a href="https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11DQ8eBO" target="_blank" rel="noopener">https://developer.aliyun.com/mirror/centos?spm=a2c6h.13651102.0.0.3e221b11DQ8eBO</a></li>
</ul>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>centos新建用户并授权</title>
    <url>/2021/12/30/k8s/2.centos%E6%96%B0%E5%BB%BA%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1.新建用户"></a>1.新建用户</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd dev_user</span><br></pre></td></tr></table></figure>

<h4 id="2-设置新用户密码"><a href="#2-设置新用户密码" class="headerlink" title="2.设置新用户密码"></a>2.设置新用户密码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd dev_user</span><br></pre></td></tr></table></figure>


<h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><h4 id="1-查找sudoers文件路径并赋予权限"><a href="#1-查找sudoers文件路径并赋予权限" class="headerlink" title="1.查找sudoers文件路径并赋予权限"></a>1.查找sudoers文件路径并赋予权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@work ~]# whereis sudoers                  # 查找sudoers文件路径</span><br><span class="line">sudoers: &#x2F;etc&#x2F;sudoers &#x2F;etc&#x2F;sudoers.d &#x2F;usr&#x2F;share&#x2F;man&#x2F;man5&#x2F;sudoers.5.gz</span><br><span class="line">[root@work ~]# ls -l &#x2F;etc&#x2F;sudoers               # 查看权限</span><br><span class="line">-r--r-----. 1 root root 4328 10月 30 2018 &#x2F;etc&#x2F;sudoers</span><br><span class="line">[root@work ~]# chmod -v u+w &#x2F;etc&#x2F;sudoers        # 赋予读写权限</span><br><span class="line">mode of &quot;&#x2F;etc&#x2F;sudoers&quot; changed from 0440 (r--r-----) to 0640 (rw-r-----)</span><br></pre></td></tr></table></figure>

<h4 id="2-修改文件"><a href="#2-修改文件" class="headerlink" title="2.修改文件"></a>2.修改文件</h4><p>输入命令<code>vim /etc/sudoers</code>修改sudoers文件，添加新用户信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Allow root to run any commands anywhere</span><br><span class="line">root ALL&#x3D;(ALL) ALL</span><br><span class="line">dev_user ALL&#x3D;(ALL) ALL #这个是新用户</span><br></pre></td></tr></table></figure>

<h4 id="3-收回权限"><a href="#3-收回权限" class="headerlink" title="3.收回权限"></a>3.收回权限</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@work ~]# chmod -v u-w &#x2F;etc&#x2F;sudoers</span><br><span class="line">mode of &quot;&#x2F;etc&#x2F;sudoers&quot; changed from 0640 (rw-r-----) to 0440 (r--r-----)</span><br><span class="line">[root@work ~]# ls -l &#x2F;etc&#x2F;sudoers</span><br><span class="line">-r--r-----. 1 root root 4354 12月 30 01:18 &#x2F;etc&#x2F;sudoers</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>10.k8s安装nginx-ingress</title>
    <url>/2022/02/08/k8s/10.k8s%E5%AE%89%E8%A3%85nginx-ingress/</url>
    <content><![CDATA[<p>参考文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;blob&#x2F;main&#x2F;docs&#x2F;deploy&#x2F;index.md</span><br></pre></td></tr></table></figure>
<p>因为官方提供的yaml文件中有部分内容国内访问不到，需要使用国内镜像，先将yaml文件下载至本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 官方命令</span><br><span class="line">kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;controller-v1.1.1&#x2F;deploy&#x2F;static&#x2F;provider&#x2F;baremetal&#x2F;deploy.yaml</span><br><span class="line"></span><br><span class="line"># 下载至本地</span><br><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;kubernetes&#x2F;ingress-nginx&#x2F;controller-v1.1.1&#x2F;deploy&#x2F;static&#x2F;provider&#x2F;baremetal&#x2F;deploy.yaml</span><br></pre></td></tr></table></figure>
<p>在国外服务器上<code>pull</code>对应的镜像并将其<code>push</code>到<code>hub.docker.com</code>中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询deploy.yaml中使用到的镜像</span><br><span class="line">[dev_user@master ~]$ grep image deploy.yaml</span><br><span class="line">          image: k8s.gcr.io&#x2F;ingress-nginx&#x2F;controller:v1.1.1@sha256:0bc88eb15f9e7f84e8e56c14fa5735aaa488b840983f87bd79b1054190e660de</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          image: k8s.gcr.io&#x2F;ingress-nginx&#x2F;kube-webhook-certgen:v1.1.1@sha256:64d8c73dca984af206adf9d6d7e46aa550362b1d7a01f3a0a91b20cc67868660</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          image: k8s.gcr.io&#x2F;ingress-nginx&#x2F;kube-webhook-certgen:v1.1.1@sha256:64d8c73dca984af206adf9d6d7e46aa550362b1d7a01f3a0a91b20cc67868660</span><br><span class="line">          imagePullPolicy: IfNotPresent</span><br><span class="line">          </span><br><span class="line"># 在国外服务器上pull</span><br><span class="line">[root@host1 ~]# docker pull k8s.gcr.io&#x2F;ingress-nginx&#x2F;controller:v1.1.1</span><br><span class="line">[root@host1 ~]# docker pull k8s.gcr.io&#x2F;ingress-nginx&#x2F;kube-webhook-certgen:v1.1.1</span><br><span class="line"># 给镜像打标签</span><br><span class="line">[root@host1 ~]# docker tag k8s.gcr.io&#x2F;ingress-nginx&#x2F;controller:v1.1.1 nasus&#x2F;ingress-nginx-controller:v1.1.1</span><br><span class="line">[root@host1 ~]# docker tag k8s.gcr.io&#x2F;ingress-nginx&#x2F;kube-webhook-certgen:v1.1.1 nasus&#x2F;ingress-nginx-kube-webhook-certgen:v1.1.1</span><br><span class="line">[root@host1 ~]# docker push nasus&#x2F;ingress-nginx-controller:v1.1.1</span><br><span class="line">[root@host1 ~]# docker push nasus&#x2F;ingress-nginx-kube-webhook-certgen:v1.1.1</span><br></pre></td></tr></table></figure>

<p>修改deploy.yml中对应的镜像并在<code>Deployment</code>中添加<code>hostNetwork</code>,增加<code>nodeSelector</code>的标签<code>kubernetes.io/hostname: master</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spec:</span><br><span class="line">    hostNetwork: true</span><br><span class="line">    </span><br><span class="line">nodeSelector:</span><br><span class="line">        kubernetes.io&#x2F;os: linux</span><br><span class="line">        kubernetes.io&#x2F;hostname: master</span><br></pre></td></tr></table></figure>

<p><img src="/2022/02/08/k8s/10.k8s%E5%AE%89%E8%A3%85nginx-ingress/20220211-1451.png" alt></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>3.centos设置静态IP</title>
    <url>/2021/12/30/k8s/3.centos%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/</url>
    <content><![CDATA[<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</span><br></pre></td></tr></table></figure>
<ul>
<li>将“BOOTPROTO=dhcp”改为“BOOTPROTO=static”</li>
<li>将“ONBOOT=no”改为“ONBOOT=yes”</li>
</ul>
<h4 id="未修改前"><a href="#未修改前" class="headerlink" title="未修改前"></a>未修改前</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD&#x3D;&quot;none&quot;</span><br><span class="line">BROWSER_ONLY&#x3D;&quot;no&quot;</span><br><span class="line">BOOTPROTO&#x3D;&quot;dhcp&quot;</span><br><span class="line">DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPV6INIT&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;&quot;stable-privacy&quot;</span><br><span class="line">NAME&#x3D;&quot;eth0&quot;</span><br><span class="line">UUID&#x3D;&quot;a4c4162e-15d9-4231-87d4-3ae1c9e53570&quot;</span><br><span class="line">DEVICE&#x3D;&quot;eth0&quot;</span><br><span class="line">ONBOOT&#x3D;&quot;yes&quot;</span><br></pre></td></tr></table></figure>


<h4 id="修改后"><a href="#修改后" class="headerlink" title="修改后"></a>修改后</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TYPE&#x3D;&quot;Ethernet&quot;</span><br><span class="line">PROXY_METHOD&#x3D;&quot;none&quot;</span><br><span class="line">BROWSER_ONLY&#x3D;&quot;no&quot;</span><br><span class="line">BOOTPROTO&#x3D;&quot;static&quot;</span><br><span class="line">DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV4_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPV6INIT&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_AUTOCONF&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_DEFROUTE&#x3D;&quot;yes&quot;</span><br><span class="line">IPV6_FAILURE_FATAL&#x3D;&quot;no&quot;</span><br><span class="line">IPV6_ADDR_GEN_MODE&#x3D;&quot;stable-privacy&quot;</span><br><span class="line">NAME&#x3D;&quot;eth0&quot;</span><br><span class="line">UUID&#x3D;&quot;422dce01-9b25-4f06-8f0d-a8d2a6d07a89&quot;</span><br><span class="line">DEVICE&#x3D;&quot;eth0&quot;</span><br><span class="line">ONBOOT&#x3D;&quot;yes&quot;</span><br><span class="line">IPADDR&#x3D;&quot;192.168.0.11&quot;</span><br><span class="line">GATEWAY&#x3D;&quot;192.168.0.1&quot;</span><br><span class="line">NETMASK&#x3D;&quot;255.255.255.0&quot;</span><br><span class="line">DNS1&#x3D;&quot;218.2.2.2&quot;</span><br><span class="line">DNS2&#x3D;&quot;218.4.4.4&quot;</span><br></pre></td></tr></table></figure>

<h2 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;network restart</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>7.centos挂载smb</title>
    <url>/2022/01/24/k8s/7.centos%E6%8C%82%E8%BD%BDsmb/</url>
    <content><![CDATA[<h2 id="手动挂载smb"><a href="#手动挂载smb" class="headerlink" title="手动挂载smb"></a>手动挂载smb</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y cifs-utils</span><br><span class="line"></span><br><span class="line">sudo mount -t cifs &#x2F;&#x2F;192.168.0.10&#x2F;nfs_mount &#x2F;home&#x2F;dev_user&#x2F;mount -o username&#x3D;guest,password&#x3D;guest,vers&#x3D;3.0,gid&#x3D;1000,uid&#x3D;1000,file_mode&#x3D;0777,dir_mode&#x3D;0777</span><br></pre></td></tr></table></figure>

<h2 id="自动挂载"><a href="#自动挂载" class="headerlink" title="自动挂载"></a>自动挂载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;fstab</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;192.168.0.10&#x2F;nfs_mount &#x2F;home&#x2F;dev_user&#x2F;mount cifs username&#x3D;guest,password&#x3D;guest,vers&#x3D;3.0,gid&#x3D;1000,uid&#x3D;1000,file_mode&#x3D;0777,dir_mode&#x3D;0777 0 0</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>5.部署k8s</title>
    <url>/2021/12/30/k8s/5.%E9%83%A8%E7%BD%B2k8s/</url>
    <content><![CDATA[<h3 id="1-服务器配置"><a href="#1-服务器配置" class="headerlink" title="1.服务器配置"></a>1.服务器配置</h3><p>共使用3台服务器，依次配置<code>hostname</code>、<code>固定IP</code>、<code>hosts</code>、<code>防火墙</code>、<code>selinux</code>和<code>Swap</code></p>
<h4 id="1-1-配置HOSTNAME"><a href="#1-1-配置HOSTNAME" class="headerlink" title="1.1 配置HOSTNAME"></a>1.1 配置HOSTNAME</h4><ul>
<li>master服务器：<code>hostnamectl --static set-hostname k8s-master</code></li>
<li>node-1服务器：<code>hostnamectl --static set-hostname k8s-node1</code></li>
<li>node-2服务器：<code>hostnamectl --static set-hostname k8s-node2</code></li>
</ul>
<h4 id="1-2-配置固定IP"><a href="#1-2-配置固定IP" class="headerlink" title="1.2 配置固定IP"></a>1.2 配置固定IP</h4><p>编辑文件<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>，修改<code>BOOTPROTO</code>的值为<code>static</code>，并在文件追加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPADDR&#x3D;&quot;192.168.0.11&quot;</span><br><span class="line">GATEWAY&#x3D;&quot;192.168.0.1&quot;</span><br><span class="line">NETMASK&#x3D;&quot;255.255.255.0&quot;</span><br><span class="line">DNS1&#x3D;&quot;218.2.2.2&quot;</span><br><span class="line">DNS2&#x3D;&quot;218.4.4.4&quot;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-配置HOSTS"><a href="#1-3-配置HOSTS" class="headerlink" title="1.3 配置HOSTS"></a>1.3 配置HOSTS</h4><p>配置每台服务器的host，让每台服务器可以使用域名互相访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt;&gt; &#x2F;etc&#x2F;hosts</span><br><span class="line">192.168.0.11 work</span><br><span class="line">192.168.0.12 k8s-node1</span><br><span class="line">192.168.0.13 k8s-node2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后一行回车之后，<code>ctrl+c</code>或者<code>ctrl+d</code>结束输入</p>
</blockquote>
<h4 id="1-4-配置防火墙"><a href="#1-4-配置防火墙" class="headerlink" title="1.4 配置防火墙"></a>1.4 配置防火墙</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop firewalld</span><br><span class="line">sudo systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h4 id="1-5-配置SELinux"><a href="#1-5-配置SELinux" class="headerlink" title="1.5 配置SELinux"></a>1.5 配置SELinux</h4><p><code>SELinux</code>，安全增强型<code>Linux</code>，是一种采用安全架构的<code>Linux</code>系统。因为我们不是专业的<code>Linux</code>运维工程师，并且防止在后续部署过程中遇到因为<code>SELinux</code>产生的问题，这里直接关闭<code>SELinux</code>。</p>
<ul>
<li>查看<code>SELinux</code>是否开启：执行命令<code>/usr/sbin/sestatus -v</code>，查看<code>SELinux status</code>的状态是否为<code>enabled</code></li>
<li>关闭<code>SELinux</code>：编辑文件<code>vi /etc/selinux/config</code>，设置<code>SELINUX</code>为<code>disabled</code></li>
</ul>
<h4 id="1-6-配置SWAP"><a href="#1-6-配置SWAP" class="headerlink" title="1.6 配置SWAP"></a>1.6 配置<code>SWAP</code></h4><p><code>k8s</code>想法是将实例紧密包装到尽可能接近<code>100%</code>，所有的部署都应该与<code>CPU</code>、内存限制固定在一起。所以，如果调度程序发送一个<code>Pod</code>到一台机器，它不应该使用交换。同时，<code>k8s</code>的设计者考虑到性能的原因，关闭<code>swap</code>。如果在运行容器数量较多时，考虑节省资源的资源，可以添加<code>kubelet</code>参数<code>--fail-swap-on=false</code>来解决这个问题。</p>
<p>关闭<code>Swap</code>的步骤：</p>
<ul>
<li><code>swapoff -a</code></li>
<li>编辑<code>/etc/fstab</code>，注释<code>swap</code>所在的行</li>
<li><code>free</code> # 可以通过这个命令查看swap是否关闭了</li>
</ul>
<h3 id="2-部署容器"><a href="#2-部署容器" class="headerlink" title="2. 部署容器"></a>2. 部署容器</h3><p>这里的容器运行时指的是：负责容器运行的软件，可选的有：<code>containerd</code>、<code>docker</code>和<code>CRI-O</code>，我们选择<code>docker</code>作为容器运行时。</p>
<p>配置<code>k8s</code>集群，需要为每个节点安装一个容器运行时，用来为<code>Pod</code>提供运行环境</p>
<h4 id="2-1-为容器进行时配置Cgroups"><a href="#2-1-为容器进行时配置Cgroups" class="headerlink" title="2.1 为容器进行时配置Cgroups"></a>2.1 为容器进行时配置Cgroups</h4><p><code>Cgroups</code>是<code>Linux</code>内核提供的一种可以限制单个进程或者多个进程所使用的资源的机制，可以对<code>CPU</code>、内存等资源实现精细化的控制。<code>Docker</code>就使用<code>Cgroups</code>来对<code>CPU</code>、内存等部分资源进行控制。</p>
<p>如果<code>Linux</code>系统发行版使用<code>systemd</code>来初始化系统时，初始化进程会生成并使用一个<code>root</code>控制组，充当<code>cgroup</code>管理器。这时<code>systemd</code>和<code>Cgroups</code>紧密集成，并将为每个<code>systemd</code>单位分配一个<code>Cgroup</code>。更多<code>Cgroup</code>的内容可查看这里。</p>
<p>在安装容器运行时和<code>kubelet</code>时，可以为其指定一个<code>Cgroups</code>管理器，但<code>k8s</code>官网并不推荐这种配置，在资源压力下会变得不稳定。</p>
<p>容器运行时和<code>kubelet</code>以及<code>systemd</code>使用同一个<code>Cgroups</code>管理器，单个管理器会简化分配资源的视图，并且默认情况下对可用资源和使用的资源具有更一直的管理。</p>
<p>对于<code>Docker</code>容器运行时，可以设置<code>native.cgroupdriver=system</code>选项来配置。</p>
<h4 id="2-2-安装docker"><a href="#2-2-安装docker" class="headerlink" title="2.2 安装docker"></a>2.2 安装<code>docker</code></h4><p>需要在所有的服务器节点中安装<code>Docker</code></p>
<ol>
<li>安装所需包<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li>
<li>新增<code>docker</code>库<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装<code>docker-ce</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum update -y &amp;&amp; sudo yum install -y containerd.io-1.2.13 docker-ce-19.03.11 docker-ce-cli-19.03.11</span><br></pre></td></tr></table></figure></li>
<li>配置<code>Docker Daemon</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 创建&#x2F;etc&#x2F;docker目录</span><br><span class="line">sudo mkdir &#x2F;etc&#x2F;docker</span><br><span class="line"></span><br><span class="line">## 设置Docker Daemon</span><br><span class="line">cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver&#x3D;systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">  &quot;storage-opts&quot;: [</span><br><span class="line">    &quot;overlay2.override_kernel_check&#x3D;true&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li>
<li>配置<code>Docker</code>开机启动<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-安装kubeadm、kubelet和kubectl"><a href="#3-安装kubeadm、kubelet和kubectl" class="headerlink" title="3. 安装kubeadm、kubelet和kubectl"></a>3. 安装kubeadm、kubelet和kubectl</h3><h4 id="3-1-查看节点MAC地址和product-uuid的唯一性"><a href="#3-1-查看节点MAC地址和product-uuid的唯一性" class="headerlink" title="3.1 查看节点MAC地址和product_uuid的唯一性"></a>3.1 查看节点MAC地址和product_uuid的唯一性</h4><ul>
<li>通过命令ifconfig -a查看网络的MAC地址，其中ether后面的为网卡的MAC地址<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure></li>
<li>使用命令cat /sys/class/dmi/id/product_uuid对product_uuid校验</li>
</ul>
<p>正常情况，硬件设备的网络MAC地址和product_uuid都会有唯一值，但是虚拟机中可能会存在重复值。如果这两个配置不唯一，在安装kubeadm时可能会失败</p>
<h4 id="3-2-允许iptables检查桥接流量"><a href="#3-2-允许iptables检查桥接流量" class="headerlink" title="3.2 允许iptables检查桥接流量"></a>3.2 允许iptables检查桥接流量</h4><p>使用命令lsmod | grep br_netfilter来查看br_netfilter模块是否被加载。如果该模块没有被加载，可执行sudo modprobe br_netfilter来加载该模块。</p>
<p>设置服务节点中给的sysctl配置中的net.bridge.bridge-nf-call-iptables值为1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;modules-load.d&#x2F;k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line">$ cat &lt;&lt;EOF | sudo tee &#x2F;etc&#x2F;sysctl.d&#x2F;k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables &#x3D; 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables &#x3D; 1</span><br><span class="line">EOF</span><br><span class="line">$ sudo sysctl --system</span><br></pre></td></tr></table></figure>

<h4 id="3-3-安装kubeadm、kubelet和kubectl"><a href="#3-3-安装kubeadm、kubelet和kubectl" class="headerlink" title="3.3 安装kubeadm、kubelet和kubectl"></a>3.3 安装kubeadm、kubelet和kubectl</h4><p>需要在每台服务器中安装：</p>
<ul>
<li>kubeadm，用来初始化集群的指令</li>
<li>kubelet，在集群中的每个节点上用来启动Pod和容器等</li>
<li>kubectl，用来与集群通信的命令行工具</li>
</ul>
<p>kubeadmin、kubelet和kubectl需要单独安装，因此，需要确保他们的版本相匹配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;yum.repos.d&#x2F;kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name&#x3D;Kubernetes</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;repos&#x2F;kubernetes-el7-x86_64</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line">repo_gpgcheck&#x3D;0</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;yum-key.gpg https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kubernetes&#x2F;yum&#x2F;doc&#x2F;rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 将 SELinux 设置为 permissive 模式（相当于将其禁用）</span><br><span class="line">$ setenforce 0</span><br><span class="line">$ sed -i &#39;s&#x2F;^SELINUX&#x3D;enforcing$&#x2F;SELINUX&#x3D;permissive&#x2F;&#39; &#x2F;etc&#x2F;selinux&#x2F;config</span><br><span class="line"></span><br><span class="line">$ yum install -y kubelet kubeadm kubectl --disableexcludes&#x3D;kubernetes</span><br><span class="line"></span><br><span class="line">$ systemctl enable --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="配置master节点"><a href="#配置master节点" class="headerlink" title="配置master节点"></a>配置master节点</h3><ol>
<li>在<code>work</code>容器中执行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubeadm init \</span><br><span class="line">  --apiserver-advertise-address&#x3D;192.168.0.31 \</span><br><span class="line">  --image-repository registry.aliyuncs.com&#x2F;google_containers \</span><br><span class="line">  --service-cidr&#x3D;10.96.0.0&#x2F;12 \</span><br><span class="line">  --pod-network-cidr&#x3D;10.244.0.0&#x2F;16</span><br></pre></td></tr></table></figure>
其中，</li>
</ol>
<p>–apiserver-advertise-address，API服务器所公布的其正在监听的IP地址，如果没有设置，将会使用默认网络接口<br>–image-repository，拉取镜像的容器仓库<br>–service-cidr，为服务的虚拟IP地址另外指定的IP地址段，默认值为”10.96.0.0/12”<br>–pod-network-cidr， 指明 pod 网络可以使用的 IP 地址段。如果设置了这个参数，控制平面将会为每一个节点自动分配 CIDRs</p>
<ol start="2">
<li><p>为用户设置权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p $HOME&#x2F;.kube</span><br><span class="line">$ sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">$ sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure></li>
<li><p>安装POD网络插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;coreos&#x2F;flannel&#x2F;master&#x2F;Documentation&#x2F;kube-flannel.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>token过期重新获取join命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@test ~]# kubeadm token generate #生成token</span><br><span class="line">pmiad9.1g4qrc4yvkqxggse  #下条命令需要使用这个结果</span><br><span class="line">[root@test ~]# kubeadm token create pmiad9.1g4qrc4yvkqxggse --print-join-command --ttl&#x3D;0  #根据token输出添加命令</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-Toolbox修改源</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/dockertoolbox/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建虚拟机</span><br><span class="line">docker-machine create --engine-registry-mirror&#x3D;https:&#x2F;&#x2F;ra1frvk6.mirror.aliyuncs.com --driver virtualbox default</span><br><span class="line"># 删除虚拟机</span><br><span class="line">docker-machine rm default</span><br><span class="line"></span><br><span class="line"># docker-machine ssh default</span><br><span class="line"></span><br><span class="line"># sudo vi &#x2F;var&#x2F;lib&#x2F;boot2docker&#x2F;profile</span><br><span class="line"></span><br><span class="line">然后在--label provider&#x3D;virtualbox的下一行添加--registry-mirror&#x3D;加速地址</span><br><span class="line">--registry-mirror&#x3D;https:&#x2F;&#x2F;ra1frvk6.mirror.aliyuncs.com</span><br><span class="line">&#x2F;&#x2F; 保存并退出</span><br><span class="line"></span><br><span class="line"># docker-machine restart default</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>centos手动添加环境变量</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/centos_path/</url>
    <content><![CDATA[<h3 id="打印当前系统的环境变量"><a href="#打印当前系统的环境变量" class="headerlink" title="打印当前系统的环境变量"></a>打印当前系统的环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>

<h3 id="添加系统环境变量"><a href="#添加系统环境变量" class="headerlink" title="添加系统环境变量"></a>添加系统环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 找到文件最后一行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 原内容为：</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin:$PATH</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 增加新的环境变量</span><br><span class="line">&#x2F;&#x2F; 输入需要增加的目录，多个目录以 : 分割即可</span><br><span class="line">export PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin:&#x2F;root&#x2F;.config&#x2F;composer&#x2F;vendor&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

<h3 id="启用增加的环境变量"><a href="#启用增加的环境变量" class="headerlink" title="启用增加的环境变量"></a>启用增加的环境变量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>6.centos设置时区</title>
    <url>/2021/12/31/k8s/6.centos%E8%AE%BE%E7%BD%AE%E6%97%B6%E5%8C%BA/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timedatectl status|grep &#39;Time zone&#39;</span><br><span class="line"></span><br><span class="line">timedatectl set-local-rtc 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timedatectl set-timezone Asia&#x2F;Shanghai</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>跨云swarm部署MySQL主从</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/docker-swarm-mysql/</url>
    <content><![CDATA[<h4 id="1、获取mysql镜像"><a href="#1、获取mysql镜像" class="headerlink" title="1、获取mysql镜像"></a>1、获取mysql镜像</h4><pre><code>docker pull mysql:5.7</code></pre><h4 id="2、设置配置文件"><a href="#2、设置配置文件" class="headerlink" title="2、设置配置文件"></a>2、设置配置文件</h4><pre><code>1、主服务器1：
新建目录：/data/docker/mysql/conf/
新建文件：master.cnf
[mysqld]
server_id = 999  ##mysql服务器的唯一标识，每个都不一样

log-bin = mysql-bin

2、主服务器2：
新建目录：/data/docker/mysql/conf/
新建文件：master.cnf
[mysqld]
server_id = 101  ##mysql服务器的唯一标识，每个都不一样

log-bin = mysql-bin</code></pre><h4 id="3、分别创建mysql主从服务器的docker容器"><a href="#3、分别创建mysql主从服务器的docker容器" class="headerlink" title="3、分别创建mysql主从服务器的docker容器"></a>3、分别创建mysql主从服务器的docker容器</h4><pre><code>docker run -p 3306:3306 --name mysql-master-01 --network my_net --restart always \
    -v /data/docker/mysql/conf:/etc/mysql/conf.d \
    -v /data/docker/mysql/data:/var/lib/mysql \
    -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7

docker run -p 3306:3306 --name mysql-master-02 --network my_net --restart always \
    -v /data/docker/mysql/conf:/etc/mysql/conf.d \
    -v /data/docker/mysql/data:/var/lib/mysql \
    -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</code></pre><h4 id="4、mysql主服务器设置："><a href="#4、mysql主服务器设置：" class="headerlink" title="4、mysql主服务器设置："></a>4、mysql主服务器设置：</h4><pre><code>docker exec -i -t mysql-master-01 /bin/bash

mysql -u root -p
//创建一个同步数据的账号
GRANT REPLICATION SLAVE ON *.* to &apos;backup&apos;@&apos;%&apos; identified by &apos;123456&apos;;
//查看状态，记住File、Position的值，在Slaver中将用到
show master status;</code></pre><h4 id="5、mysql从服务器设置："><a href="#5、mysql从服务器设置：" class="headerlink" title="5、mysql从服务器设置："></a>5、mysql从服务器设置：</h4><pre><code>docker exec -i -t mysql-master-02 /bin/bash

mysql -u root -p

//设置主库链接
change master to master_host=&apos;mysql-master-01&apos;,master_user=&apos;backup&apos;,
    master_password=&apos;123456&apos;,master_log_file=&apos;mysql-bin.000001&apos;,master_log_pos=154,master_port=3306;

//启动从库同步    
start slave; 

//查看状态  
show slave status\G;</code></pre><p><img src="/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/docker-swarm-mysql/1.png" alt></p>
<p>这种情况说明mysql主从同步配置成功</p>
<blockquote>
<p>备注1：</p>
</blockquote>
<p>我一开始总是报错：Slave_IO_Running: Connecting；原因是在设置主库链接时我将ip地址设置为localhost；改为实际ip192.168.56.101即可  </p>
<blockquote>
<p>备注2（从服务器设置）：</p>
</blockquote>
<ol>
<li>master_host：主库地址</li>
<li>master_user：主库创建的同步账号</li>
<li>master_password：主库创建的同步密码</li>
<li>master_log_file：主库产生的日志（File）</li>
<li>master_log_pos：主库日志记录偏移量（Position）</li>
<li>master_port：主库使用的端口，默认为3306；我的是29001</li>
</ol>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>9.配置linux的vpn客户端</title>
    <url>/2022/01/27/k8s/9.%E9%85%8D%E7%BD%AElinux%E7%9A%84vpn%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ubuntu and Debian</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install strongswan xl2tpd net-tools</span><br><span class="line"></span><br><span class="line"># Fedora</span><br><span class="line">yum install strongswan xl2tpd net-tools</span><br><span class="line"></span><br><span class="line"># CentOS</span><br><span class="line">yum install epel-release</span><br><span class="line">yum --enablerepo&#x3D;epel install strongswan xl2tpd net-tools</span><br></pre></td></tr></table></figure>

<h2 id="创建-VPN-变量（替换为你自己的值）："><a href="#创建-VPN-变量（替换为你自己的值）：" class="headerlink" title="创建 VPN 变量（替换为你自己的值）："></a>创建 VPN 变量（替换为你自己的值）：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VPN_SERVER_IP&#x3D;&#39;你的VPN服务器IP&#39;</span><br><span class="line">VPN_IPSEC_PSK&#x3D;&#39;你的IPsec预共享密钥&#39;</span><br><span class="line">VPN_USER&#x3D;&#39;你的VPN用户名&#39;</span><br><span class="line">VPN_PASSWORD&#x3D;&#39;你的VPN密码&#39;</span><br></pre></td></tr></table></figure>

<h2 id="配置-strongSwan："><a href="#配置-strongSwan：" class="headerlink" title="配置 strongSwan："></a>配置 strongSwan：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; &#x2F;etc&#x2F;ipsec.conf &lt;&lt;EOF</span><br><span class="line"># ipsec.conf - strongSwan IPsec configuration file</span><br><span class="line"></span><br><span class="line">conn myvpn</span><br><span class="line">  auto&#x3D;add</span><br><span class="line">  keyexchange&#x3D;ikev1</span><br><span class="line">  authby&#x3D;secret</span><br><span class="line">  type&#x3D;transport</span><br><span class="line">  left&#x3D;%defaultroute</span><br><span class="line">  leftprotoport&#x3D;17&#x2F;1701</span><br><span class="line">  rightprotoport&#x3D;17&#x2F;1701</span><br><span class="line">  right&#x3D;$VPN_SERVER_IP</span><br><span class="line">  ike&#x3D;aes128-sha1-modp2048</span><br><span class="line">  esp&#x3D;aes128-sha1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; &#x2F;etc&#x2F;ipsec.secrets &lt;&lt;EOF</span><br><span class="line">: PSK &quot;$VPN_IPSEC_PSK&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 600 &#x2F;etc&#x2F;ipsec.secrets</span><br><span class="line"></span><br><span class="line"># For CentOS and Fedora ONLY</span><br><span class="line">mv &#x2F;etc&#x2F;strongswan&#x2F;ipsec.conf &#x2F;etc&#x2F;strongswan&#x2F;ipsec.conf.old 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">mv &#x2F;etc&#x2F;strongswan&#x2F;ipsec.secrets &#x2F;etc&#x2F;strongswan&#x2F;ipsec.secrets.old 2&gt;&#x2F;dev&#x2F;null</span><br><span class="line">ln -s &#x2F;etc&#x2F;ipsec.conf &#x2F;etc&#x2F;strongswan&#x2F;ipsec.conf</span><br><span class="line">ln -s &#x2F;etc&#x2F;ipsec.secrets &#x2F;etc&#x2F;strongswan&#x2F;ipsec.secrets</span><br></pre></td></tr></table></figure>

<h2 id="配置-xl2tpd："><a href="#配置-xl2tpd：" class="headerlink" title="配置 xl2tpd："></a>配置 xl2tpd：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &gt; &#x2F;etc&#x2F;xl2tpd&#x2F;xl2tpd.conf &lt;&lt;EOF</span><br><span class="line">[lac myvpn]</span><br><span class="line">lns &#x3D; $VPN_SERVER_IP</span><br><span class="line">ppp debug &#x3D; yes</span><br><span class="line">pppoptfile &#x3D; &#x2F;etc&#x2F;ppp&#x2F;options.l2tpd.client</span><br><span class="line">length bit &#x3D; yes</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &gt; &#x2F;etc&#x2F;ppp&#x2F;options.l2tpd.client &lt;&lt;EOF</span><br><span class="line">ipcp-accept-local</span><br><span class="line">ipcp-accept-remote</span><br><span class="line">refuse-eap</span><br><span class="line">require-chap</span><br><span class="line">noccp</span><br><span class="line">noauth</span><br><span class="line">mtu 1280</span><br><span class="line">mru 1280</span><br><span class="line">noipdefault</span><br><span class="line">defaultroute</span><br><span class="line">usepeerdns</span><br><span class="line">connect-delay 5000</span><br><span class="line">name &quot;$VPN_USER&quot;</span><br><span class="line">password &quot;$VPN_PASSWORD&quot;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">chmod 600 &#x2F;etc&#x2F;ppp&#x2F;options.l2tpd.client</span><br></pre></td></tr></table></figure>
<p>至此 VPN 客户端配置已完成。按照下面的步骤进行连接。</p>
<p>注： 当你每次尝试连接到 VPN 时，必须重复下面的所有步骤。</p>
<h2 id="创建-xl2tpd-控制文件："><a href="#创建-xl2tpd-控制文件：" class="headerlink" title="创建 xl2tpd 控制文件："></a>创建 xl2tpd 控制文件：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;var&#x2F;run&#x2F;xl2tpd</span><br><span class="line">touch &#x2F;var&#x2F;run&#x2F;xl2tpd&#x2F;l2tp-control</span><br></pre></td></tr></table></figure>
<h2 id="重启服务："><a href="#重启服务：" class="headerlink" title="重启服务："></a>重启服务：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service strongswan restart</span><br><span class="line"></span><br><span class="line"># 适用于 Ubuntu 20.04，如果 strongswan 服务不存在</span><br><span class="line">ipsec restart</span><br><span class="line"></span><br><span class="line">service xl2tpd restart</span><br></pre></td></tr></table></figure>

<h2 id="开始-IPsec-连接："><a href="#开始-IPsec-连接：" class="headerlink" title="开始 IPsec 连接："></a>开始 IPsec 连接：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ubuntu and Debian</span><br><span class="line">ipsec up myvpn</span><br><span class="line"></span><br><span class="line"># CentOS and Fedora</span><br><span class="line">strongswan up myvpn</span><br></pre></td></tr></table></figure>
<h2 id="开始-L2TP-连接："><a href="#开始-L2TP-连接：" class="headerlink" title="开始 L2TP 连接："></a>开始 L2TP 连接：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;c myvpn&quot; &gt; &#x2F;var&#x2F;run&#x2F;xl2tpd&#x2F;l2tp-control</span><br></pre></td></tr></table></figure>
<p>运行 ifconfig 并且检查输出。现在你应该看到一个新的网络接口 ppp0。</p>
<h2 id="检查你现有的默认路由："><a href="#检查你现有的默认路由：" class="headerlink" title="检查你现有的默认路由："></a>检查你现有的默认路由：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure>
<p>在输出中查找以下行： default via X.X.X.X …。记下这个网关 IP，并且在下面的两个命令中使用。</p>
<p>从新的默认路由中排除你的 VPN 服务器的公有 IP（替换为你自己的值）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route add 你的VPN服务器的公有IP gw X.X.X.X</span><br></pre></td></tr></table></figure>
<p>如果你的 VPN 客户端是一个远程服务器，则必须从新的默认路由中排除你的本地电脑的公有 IP，以避免 SSH 会话被断开 （替换为实际值）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route add 你的本地电脑的公有IP gw X.X.X.X</span><br></pre></td></tr></table></figure>
<p>添加一个新的默认路由，并且开始通过 VPN 服务器发送数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route add default dev ppp0</span><br></pre></td></tr></table></figure>
<p>至此 VPN 连接已成功完成。检查 VPN 是否正常工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO- http:&#x2F;&#x2F;ipv4.icanhazip.com; echo</span><br></pre></td></tr></table></figure>
<p>以上命令应该返回 你的 VPN 服务器 IP。</p>
<p>要停止通过 VPN 服务器发送数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route del default dev ppp0</span><br></pre></td></tr></table></figure>
<h2 id="要断开连接："><a href="#要断开连接：" class="headerlink" title="要断开连接："></a>要断开连接：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ubuntu and Debian</span><br><span class="line">echo &quot;d myvpn&quot; &gt; &#x2F;var&#x2F;run&#x2F;xl2tpd&#x2F;l2tp-control</span><br><span class="line">ipsec down myvpn</span><br><span class="line"></span><br><span class="line"># CentOS and Fedora</span><br><span class="line">echo &quot;d myvpn&quot; &gt; &#x2F;var&#x2F;run&#x2F;xl2tpd&#x2F;l2tp-control</span><br><span class="line">strongswan down myvpn</span><br></pre></td></tr></table></figure>

<h2 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h2><p><a href="https://github.com/hwdsl2/setup-ipsec-vpn/blob/master/docs/clients-zh.md#%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE-linux-vpn-%E5%AE%A2%E6%88%B7%E7%AB%AF" target="_blank" rel="noopener">参考地址</a></p>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装jenkins</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/jenkins/</url>
    <content><![CDATA[<p>1、docker运行Jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -u root -d --name jenkins --network my_net --restart always -v &#x2F;data&#x2F;docker&#x2F;jenkins_data:&#x2F;var&#x2F;jenkins_home -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v &#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker -p 8080:8080 -p 50000:50000 jenkins&#x2F;jenkins:lts</span><br></pre></td></tr></table></figure>

<p>2、获取登录密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it jenkins cat &#x2F;var&#x2F;jenkins_home&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure>

<p>3、网络配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一步</span><br><span class="line">vim &#x2F;var&#x2F;jenkins_home&#x2F;updates&#x2F;default.json</span><br><span class="line"></span><br><span class="line">将&#96;https:&#x2F;&#x2F;www.google.com&#96;改为&#96;https:&#x2F;&#x2F;www.baidu.com&#96;</span><br><span class="line"></span><br><span class="line">第二步</span><br><span class="line">然后打开一个新的tab，输入网址http:&#x2F;&#x2F;localhost:8080&#x2F;pluginManager&#x2F;advanced。 这里面最底下有个【升级站点】，把其中的链接改成http的就好了或者国内的备用地址，http:&#x2F;&#x2F;updates.jenkins.io&#x2F;update-center.json。</span><br><span class="line">https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;updates&#x2F;update-center.json</span><br></pre></td></tr></table></figure>



<p>4、生成凭据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入容器</span><br><span class="line">docker exec -it jenkins bash</span><br><span class="line"># 生成ssh，一路回车就行了</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"># 获取密钥，下图Private Key的值</span><br><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line"># 获取公钥，加入到github的 SSH keys 里</span><br><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line"># 远程主机免密登录</span><br><span class="line">ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub root@172.19.0.1</span><br></pre></td></tr></table></figure>



<p>设置时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 打开 【系统管理】-&gt;【脚本命令行】运行下面的命令</span><br><span class="line">System.setProperty(&#39;org.apache.commons.jelly.tags.fmt.timeZone&#39;, &#39;Asia&#x2F;Shanghai&#39;)</span><br></pre></td></tr></table></figure>





<p>hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">echo &quot;list hexo&quot;</span><br><span class="line">npm list hexo</span><br><span class="line">npm install hexo-cli -g</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo d -g</span><br></pre></td></tr></table></figure>

<p>为什么我使用Jenkins部署hexo时会出现时间错乱呢，最近一段时间的文章，部署之后的时间都变成一样的了</p>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>php使用Kafka生产和消费</title>
    <url>/2020/08/27/%E6%9C%8D%E5%8A%A1%E5%99%A8/kafka/</url>
    <content><![CDATA[<h3 id="使用docker快速部署kafka"><a href="#使用docker快速部署kafka" class="headerlink" title="使用docker快速部署kafka"></a>使用docker快速部署kafka</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim docker-compose.yml</span><br><span class="line"></span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  zookeeper:</span><br><span class="line">    image: wurstmeister&#x2F;zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;2181:2181&quot;</span><br><span class="line">  kafka:</span><br><span class="line">    image: wurstmeister&#x2F;kafka</span><br><span class="line">    depends_on: </span><br><span class="line">      - zookeeper</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9092:9092&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KAFKA_ADVERTISED_HOST_NAME: 192.168.56.112</span><br><span class="line">      KAFKA_LISTENERS: PLAINTEXT:&#x2F;&#x2F;0.0.0.0:9092</span><br><span class="line">      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181</span><br><span class="line">      KAFKA_CREATE_TOPICS: &quot;test&quot;</span><br><span class="line">  kafka-manager:</span><br><span class="line">    image: sheepkiller&#x2F;kafka-manager</span><br><span class="line">    depends_on: </span><br><span class="line">      - zookeeper</span><br><span class="line">      - kafka</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9000:9000&quot;</span><br><span class="line">    environment:</span><br><span class="line">      ZK_HOSTS: zookeeper:2181</span><br></pre></td></tr></table></figure>



<h3 id="安装php的Kafka扩展"><a href="#安装php的Kafka扩展" class="headerlink" title="安装php的Kafka扩展"></a>安装php的Kafka扩展</h3><ol>
<li><p>安装<code>librdkafka</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;edenhill&#x2F;librdkafka.git</span><br><span class="line">cd librdkafka</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装<code>php-rdkafka</code>扩展</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;arnaud-lb&#x2F;php-rdkafka.git</span><br><span class="line"> </span><br><span class="line">#生成configure文件</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;phpize </span><br><span class="line"> </span><br><span class="line">#编译安装</span><br><span class="line">.&#x2F;configure --with-php-config&#x3D;&#x2F;usr&#x2F;local&#x2F;php&#x2F;bin&#x2F;php-config</span><br><span class="line">make</span><br><span class="line">make install </span><br><span class="line"> </span><br><span class="line">#在php.ini 文件中配置 rdkafka扩展</span><br><span class="line">vim &#x2F;usr&#x2F;local&#x2F;php&#x2F;etc&#x2F;php.ini</span><br><span class="line">extension&#x3D;rdkafka.so</span><br><span class="line"> </span><br><span class="line">#查看扩展是否生效</span><br><span class="line">php -m | grep kafka</span><br></pre></td></tr></table></figure>






</li>
</ol>
<h3 id="php使用Kafka"><a href="#php使用Kafka" class="headerlink" title="php使用Kafka"></a>php使用Kafka</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class kafka</span><br><span class="line">&#123;</span><br><span class="line">    public $broker_list;</span><br><span class="line">    public $topic;</span><br><span class="line">    public $group_id;</span><br><span class="line">    protected $producer &#x3D; null;</span><br><span class="line">    protected $consumer &#x3D; null;</span><br><span class="line">    protected $receive_wait_time;</span><br><span class="line">    protected $receive_wait_num;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;broker_list &#x3D; config(&#39;kafka.broker_list&#39;);</span><br><span class="line">        $this-&gt;topic &#x3D; config(&#39;kafka.default_topic&#39;);</span><br><span class="line">        $this-&gt;group_id &#x3D; config(&#39;kafka.default_group_id&#39;);</span><br><span class="line">        $this-&gt;producer &#x3D; null;</span><br><span class="line">        $this-&gt;consumer &#x3D; null;</span><br><span class="line">        $this-&gt;receive_wait_time &#x3D; config(&#39;kafka.default_receive_wait_time&#39;, 10);</span><br><span class="line">        $this-&gt;receive_wait_num &#x3D; config(&#39;kafka.default_receive_wait_num&#39;, 100);</span><br><span class="line">    &#125;</span><br><span class="line">	&#x2F;**</span><br><span class="line">     * 获取生产者</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function Producer()</span><br><span class="line">    &#123;</span><br><span class="line">        $conf &#x3D; new \RdKafka\Conf();</span><br><span class="line">        $conf-&gt;set(&#39;bootstrap.servers&#39;, $this-&gt;broker_list);</span><br><span class="line">        &#x2F;&#x2F; 0:不会等待服务器的反馈。该消息会被立刻添加到 socket buffer 中并认为已经发送完成</span><br><span class="line">        &#x2F;&#x2F; 1:leader节点会将记录写入本地日志，并且在所有 follower 节点反馈之前就先确认成功</span><br><span class="line">        &#x2F;&#x2F; all:leader 节点会等待所有同步中的副本确认之后再确认这条记录是否发送完成</span><br><span class="line">        $conf-&gt;set(&#39;acks&#39;, &#39;0&#39;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;If you need to produce exactly once and want to keep the original produce order, uncomment the line below</span><br><span class="line">        &#x2F;&#x2F;$conf-&gt;set(&#39;enable.idempotence&#39;, &#39;true&#39;);</span><br><span class="line"></span><br><span class="line">        $producer &#x3D; new \RdKafka\Producer($conf);</span><br><span class="line"></span><br><span class="line">        $this-&gt;producer &#x3D; $producer;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 发送消息</span><br><span class="line">     *</span><br><span class="line">     * @param string|array $msg</span><br><span class="line">     * @param string $topic</span><br><span class="line">     * @return void</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function SendMsg($msg &#x3D; &#39;&#39;, $topic &#x3D; &#39;&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (empty($topic)) &#123;</span><br><span class="line">            $topic &#x3D; $this-&gt;topic;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $producer &#x3D; $this-&gt;producer;</span><br><span class="line"></span><br><span class="line">        $topic &#x3D; $producer-&gt;newTopic($topic);</span><br><span class="line"></span><br><span class="line">        if (!is_array($msg)) &#123;</span><br><span class="line">            $msg &#x3D; [$msg];</span><br><span class="line">        &#125;</span><br><span class="line">        foreach ($msg as $value) &#123;</span><br><span class="line">            $topic-&gt;produce(RD_KAFKA_PARTITION_UA, 0, $value);</span><br><span class="line">            $producer-&gt;poll(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for ($flushRetries &#x3D; 0; $flushRetries &lt; count($msg); $flushRetries++) &#123;</span><br><span class="line">            $result &#x3D; $producer-&gt;flush(10000);</span><br><span class="line">            if (RD_KAFKA_RESP_ERR_NO_ERROR &#x3D;&#x3D;&#x3D; $result) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (RD_KAFKA_RESP_ERR_NO_ERROR !&#x3D;&#x3D; $result) &#123;</span><br><span class="line">            throw new \RuntimeException(&#39;Kafka消息发送失败&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 获取消费者</span><br><span class="line">     *</span><br><span class="line">     * @param string $group_id</span><br><span class="line">     * @return void</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function Consumer($group_id &#x3D; &#39;&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        $conf &#x3D; new \RdKafka\Conf();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Set a rebalance callback to log partition assignments (optional)</span><br><span class="line">        $conf-&gt;setRebalanceCb(function (\RdKafka\KafkaConsumer $kafka, $err, array $partitions &#x3D; null) &#123;</span><br><span class="line">            switch ($err) &#123;</span><br><span class="line">                case RD_KAFKA_RESP_ERR__ASSIGN_PARTITIONS:</span><br><span class="line">                    echo &quot;Assign: &quot;;</span><br><span class="line">                    var_dump($partitions);</span><br><span class="line">                    $kafka-&gt;assign($partitions);</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                case RD_KAFKA_RESP_ERR__REVOKE_PARTITIONS:</span><br><span class="line">                    echo &quot;Revoke: &quot;;</span><br><span class="line">                    var_dump($partitions);</span><br><span class="line">                    $kafka-&gt;assign(NULL);</span><br><span class="line">                    break;</span><br><span class="line"></span><br><span class="line">                default:</span><br><span class="line">                    throw new \Exception($err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Configure the group.id. All consumer with the same group.id will consume</span><br><span class="line">        &#x2F;&#x2F; different partitions.</span><br><span class="line">        if (empty($group_id)) &#123;</span><br><span class="line">            $group_id &#x3D; $this-&gt;group_id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置相同的group，防止一次消息被多次消费。</span><br><span class="line">        &#x2F;&#x2F; 消费者启动的进程数应小于等于topic的分区数，否则多余的进程是无用的</span><br><span class="line">        $conf-&gt;set(&#39;group.id&#39;, $group_id);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Initial list of Kafka brokers</span><br><span class="line">        $conf-&gt;set(&#39;bootstrap.servers&#39;, $this-&gt;broker_list);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Set where to start consuming messages when there is no initial offset in</span><br><span class="line">        &#x2F;&#x2F; offset store or the desired offset is out of range.</span><br><span class="line">        &#x2F;&#x2F; &#39;smallest&#39;: start from the beginning</span><br><span class="line">        &#x2F;&#x2F;earliest：简单理解为从头开始消费，latest：简单理解为从最新的开始消费</span><br><span class="line">        $conf-&gt;set(&#39;auto.offset.reset&#39;, &#39;earliest&#39;);</span><br><span class="line">        &#x2F;&#x2F; 在interval.ms的时间内定期向ZooKeeper提交使用者已获取的消息的偏移量</span><br><span class="line">        &#x2F;&#x2F; 自动提交分区消费的位置，手动可确保消息被消费</span><br><span class="line">        $conf-&gt;set(&#39;enable.auto.commit&#39;, true);</span><br><span class="line">        $conf-&gt;set(&#39;auto.commit.interval.ms&#39;, 1000);</span><br><span class="line"></span><br><span class="line">        $consumer &#x3D; new \RdKafka\KafkaConsumer($conf);</span><br><span class="line"></span><br><span class="line">        $this-&gt;consumer &#x3D; $consumer;</span><br><span class="line">        return $this;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 接收消息</span><br><span class="line">     *</span><br><span class="line">     * @param string $topic</span><br><span class="line">     * @param array $callback</span><br><span class="line">     * @return void</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public function ReceiveMsg($topic &#x3D; &#39;&#39;, array $callback &#x3D; [])</span><br><span class="line">    &#123;</span><br><span class="line">        $consumer &#x3D; $this-&gt;consumer;</span><br><span class="line"></span><br><span class="line">        if (empty($topic)) &#123;</span><br><span class="line">            $topic &#x3D; $this-&gt;topic;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!is_array($topic)) &#123;</span><br><span class="line">            $topic &#x3D; [$topic];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Subscribe to topic &#39;test&#39;</span><br><span class="line">        $consumer-&gt;subscribe($topic);</span><br><span class="line"></span><br><span class="line">        echo &quot;Waiting for partition assignment... (make take some time when\n&quot;;</span><br><span class="line">        echo &quot;quickly re-joining the group after leaving it.)\n&quot;;</span><br><span class="line"></span><br><span class="line">        $i &#x3D; 0;</span><br><span class="line">        $msg_list &#x3D; [];</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            $i++;</span><br><span class="line">            if ($i &gt; $this-&gt;receive_wait_time) &#123;</span><br><span class="line">                $i &#x3D; 0;</span><br><span class="line">                if (empty($msg_list)) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!empty($callback)) &#123;</span><br><span class="line">                    call_user_func_array($callback, [$msg_list]);</span><br><span class="line">                &#125;</span><br><span class="line">                $msg_list &#x3D; [];</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 阻塞一秒钟</span><br><span class="line">            $message &#x3D; $consumer-&gt;consume(1000);</span><br><span class="line">            switch ($message-&gt;err) &#123;</span><br><span class="line">                case RD_KAFKA_RESP_ERR_NO_ERROR:</span><br><span class="line">                    $msg_list[] &#x3D; $message-&gt;payload;</span><br><span class="line">                    if (count($msg_list) &lt; $this-&gt;receive_wait_num) &#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!empty($callback)) &#123;</span><br><span class="line">                        call_user_func_array($callback, [$msg_list]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    $i &#x3D; 0;</span><br><span class="line">                    $msg_list &#x3D; [];</span><br><span class="line">                    break;</span><br><span class="line">                case RD_KAFKA_RESP_ERR__PARTITION_EOF:</span><br><span class="line">                    &#x2F;&#x2F; echo &quot;No more messages; will wait for more\n&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                case RD_KAFKA_RESP_ERR__TIMED_OUT:</span><br><span class="line">                    &#x2F;&#x2F; echo &quot;Timed out\n&quot;;</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    throw new \Exception($message-&gt;errstr(), $message-&gt;err);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看topic列表</span><br><span class="line">&gt; bin&#x2F;kafka-topics.sh --list --zookeeper zookeeper:2181</span><br><span class="line"></span><br><span class="line"># 创建topic</span><br><span class="line">&gt; bin&#x2F;kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 2 --topic test</span><br><span class="line"></span><br><span class="line"># 查看topic分区情况</span><br><span class="line">&gt; bin&#x2F;kafka-topics.sh --zookeeper zookeeper:2181 --describe --topic test</span><br><span class="line"></span><br><span class="line"># 修改topic分区数</span><br><span class="line">&gt; bin&#x2F;kafka-topics.sh --zookeeper zookeeper:2181 -alter --partitions 5 --topic test1</span><br></pre></td></tr></table></figure>



<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">生产者：</span><br><span class="line"></span><br><span class="line">$service &#x3D; new kafka();</span><br><span class="line">$service-&gt;Producer()-&gt;sendMsg(json_encode([&#39;msg&#39;&#x3D;&gt;&#39;hello world&#39;, &#39;name&#39;&#x3D;&gt;&#39;xupengfei&#39;], 320), &#39;test_topic&#39;);</span><br><span class="line"></span><br><span class="line">消费者：</span><br><span class="line">$callbak是指定的类方法</span><br><span class="line"></span><br><span class="line">$service &#x3D; new kafka();</span><br><span class="line">$service-&gt;Consumer()-&gt;receiveMsg($topic, $callback);</span><br></pre></td></tr></table></figure>



<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol>
<li><a href="https://arnaud.le-blanc.net/php-rdkafka-doc/phpdoc/book.rdkafka.html" target="_blank" rel="noopener">https://arnaud.le-blanc.net/php-rdkafka-doc/phpdoc/book.rdkafka.html</a></li>
<li><a href="https://github.com/BCEBIGDATA/kafka-sample-php/blob/master/setup-librdkafka.sh" target="_blank" rel="noopener">https://github.com/BCEBIGDATA/kafka-sample-php/blob/master/setup-librdkafka.sh</a></li>
</ol>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/linux/</url>
    <content><![CDATA[<ol>
<li><p>查看进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>查看文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、tail -n -数字 文件名。</span><br><span class="line"></span><br><span class="line">tail -n -数字 文件名，表示查看文件的最后几行，比如查看SpecialVariable.sh的最后5行，tail -n -5 SpecialVariable.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、tail -n +数字 文件名。</span><br><span class="line"></span><br><span class="line">tail -n +数字 文件名，表示查看文件的某一行到最后一行，比如查看SpecialVariable.sh的第3行到最后一行，tail -n +3 SpecialVariable.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、head -n 数字 文件名。</span><br><span class="line"></span><br><span class="line">head -n 数字 文件名，表示查看文件前几行的内容，比如查看SpecialVariable.sh的前3行内容，head -n 3 SpecialVariable.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、sed -n &quot;开始行，结束行p&quot; 文件名。</span><br><span class="line"></span><br><span class="line">sed -n &quot;开始行，结束行p&quot; 文件名，表示查看文件的开始行到结束行的内容</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>查看端口占用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -anp |grep</span><br><span class="line"></span><br><span class="line">1、强制杀死该端口进程</span><br><span class="line"></span><br><span class="line">      sudo fuser -k -n tcp 80</span><br><span class="line"></span><br><span class="line">2、根据PID关闭某个被占用的端口</span><br><span class="line"></span><br><span class="line">      netstat -tunlp | grep 80</span><br><span class="line">	  查看被占用端口的PID</span><br><span class="line">      lsof -i:80</span><br><span class="line">      强制杀死进程</span><br><span class="line">      sudo kill -9 PID</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>查看文件夹树形结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql导出数据字典</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/mysql_dictionary/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## use information_schema</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">    T.TABLE_SCHEMA AS &#39;数据库名称&#39;,</span><br><span class="line">    T.TABLE_NAME AS &#39;表名&#39;,</span><br><span class="line">    C.ORDINAL_POSITION AS &#39;字段编号&#39;,</span><br><span class="line">    C.COLUMN_NAME AS &#39;字段名&#39;,</span><br><span class="line">    C.COLUMN_TYPE AS &#39;数据类型&#39;,</span><br><span class="line">    C.IS_NULLABLE AS &#39;允许为空&#39;,</span><br><span class="line">    C.COLUMN_KEY AS &#39;键类型&#39;,</span><br><span class="line">    C.EXTRA AS &#39;自增属性&#39;,</span><br><span class="line">    C.CHARACTER_SET_NAME AS &#39;编码名称&#39;,</span><br><span class="line">    C.COLUMN_COMMENT AS &#39;字段说明&#39;</span><br><span class="line">FROM</span><br><span class="line">    COLUMNS C</span><br><span class="line">INNER JOIN TABLES T ON C.TABLE_SCHEMA &#x3D; T.TABLE_SCHEMA</span><br><span class="line">AND C.TABLE_NAME &#x3D; T.TABLE_NAME</span><br><span class="line">WHERE</span><br><span class="line">    T.TABLE_SCHEMA &#x3D; &#39;mysql&#39;	### 要导出的数据库</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">## 将查询结果导出</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>部署kong网关</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/kong/</url>
    <content><![CDATA[<h3 id="安装postgres"><a href="#安装postgres" class="headerlink" title="安装postgres"></a>安装postgres</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --restart always --name postgres \</span><br><span class="line">               --network&#x3D;my_net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e &quot;POSTGRES_USER&#x3D;kong&quot; \</span><br><span class="line">               -e &quot;POSTGRES_DB&#x3D;kong&quot; \</span><br><span class="line">               -e &quot;POSTGRES_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">               -v &#x2F;data&#x2F;docker&#x2F;postgres:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure>

<h3 id="使用kong初始化postgres"><a href="#使用kong初始化postgres" class="headerlink" title="使用kong初始化postgres"></a>使用kong初始化postgres</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">     --network&#x3D;my_net \</span><br><span class="line">     -e &quot;KONG_DATABASE&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">     kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure>

<h3 id="安装kong"><a href="#安装kong" class="headerlink" title="安装kong"></a>安装kong</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">	--name kong \</span><br><span class="line">	--network my_net \</span><br><span class="line">    -e &quot;KONG_DATABASE&#x3D;postgres&quot; \</span><br><span class="line">    -e &quot;KONG_PG_HOST&#x3D;postgres&quot; \</span><br><span class="line">    -e &quot;KONG_PG_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">    -e &quot;KONG_PROXY_ACCESS_LOG&#x3D;&#x2F;dev&#x2F;stdout&quot; \</span><br><span class="line">    -e &quot;KONG_ADMIN_ACCESS_LOG&#x3D;&#x2F;dev&#x2F;stdout&quot; \</span><br><span class="line">    -e &quot;KONG_PROXY_ERROR_LOG&#x3D;&#x2F;dev&#x2F;stderr&quot; \</span><br><span class="line">    -e &quot;KONG_ADMIN_ERROR_LOG&#x3D;&#x2F;dev&#x2F;stderr&quot; \</span><br><span class="line">    -e &quot;KONG_ADMIN_LISTEN&#x3D;0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">    --publish 8000:8000 \</span><br><span class="line">    --publish 8001:8001 \</span><br><span class="line">    --publish 8443:8443 \</span><br><span class="line">    --publish 8444:8444 \</span><br><span class="line">	--replicas 1 \</span><br><span class="line">    kong:latest</span><br></pre></td></tr></table></figure>

<h3 id="安装konga"><a href="#安装konga" class="headerlink" title="安装konga"></a>安装konga</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create --network my_net --name konga --publish 1337:1337 --replicas 1 pantsel&#x2F;konga</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装redis</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/redis/</url>
    <content><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">改为</span><br><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure>



<h3 id="启动redis"><a href="#启动redis" class="headerlink" title="启动redis"></a>启动redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --network my_net --restart always -p 6379:6379 -d -v &#x2F;data&#x2F;docker&#x2F;redis&#x2F;conf&#x2F;redis.conf:&#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf --name redis redis:5 redis-server &#x2F;usr&#x2F;local&#x2F;etc&#x2F;redis&#x2F;redis.conf</span><br></pre></td></tr></table></figure>

<h3 id="安装gitlab"><a href="#安装gitlab" class="headerlink" title="安装gitlab"></a>安装gitlab</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line"> -p 9980:80 \</span><br><span class="line"> -p 9922:22 \</span><br><span class="line"> -v &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab  \</span><br><span class="line"> -v &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \</span><br><span class="line"> -v &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \</span><br><span class="line"> --restart always \</span><br><span class="line"> --network my_net \</span><br><span class="line"> --name gitlab \</span><br><span class="line"> gitlab&#x2F;gitlab-ce</span><br><span class="line"> </span><br><span class="line">## 修改配置文件</span><br><span class="line">vim &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;config&#x2F;gitlab.rb</span><br><span class="line">external_url &#39;http:&#x2F;&#x2F;gitlab.example.net&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_ssh_host&#39;] &#x3D; &#39;gitlab.example.net&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] &#x3D; 9922</span><br><span class="line"></span><br><span class="line">## 重启gitlab</span><br><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装sentry</title>
    <url>/2021/04/02/%E6%9C%8D%E5%8A%A1%E5%99%A8/sentry/</url>
    <content><![CDATA[<h3 id="redis的docker-compose-yml"><a href="#redis的docker-compose-yml" class="headerlink" title="redis的docker-compose.yml"></a>redis的docker-compose.yml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  sentry_redis:</span><br><span class="line">    container_name: sentry_redis</span><br><span class="line">    image: redis</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;e&#x2F;wsl&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data</span><br><span class="line">    ports:</span><br><span class="line">      - 6379:6379</span><br><span class="line">    networks:</span><br><span class="line">      - local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  local:</span><br><span class="line">    external:</span><br><span class="line">      name: local</span><br></pre></td></tr></table></figure>



<h3 id="postgres的docker-compose-yml文件"><a href="#postgres的docker-compose-yml文件" class="headerlink" title="postgres的docker-compose.yml文件"></a>postgres的docker-compose.yml文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  sentry_postgres:</span><br><span class="line">    container_name: sentry_postgres</span><br><span class="line">    image: postgres:9.6</span><br><span class="line">    privileged: true</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_USER: postgres</span><br><span class="line">      POSTGRES_PASSWORD: 123456</span><br><span class="line">    volumes:</span><br><span class="line">      - &#x2F;e&#x2F;wsl&#x2F;docker&#x2F;postgres&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data</span><br><span class="line">    ports:</span><br><span class="line">      - 5432:5432</span><br><span class="line">    networks:</span><br><span class="line">      - local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  local:</span><br><span class="line">    external:</span><br><span class="line">      name: local</span><br></pre></td></tr></table></figure>

<h3 id="sentry的docker-compose文件"><a href="#sentry的docker-compose文件" class="headerlink" title="sentry的docker-compose文件"></a>sentry的docker-compose文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  sentry:</span><br><span class="line">    container_name: sentry</span><br><span class="line">    image: sentry</span><br><span class="line">    environment:</span><br><span class="line">      SENTRY_REDIS_HOST: redis</span><br><span class="line">      SENTRY_POSTGRES_HOST: postgres</span><br><span class="line">      SENTRY_DB_USER: postgres</span><br><span class="line">      SENTRY_DB_PASSWORD: 123456</span><br><span class="line">      SENTRY_SECRET_KEY: 6mu1#ki^5ec#j3yp&amp;61bbe!*35scz(k))d0c#uz3!!2dx%wztz</span><br><span class="line">    ports:</span><br><span class="line">      - 9000:9000</span><br><span class="line">    networks:</span><br><span class="line">      - local</span><br><span class="line">  sentry-cron:</span><br><span class="line">    container_name: sentry-cron</span><br><span class="line">    image: sentry</span><br><span class="line">    command: &quot;sentry run cron&quot;</span><br><span class="line">    environment:</span><br><span class="line">      SENTRY_REDIS_HOST: redis</span><br><span class="line">      SENTRY_POSTGRES_HOST: postgres</span><br><span class="line">      SENTRY_DB_USER: postgres</span><br><span class="line">      SENTRY_DB_PASSWORD: 123456</span><br><span class="line">      SENTRY_SECRET_KEY: 6mu1#ki^5ec#j3yp&amp;61bbe!*35scz(k))d0c#uz3!!2dx%wztz</span><br><span class="line">    networks:</span><br><span class="line">      - local</span><br><span class="line">  sentry-worker:</span><br><span class="line">    container_name: sentry-worker</span><br><span class="line">    image: sentry</span><br><span class="line">    command: &quot;sentry run worker&quot;</span><br><span class="line">    environment:</span><br><span class="line">      SENTRY_REDIS_HOST: redis</span><br><span class="line">      SENTRY_POSTGRES_HOST: postgres</span><br><span class="line">      SENTRY_DB_USER: postgres</span><br><span class="line">      SENTRY_DB_PASSWORD: 123456</span><br><span class="line">      SENTRY_SECRET_KEY: 6mu1#ki^5ec#j3yp&amp;61bbe!*35scz(k))d0c#uz3!!2dx%wztz</span><br><span class="line">    networks:</span><br><span class="line">      - local</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  local:</span><br><span class="line">    external:</span><br><span class="line">      name: local</span><br></pre></td></tr></table></figure>



<h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm sentry config generate-secret-key</span><br></pre></td></tr></table></figure>



<h3 id="连接Redis、Postgres和Sentry，执行初始化操作"><a href="#连接Redis、Postgres和Sentry，执行初始化操作" class="headerlink" title="连接Redis、Postgres和Sentry，执行初始化操作"></a>连接Redis、Postgres和<strong>Sentry</strong>，执行初始化操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## postgres用户必须是超级用户</span><br><span class="line"></span><br><span class="line">docker run -it --rm -e SENTRY_SECRET_KEY&#x3D;&#39;&lt;secret-key&gt;&#39; -e SENTRY_REDIS_HOST&#x3D;&#39;redis&#39; -e SENTRY_POSTGRES_HOST&#x3D;&#39;postgres&#39; -e SENTRY_DB_USER&#x3D;&#39;sentry&#39; -e SENTRY_DB_PASSWORD&#x3D;&#39;secret&#39; --network &lt;network&gt; --link postgres:sentry_postgres --link redis:sentry_redis sentry upgrade</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it --rm -e SENTRY_SECRET_KEY&#x3D;&#39;ccvxndrlk&amp;l@511)#yu2t8y0q2m8&amp;x-gmr4bojd29t&amp;1vu+h8*&#39; -e SENTRY_REDIS_HOST&#x3D;&#39;redis&#39; -e SENTRY_POSTGRES_HOST&#x3D;&#39;postgres&#39; -e SENTRY_DB_USER&#x3D;&#39;postgres&#39; -e SENTRY_DB_PASSWORD&#x3D;&#39;ABC@123abc&#39; --network local --link postgres:postgres --link sentry_redis:redis sentry upgrade</span><br></pre></td></tr></table></figure>



<h3 id="启动sentry"><a href="#启动sentry" class="headerlink" title="启动sentry"></a>启动sentry</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>跨云部署docker swarm</title>
    <url>/2020/06/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%B7%A8%E4%BA%91%E9%83%A8%E7%BD%B2docker%20swarm/</url>
    <content><![CDATA[<blockquote>
<p>跨云部署docker swarm必须使用大于19.03的docker版本</p>
</blockquote>
<h3 id="组建跨云服务器的局域网"><a href="#组建跨云服务器的局域网" class="headerlink" title="组建跨云服务器的局域网"></a>组建跨云服务器的局域网</h3><h4 id="安装openvpn服务器"><a href="#安装openvpn服务器" class="headerlink" title="安装openvpn服务器"></a>安装openvpn服务器</h4><ol>
<li><p>使用GitHub上的一键安装脚本；地址：<a href="https://github.com/Nyr/openvpn-install" target="_blank" rel="noopener">https://github.com/Nyr/openvpn-install</a> </p>
</li>
<li><p>配置服务器的配置文件</p>
<ul>
<li><p>服务器配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> vim &#x2F;etc&#x2F;openvpn&#x2F;server&#x2F;server.conf</span><br><span class="line"> </span><br><span class="line"> ;local 172.17.0.10</span><br><span class="line"> port 1194</span><br><span class="line"> proto udp</span><br><span class="line"> dev tun</span><br><span class="line"> ca ca.crt</span><br><span class="line"> cert server.crt</span><br><span class="line"> key server.key</span><br><span class="line"> dh dh.pem</span><br><span class="line"> auth SHA512</span><br><span class="line"> tls-crypt tc.key</span><br><span class="line"> topology subnet</span><br><span class="line"> server 10.8.0.0 255.255.255.0</span><br><span class="line"> push &quot;route 0.0.0.0 0.0.0.0&quot;</span><br><span class="line"> ;push &quot;redirect-gateway def1 bypass-dhcp&quot;</span><br><span class="line"> ifconfig-pool-persist ipp.txt</span><br><span class="line"> ;push &quot;dhcp-option DNS 183.60.83.19&quot;</span><br><span class="line"> ;push &quot;dhcp-option DNS 183.60.82.98&quot;</span><br><span class="line"> keepalive 10 120</span><br><span class="line"> cipher AES-256-CBC</span><br><span class="line"> user nobody</span><br><span class="line"> group nobody</span><br><span class="line"> persist-key</span><br><span class="line"> persist-tun</span><br><span class="line"> status openvpn-status.log</span><br><span class="line"> verb 3</span><br><span class="line"> crl-verify crl.pem</span><br><span class="line"> explicit-exit-notify</span><br><span class="line"> </span><br><span class="line"> ## 主要修改内容：</span><br><span class="line"> 1. 增加&#96;push &quot;route 0.0.0.0 0.0.0.0&quot;&#96;</span><br><span class="line"> 2. 注释&#96;push &quot;redirect-gateway def1 bypass-dhcp&quot;&#96;,&#96;push &quot;dhcp-option DNS 183.60.83.19&quot;&#96;和&#96;push &quot;dhcp-option DNS 183.60.82.98&quot;&#96;</span><br><span class="line"> </span><br><span class="line"> ## 注意：windows使用openvpn gui时会造成只能访问局域网，不能访问外网；解决方式如下</span><br><span class="line"> 原配置：</span><br><span class="line"> client</span><br><span class="line"> dev tun</span><br><span class="line"> proto udp</span><br><span class="line"> remote 49.234.201.19 1194</span><br><span class="line"> resolv-retry infinite</span><br><span class="line"> nobind</span><br><span class="line"> persist-key</span><br><span class="line"> persist-tun</span><br><span class="line"> remote-cert-tls server</span><br><span class="line"> auth SHA512</span><br><span class="line"> cipher AES-256-CBC</span><br><span class="line"> ignore-unknown-option block-outside-dns</span><br><span class="line"> block-outside-dns</span><br><span class="line"> verb 3</span><br><span class="line"> 修改内容：</span><br><span class="line"> 删除&#96;block-outside-dns&#96;</span><br><span class="line"> windows配置删除block-outside-dns这一行，就行了</span><br><span class="line">因为这个设置， OpenVPN 会添加 Windows 防火墙记录</span><br><span class="line"> 参考网址：https:&#x2F;&#x2F;www.v2ex.com&#x2F;t&#x2F;521393#reply19</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定客户端ip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">已有配置：ifconfig-pool-persist ipp.txt</span><br><span class="line">修改ipp.txt的文件内容，指定用户的ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 网上查到的方法</span><br><span class="line">1、在server.conf文件中增加客户端配目录，ccd可以任意指定：</span><br><span class="line">	client-config-dir ccd</span><br><span class="line"> </span><br><span class="line">2、进入ccd目录后，用客户名（就是common name）建立文件。</span><br><span class="line">例如：客户名：litifeng  ip：10.8.0.6</span><br><span class="line">则名为litifeng的文件中，写入下面代码：</span><br><span class="line">	ifconfig-push 10.8.0.6 255.255.255.0</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ol>
<ul>
<li><p>重启服务器的openvpn服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart openvpn-server@server.service</span><br><span class="line">systemctl status openvpn-server@server.service</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="客户端安装vpn"><a href="#客户端安装vpn" class="headerlink" title="客户端安装vpn"></a>客户端安装vpn</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum -y install openvpn</span><br><span class="line"></span><br><span class="line">启动vpn,client.ovpn为服务器生成的文件</span><br><span class="line">openvpn --daemon --cd &#x2F;etc&#x2F;openvpn&#x2F;client --config client.ovpn --log-append &#x2F;var&#x2F;log&#x2F;openvpn.log</span><br><span class="line">查看log</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;openvpn.log</span><br></pre></td></tr></table></figure>



<h3 id="初始化docker-swarm"><a href="#初始化docker-swarm" class="headerlink" title="初始化docker swarm"></a>初始化docker swarm</h3><p>跨云部署docker swarm时routingMesh等都无法使用，因为docker swarm需要使用4789的udp端口；而部分云服务商将4789端口自用了，所以在19.03版本之前的docker是无法使用docker swarm服务的</p>
<ol>
<li><p>开放iptables端口，所有节点全部开放</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># docker</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 2376 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 2377 -j ACCEPT</span><br><span class="line">-A INPUT -p udp -m state --state NEW -m udp --dport 4789 -j ACCEPT</span><br><span class="line">-A INPUT -p udp -m state --state NEW -m udp --dport 5789 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 7946 -j ACCEPT</span><br><span class="line">-A INPUT -p udp -m state --state NEW -m udp --dport 7946 -j ACCEPT</span><br><span class="line"># openvpn</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 1194 -j ACCEPT</span><br><span class="line">-A INPUT -p udp -m state --state NEW -m udp --dport 1194 -j ACCEPT</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>初始化docker swarm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker swarm init --advertise-addr 10.8.0.1:2377 --listen-addr 10.8.0.1:2377  --data-path-port 5789</span><br><span class="line"></span><br><span class="line">## 参数说明</span><br><span class="line">--advertise-addr 指定其他节点用来连接到当前管理节点的 IP 和端口。这一属性是可选的，当节点上有多个 IP 时，可以用于指定使用哪个IP。此外，还可以用于指定一个节点上没有的 IP，比如一个负载均衡的 IP。</span><br><span class="line"></span><br><span class="line">--listen-addr 指定用于承载 Swarm 流量的 IP 和端口。其设置通常与 --advertise-addr 相匹配，但是当节点上有多个 IP 的时候，可用于指定具体某个 IP。并且，如果 --advertise-addr 设置了一个远程 IP 地址（如负载均衡的IP地址），该属性也是需要设置的。建议执行命令时总是使用这两个属性来指定具体 IP 和端口。</span><br><span class="line"></span><br><span class="line">--data-path-port</span><br><span class="line">该标志允许您配置用于数据路径通信的UDP端口号。提供的端口号必须在1024-49151范围内。如果未设置此标志或将其设置为0，则使用默认端口号4789。数据路径端口只能在初始化群集时配置，并且适用于加入群集的所有节点。以下示例初始化一个新的Swarm，并将数据路径端口配置为UDP端口5789。</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>加入docker swarm</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 获取加入集群的命令</span><br><span class="line">docker swarm join-token worker      &#x2F;&#x2F;获取工作节点的token</span><br><span class="line">docker swarm join-token manager     &#x2F;&#x2F;获取管理节点的token</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li><p>创建overlay网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network create \</span><br><span class="line">--driver overlay \</span><br><span class="line">--attachable \</span><br><span class="line">server_net</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果创建的ingress网络未指定--attachable参数，则ingress网络只允许服务连接到overlay网络中</span><br><span class="line">&#x2F;&#x2F; 想要连接单一容器到overlay网络，就必须在创建overlay网络时添加--attachable参数，</span><br><span class="line">&#x2F;&#x2F; 并且单一容器并不是暴露所有端口到overlay网络中，需要自己发布</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="5">
<li><p>测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker service create --name web --network server_net --publish 80:80 --replicas 2 httpd</span><br><span class="line"></span><br><span class="line">docker service scale web&#x3D;1</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="安装kong"><a href="#安装kong" class="headerlink" title="安装kong"></a>安装kong</h3><ol>
<li><p>安装postgres</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成随机密码</span><br><span class="line">openssl rand -base64 20 &gt;&gt; postgres_password.txt</span><br><span class="line"></span><br><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  postgres:</span><br><span class="line">    container_name: &quot;postgres&quot;</span><br><span class="line">    image: &quot;postgres:9.6&quot;</span><br><span class="line">    restart: &quot;always&quot;</span><br><span class="line">    environment:</span><br><span class="line">      POSTGRES_USER: kong</span><br><span class="line">      POSTGRES_DB: kong</span><br><span class="line">      POSTGRES_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;postgres_password</span><br><span class="line">    secrets:</span><br><span class="line">      - postgres_password</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;postgres&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5432:5432&quot;</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line">secrets:</span><br><span class="line">  postgres_password:</span><br><span class="line">    file: .&#x2F;postgres_password.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 直接运行</span><br><span class="line">docker run -d --restart always --name postgres \</span><br><span class="line">               --network&#x3D;server_net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e POSTGRES_USER&#x3D;kong \</span><br><span class="line">               -e POSTGRES_DB&#x3D;kong \</span><br><span class="line">               -e POSTGRES_PASSWORD&#x3D;123456 \</span><br><span class="line">               -v &#x2F;data&#x2F;docker&#x2F;postgres&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data \</span><br><span class="line">               postgres:9.6</span><br><span class="line">               </span><br><span class="line">               </span><br><span class="line"># 创建用户</span><br><span class="line">create user harbor with password &#39;123456&#39;;</span><br><span class="line"># 创建数据库</span><br><span class="line">create database harbor owner harbor;</span><br><span class="line"># 将数据库的权限全部赋予某个用户</span><br><span class="line">grant all on database harbor to harbor;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>初始化及更新数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm \</span><br><span class="line">     --network&#x3D;server_net \</span><br><span class="line">     -e &quot;KONG_DATABASE&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">     kong:latest kong migrations bootstrap</span><br><span class="line">     </span><br><span class="line">docker run --rm \</span><br><span class="line">     --network&#x3D;server_net \</span><br><span class="line">     -e &quot;KONG_DATABASE&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">     kong:latest kong migrations up</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>设置数据库主机label</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker node update --label-add kong&#x3D;master [主机名称]</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>创建kong服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  kong:</span><br><span class="line">    image: &quot;kong:latest&quot;</span><br><span class="line">    environment:</span><br><span class="line">      KONG_DATABASE: postgres</span><br><span class="line">      KONG_PG_HOST: postgres</span><br><span class="line">      KONG_PG_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;postgres_password</span><br><span class="line">      KONG_PROXY_ACCESS_LOG: &#x2F;dev&#x2F;stdout</span><br><span class="line">      KONG_ADMIN_ACCESS_LOG: &#x2F;dev&#x2F;stdout</span><br><span class="line">      KONG_PROXY_ERROR_LOG: &#x2F;dev&#x2F;stderr</span><br><span class="line">      KONG_ADMIN_ERROR_LOG: &#x2F;dev&#x2F;stderr</span><br><span class="line">      KONG_ADMIN_LISTEN: &quot;0.0.0.0:8001, 0.0.0.0:8444 ssl&quot;</span><br><span class="line">    secrets:</span><br><span class="line">      - postgres_password</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">      - &quot;8001:8001&quot;</span><br><span class="line">      - &quot;8443:8443&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">  konga:</span><br><span class="line">    image: pantsel&#x2F;konga</span><br><span class="line">    environment:</span><br><span class="line">      DB_ADAPTER: mysql</span><br><span class="line">      DB_HOST: mysql_master</span><br><span class="line">      DB_PORT: 3306</span><br><span class="line">      DB_USER: konga</span><br><span class="line">      DB_PASSWORD: 123456</span><br><span class="line">      DB_DATABASE: konga</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line">secrets:</span><br><span class="line">  postgres_password:</span><br><span class="line">    file: .&#x2F;postgres_password.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 直接运行</span><br><span class="line">docker service create --name kong \</span><br><span class="line">     --network&#x3D;server_net \</span><br><span class="line">     -e &quot;KONG_DATABASE&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST&#x3D;postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_PASSWORD&#x3D;123456&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ACCESS_LOG&#x3D;&#x2F;dev&#x2F;stdout&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ACCESS_LOG&#x3D;&#x2F;dev&#x2F;stdout&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ERROR_LOG&#x3D;&#x2F;dev&#x2F;stderr&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ERROR_LOG&#x3D;&#x2F;dev&#x2F;stderr&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_LISTEN&#x3D;0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     kong:latest</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line"># 创建konga服务和路由</span><br><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;services -X POST -d &#39;name&#x3D;konga&amp;host&#x3D;konga&amp;port&#x3D;1337&#39;</span><br><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:8001&#x2F;services&#x2F;konga&#x2F;routes -X POST -d &#39;hosts[]&#x3D;konga.xupengfei.net&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成随机密码</span><br><span class="line">openssl rand -base64 20 &gt;&gt; mysql_password.txt</span><br><span class="line">openssl rand -base64 20 &gt;&gt; mysql_konga_password.txt</span><br><span class="line"></span><br><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  mysql:</span><br><span class="line">    container_name: &quot;mysql_master&quot;</span><br><span class="line">    image: &quot;mysql:5.7&quot;</span><br><span class="line">    restart: &quot;always&quot;</span><br><span class="line">    environment:</span><br><span class="line">      MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;mysql_password</span><br><span class="line">    secrets:</span><br><span class="line">      - mysql_password</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql&#x2F;conf.d&quot;</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3306:3306&quot;</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line">secrets:</span><br><span class="line">  mysql_password:</span><br><span class="line">    file: .&#x2F;mysql_password.txt</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 创建新用户</span><br><span class="line">create user konga identified by &#39;123456&#39;;</span><br><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE IF NOT EXISTS konga DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line"># 查看用户权限</span><br><span class="line">show grants for &quot;konga&quot;@&quot;%&quot;;</span><br><span class="line"># 取消用户权限</span><br><span class="line">revoke all on *.* from &quot;konga&quot;@&quot;%&quot;;</span><br><span class="line"># 授权</span><br><span class="line">grant all privileges on konga.* to konga@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    container_name: &quot;redis&quot;</span><br><span class="line">    image: &quot;redis&quot;</span><br><span class="line">    restart: &quot;always&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line"></span><br><span class="line">docker run -d -p 6379:6379 --restart always --network server_net --name redis -v &#x2F;data&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data redis</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="7">
<li><p>创建konga管理面板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  konga:</span><br><span class="line">    image: pantsel&#x2F;konga</span><br><span class="line">    environment:</span><br><span class="line">      DB_ADAPTER: mysql</span><br><span class="line">      DB_HOST: mysql_master</span><br><span class="line">      DB_PORT: 3306</span><br><span class="line">      DB_USER: konga</span><br><span class="line">      DB_PASSWORD: 123456</span><br><span class="line">      DB_DATABASE: konga</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line"></span><br><span class="line"># 直接运行</span><br><span class="line">docker service create --network server_net --name konga pantsel&#x2F;konga</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="8">
<li><p>安装gitlab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  konga:</span><br><span class="line">    container_name: &quot;gitlab&quot;</span><br><span class="line">    image: gitlab&#x2F;gitlab-ce</span><br><span class="line">    restart: &quot;always&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab&quot;</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab&quot;</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9922:22&quot;</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 直接运行</span><br><span class="line">docker run -d \</span><br><span class="line"> -p 9980:80 \</span><br><span class="line"> -p 9922:22 \</span><br><span class="line"> -v &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;config:&#x2F;etc&#x2F;gitlab  \</span><br><span class="line"> -v &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;logs:&#x2F;var&#x2F;log&#x2F;gitlab \</span><br><span class="line"> -v &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;data:&#x2F;var&#x2F;opt&#x2F;gitlab \</span><br><span class="line"> --restart always \</span><br><span class="line"> --network server_net \</span><br><span class="line"> --name gitlab \</span><br><span class="line"> gitlab&#x2F;gitlab-ce</span><br><span class="line"> </span><br><span class="line">## 修改配置文件</span><br><span class="line">vim &#x2F;data&#x2F;docker&#x2F;gitlab&#x2F;config&#x2F;gitlab.rb</span><br><span class="line">external_url &#39;http:&#x2F;&#x2F;gitlab.xupengfei.net&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_ssh_host&#39;] &#x3D; &#39;gitlab.xupengfei.net&#39;</span><br><span class="line">gitlab_rails[&#39;gitlab_shell_ssh_port&#39;] &#x3D; 9922</span><br><span class="line">## 重启gitlab</span><br><span class="line">docker restart gitlab</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="9">
<li><p>安装邮件服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 设置服务器主机名</span><br><span class="line">hostnamectl set-hostname mail.xupengfei.net</span><br><span class="line"></span><br><span class="line">docker pull centos:7.4.1708</span><br><span class="line"># 运行新容器并设置主机名,开放端口等</span><br><span class="line">docker run -itd --name ewomail -h mail.xupengfei.net --privileged&#x3D;true \</span><br><span class="line">  -p 25:25 \</span><br><span class="line">  -p 110:110 \</span><br><span class="line">  -p 143:143 \</span><br><span class="line">  -p 465:465 \</span><br><span class="line">  -p 587:587 \</span><br><span class="line">  -p 993:993 \</span><br><span class="line">  -p 995:995  \</span><br><span class="line">  -p 13000:8000 \</span><br><span class="line">  -p 13010:8010 \</span><br><span class="line">  -p 13020:8020 \</span><br><span class="line">  --restart always \</span><br><span class="line">  -v &#x2F;data&#x2F;docker&#x2F;ewomail&#x2F;data:&#x2F;ewomail centos:7.4.1708 init &#x2F;bin&#x2F;bash</span><br><span class="line"># 进入容器</span><br><span class="line">docker exec -it ewomail &#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">yum clean all &amp;&amp; rm -rf &#x2F;var&#x2F;cache&#x2F;yum &amp;&amp; yum update -y &amp;&amp; yum -y install git &amp;&amp; cd &#x2F;root &amp;&amp; git clone https:&#x2F;&#x2F;gitee.com&#x2F;laowu5&#x2F;EwoMail.git &amp;&amp; cd &#x2F;root&#x2F;EwoMail&#x2F;install  &amp;&amp; chmod +x start.sh &amp;&amp; sh start.sh xupengfei.net</span><br><span class="line"> </span><br><span class="line"># 获取DKIM（防止被判定为垃圾邮件）</span><br><span class="line">amavisd -c &#x2F;etc&#x2F;amavisd&#x2F;amavisd.conf showkeys</span><br><span class="line"># 容器打包成镜像</span><br><span class="line">docker commit ewomail ewomail</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="10">
<li><p>安装Jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    container_name: &quot;jenkins&quot;</span><br><span class="line">    image: jenkins</span><br><span class="line">    restart: &quot;always&quot;</span><br><span class="line">    user: root</span><br><span class="line">    privileged: true</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;jenkins&#x2F;data:&#x2F;var&#x2F;jenkins_home&quot;</span><br><span class="line">      - &quot;&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">      - &quot;&#x2F;usr&#x2F;bin&#x2F;docker:&#x2F;usr&#x2F;bin&#x2F;docker&quot;</span><br><span class="line">      - &quot;&#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;58080:8080&quot;</span><br><span class="line">      - &quot;50000:50000&quot;</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="11">
<li><p>安装gogs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用docker-compose</span><br><span class="line">version: &quot;3.3&quot;</span><br><span class="line">services:</span><br><span class="line">  gogs:</span><br><span class="line">    container_name: &quot;gogs&quot;</span><br><span class="line">    image: gogs&#x2F;gogs</span><br><span class="line">    restart: &quot;always&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;data&#x2F;docker&#x2F;gogs&#x2F;data:&#x2F;data&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;10022:22&quot;</span><br><span class="line">      - &quot;10080:3000&quot;</span><br><span class="line">networks:</span><br><span class="line">  default:</span><br><span class="line">    external:</span><br><span class="line">      name: server_net</span><br><span class="line"></span><br><span class="line"># mysql 创建用户</span><br><span class="line"># 创建新用户</span><br><span class="line">create user gogs identified by &#39;123456&#39;;</span><br><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE IF NOT EXISTS gogs DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line"># 查看用户权限</span><br><span class="line">show grants for &quot;gogs&quot;@&quot;%&quot;;</span><br><span class="line"># 取消用户权限</span><br><span class="line">revoke all on *.* from &quot;gogs&quot;@&quot;%&quot;;</span><br><span class="line"># 授权</span><br><span class="line">grant all privileges on gogs.* to gogs@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="12">
<li><p>mysql，postgres添加用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># mysql </span><br><span class="line">    </span><br><span class="line"># 创建新用户--konga</span><br><span class="line">create user konga identified by &#39;123456&#39;;</span><br><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE IF NOT EXISTS konga DEFAULT CHARSET utf8mb4 COLLATE utf8mb4_general_ci;</span><br><span class="line"># 查看用户权限</span><br><span class="line">show grants for &quot;konga&quot;@&quot;%&quot;;</span><br><span class="line"># 取消用户权限</span><br><span class="line">revoke all on *.* from &quot;konga&quot;@&quot;%&quot;;</span><br><span class="line"># 授权</span><br><span class="line">grant all privileges on konga.* to konga@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># 创建新用户--gogs</span><br><span class="line">create user gogs identified by &#39;123456&#39;;</span><br><span class="line"># 创建数据库</span><br><span class="line">CREATE DATABASE IF NOT EXISTS gogs DEFAULT CHARSET utf8 COLLATE utf8_general_ci;</span><br><span class="line"># 查看用户权限</span><br><span class="line">show grants for &quot;gogs&quot;@&quot;%&quot;;</span><br><span class="line"># 取消用户权限</span><br><span class="line">revoke all on *.* from &quot;gogs&quot;@&quot;%&quot;;</span><br><span class="line"># 授权</span><br><span class="line">grant all privileges on gogs.* to gogs@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line">flush privileges;</span><br><span class="line"></span><br><span class="line"># postgres</span><br><span class="line"></span><br><span class="line"># 创建用户--harbor</span><br><span class="line">create user harbor with password &#39;123456&#39;;</span><br><span class="line"># 创建数据库</span><br><span class="line">create database harbor owner harbor;</span><br><span class="line"># 将数据库的权限全部赋予某个用户</span><br><span class="line">grant all on database harbor to harbor;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="13">
<li><p>harbor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用nginx代理harbor</span><br><span class="line"># 1. 代理nginx增加&#96;client_max_body_size 0;&#96;取消限制上传文件的大小</span><br><span class="line"># 2. 修改harbor的nginx配置</span><br><span class="line"># 删除&#x2F;注释掉common&#x2F;config&#x2F;nginx&#x2F;nginx.conf中的proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"></span><br><span class="line"># 登录</span><br><span class="line">docker login hub.xupengfei.net -u xupengfei -p 123456</span><br><span class="line"># 打标签</span><br><span class="line">docker tag jenkins:proxy hub.xupengfei.net&#x2F;library&#x2F;jenkins</span><br><span class="line"># 推送</span><br><span class="line">docker push hub.xupengfei.net&#x2F;library&#x2F;jenkins</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>使用GitHub page创建helm私有仓库</title>
    <url>/2021/08/30/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BD%BF%E7%94%A8GitHub%20page%E5%88%9B%E5%BB%BAhelm%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>在GitHub上创建<code>helm-chart</code>的新仓库</li>
<li>本地拉取<code>helm-chart</code></li>
</ul>
<h2 id="创建示例chart"><a href="#创建示例chart" class="headerlink" title="创建示例chart"></a>创建示例<code>chart</code></h2><ul>
<li>进入<code>helm-chart</code>文件夹<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir helm-chart-sources</span><br><span class="line"></span><br><span class="line">helm create helm-chart-sources&#x2F;helloworld</span><br></pre></td></tr></table></figure>
目录结构为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└─helm-chart-sources</span><br><span class="line">    └─helloworld</span><br><span class="line">        │  .helmignore</span><br><span class="line">        │  Chart.yaml</span><br><span class="line">        │  values.yaml</span><br><span class="line">        │</span><br><span class="line">        ├─charts</span><br><span class="line">        └─templates</span><br><span class="line">            │  deployment.yaml</span><br><span class="line">            │  hpa.yaml</span><br><span class="line">            │  ingress.yaml</span><br><span class="line">            │  NOTES.txt</span><br><span class="line">            │  service.yaml</span><br><span class="line">            │  serviceaccount.yaml</span><br><span class="line">            │  _helpers.tpl</span><br><span class="line">            │  </span><br><span class="line">            └─tests</span><br><span class="line">                    test-connection.yaml</span><br></pre></td></tr></table></figure></li>
<li>检查配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm lint helm-chart-sources&#x2F;helloworld</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="打包发布应用"><a href="#打包发布应用" class="headerlink" title="打包发布应用"></a>打包发布应用</h2><ul>
<li>打包应用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm package helm-chart-sources&#x2F;helloworld</span><br></pre></td></tr></table></figure></li>
<li>添加描述文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo index . --url https:&#x2F;&#x2F;github.xupengfei.net&#x2F;helm-chart&#x2F;</span><br></pre></td></tr></table></figure></li>
<li>提交并推送到仓库中</li>
<li>配置仓库开启Girhub Pages</li>
</ul>
<h2 id="客户端添加repo"><a href="#客户端添加repo" class="headerlink" title="客户端添加repo"></a>客户端添加<code>repo</code></h2><ul>
<li>添加仓库到<code>Helm</code>客户端<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm repo add myrepo https:&#x2F;&#x2F;github.xupengfei.net&#x2F;helm-chart</span><br></pre></td></tr></table></figure></li>
<li>查找应用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm search repo helloworld</span><br></pre></td></tr></table></figure></li>
<li>安装应用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helm install helloworld myrepo&#x2F;helloworld</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>反转二叉树</title>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>操作给定的二叉树，将其变成源二叉树的镜像。【即左右子节点互换】</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的镜像定义：源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">    	镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   &#x2F;  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 &#x2F; \  &#x2F; \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TreeNode&#123;</span><br><span class="line">    var $val;</span><br><span class="line">    var $left &#x3D; NULL;</span><br><span class="line">    var $right &#x3D; NULL;</span><br><span class="line">    function __construct($val)&#123;</span><br><span class="line">        $this-&gt;val &#x3D; $val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a1 &#x3D; new TreeNode(8);</span><br><span class="line">$a2 &#x3D; new TreeNode(6);</span><br><span class="line">$a3 &#x3D; new TreeNode(10);</span><br><span class="line">$a1-&gt;left &#x3D; $a2;</span><br><span class="line">$a1-&gt;right &#x3D; $a3;</span><br><span class="line">$a4 &#x3D; new TreeNode(5);</span><br><span class="line">$a5 &#x3D; new TreeNode(7);</span><br><span class="line">$a2-&gt;left &#x3D; $a4;</span><br><span class="line">$a2-&gt;right &#x3D; $a5;</span><br><span class="line">$a6 &#x3D; new TreeNode(9);</span><br><span class="line">$a7 &#x3D; new TreeNode(11);</span><br><span class="line">$a3-&gt;left &#x3D; $a6;</span><br><span class="line">$a3-&gt;right &#x3D; $a7;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法1：递归循环</span><br><span class="line">function Mirror(&amp;$root)</span><br><span class="line">&#123;</span><br><span class="line">    if(is_null($root))&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    $temp &#x3D; $root-&gt;left;</span><br><span class="line">    $root-&gt;left &#x3D; $root-&gt;right;</span><br><span class="line">    $root-&gt;right &#x3D; $temp;</span><br><span class="line">    if(!is_null($root-&gt;left))&#123;</span><br><span class="line">        Mirror($root-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(!is_null($root-&gt;right))&#123;</span><br><span class="line">        Mirror($root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法2：模拟队列</span><br><span class="line">&#x2F;&#x2F; 思路：通过&#96;array_push&#96;和&#96;array_shift&#96;模拟一个栈；循环处理这个队列直到队列中没有数据</span><br><span class="line">function Mirror(&amp;$root)</span><br><span class="line">&#123;</span><br><span class="line">    $temp &#x3D; array();</span><br><span class="line">    array_push($temp,$root);</span><br><span class="line">    while(!empty($temp))&#123;</span><br><span class="line">        $data &#x3D; array_shift($temp);</span><br><span class="line">        $temp_left &#x3D; $data-&gt;left;</span><br><span class="line">        $data-&gt;left &#x3D; $data-&gt;right;</span><br><span class="line">        $data-&gt;right &#x3D; $temp_left;</span><br><span class="line">        if(!is_null($data-&gt;left))&#123;</span><br><span class="line">            array_push($temp,$data-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        if(!is_null($data-&gt;right))&#123;</span><br><span class="line">            array_push($temp,$data-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP排序算法</title>
    <url>/2020/04/18/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>对一组数据，比较相邻数据的大小，向值较小的数据放在前面，值大的放在后面。（升序排列）</p>
<p>对于一个长度为N的数组，我们需要排序 N-1 轮，每 i 轮 要比较 N-i 次。对此我们可以用双重循环语句，外层循环控制循环轮次，内层循环控制每轮的比较次数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">　function order($arr)&#123;</span><br><span class="line">   　　$count &#x3D; count($arr);</span><br><span class="line">   　　$temp &#x3D; 0; </span><br><span class="line">  　　 &#x2F;&#x2F;外层控制排序轮次</span><br><span class="line">   　　for($i&#x3D;0; $i&lt;$count-1; $i++)&#123;</span><br><span class="line">       　　&#x2F;&#x2F;内层控制每轮比较次数</span><br><span class="line">       　　for($j&#x3D;0; $j&lt; $count-1-$i; $j++)&#123;</span><br><span class="line">             　　if($arr[$j] &gt; $arr[$j+1])&#123;</span><br><span class="line">                 　　$temp        &#x3D; $arr[$j];</span><br><span class="line">                 　　$arr[$j]     &#x3D; $arr[$j+1];</span><br><span class="line">                 　　$arr[$j+1]   &#x3D; $temp;</span><br><span class="line">            　　&#125;</span><br><span class="line">      　　 &#125;</span><br><span class="line">   　　&#125; </span><br><span class="line">　　    return $arr;</span><br><span class="line">    &#125;     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$arr&#x3D; array(6,3,8,2,9,1);</span><br><span class="line">$res &#x3D;  order($arr);</span><br><span class="line">var_dump($res);</span><br></pre></td></tr></table></figure>

<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>在一组数据中，选出最小的一个数与第一个位置交换；然后在剩下的数据中找出最小的数与第二个位置交换，循环到倒数第二个数与最后一个数比较为止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function selectSort($arr) &#123;</span><br><span class="line">	&#x2F;&#x2F;双重循环完成，外层控制轮数，内层控制比较次数</span><br><span class="line">	$len&#x3D;count($arr);</span><br><span class="line">    for($i&#x3D;0; $i&lt;$len-1; $i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;先假设最小的值的位置</span><br><span class="line">        $p &#x3D; $i;</span><br><span class="line">        for($j&#x3D;$i+1; $j&lt;$len; $j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;$arr[$p] 是当前已知的最小值</span><br><span class="line">            if($arr[$p] &gt; $arr[$j]) &#123;</span><br><span class="line">            &#x2F;&#x2F;比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。</span><br><span class="line">                $p &#x3D; $j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。</span><br><span class="line">        if($p !&#x3D; $i) &#123;</span><br><span class="line">            $tmp &#x3D; $arr[$p];</span><br><span class="line">            $arr[$p] &#x3D; $arr[$i];</span><br><span class="line">            $arr[$i] &#x3D; $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;返回最终结果</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>在一组数据中，假设前面的数是已经排好顺序的，现在要把第n个数插入到前面的有序数据中，使得这第n个数也是排好顺序的。将这个数据和前面最后一个数据比较，如果小于最后一个数据则交换位置，如此反复循环，知道全部排好顺序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function insert_sort($arr) &#123;</span><br><span class="line">    &#x2F;&#x2F;获取数组单元个数</span><br><span class="line">    $count &#x3D; count($arr);</span><br><span class="line">    &#x2F;&#x2F;外层循环用于从未排序区域中取出待排序元素</span><br><span class="line">    for ($i&#x3D;1; $i &lt; $count; $i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取当前需要插入已排序区域的元素值</span><br><span class="line">        $temp &#x3D; $arr[$i];</span><br><span class="line">        &#x2F;&#x2F;内层循环用于从已排序区域寻找待排序元素的插入位置</span><br><span class="line">        for ($j&#x3D;$i-1; $j &gt;&#x3D; 0; $j--) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果$arr[$i]比已排序区域的$arr[$j]小，就后移$arr[$j]</span><br><span class="line">            if ($temp &lt; $arr[$j]) &#123;        </span><br><span class="line">                $arr[$j+1] &#x3D; $arr[$j];   </span><br><span class="line">                $arr[$j] &#x3D; $temp;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F;如果$arr[$i]不小于$arr[$j]，则对已排序区无需再排序</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return $arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>选择一个基准元素，通常选择第一个元素或最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归的排序划分的两部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort($arr) &#123;</span><br><span class="line">    &#x2F;&#x2F;先判断是否需要继续进行</span><br><span class="line">    $length &#x3D; count($arr);</span><br><span class="line">    if($length &lt;&#x3D; 1) &#123;</span><br><span class="line">        return $arr;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;选择第一个元素作为基准</span><br><span class="line">    $base_num &#x3D; $arr[0];</span><br><span class="line">    &#x2F;&#x2F;遍历除了标尺外的所有元素，按照大小关系放入两个数组内</span><br><span class="line">    &#x2F;&#x2F;初始化两个数组</span><br><span class="line">    $left_array &#x3D; array();  &#x2F;&#x2F;小于基准的</span><br><span class="line">    $right_array &#x3D; array();  &#x2F;&#x2F;大于基准的</span><br><span class="line">    for($i&#x3D;1; $i&lt;$length; $i++) &#123;</span><br><span class="line">        if($base_num &gt; $arr[$i]) &#123;</span><br><span class="line">            &#x2F;&#x2F;放入左边数组</span><br><span class="line">            $left_array[] &#x3D; $arr[$i];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;放入右边</span><br><span class="line">            $right_array[] &#x3D; $arr[$i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数</span><br><span class="line">    $left_array &#x3D; quick_sort($left_array);</span><br><span class="line">    $right_array &#x3D; quick_sort($right_array);</span><br><span class="line">    &#x2F;&#x2F;合并</span><br><span class="line">    return array_merge($left_array, array($base_num), $right_array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><h3 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h3><p>从数组的第一个元素开始一个一个向下查找，如果有和目标一致的元素，查找成功；如果到最后一个元素仍没有目标元素，则查找失败。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function search($arr,$k)&#123;</span><br><span class="line">　　　　 $n &#x3D; count($arr);</span><br><span class="line">    for($i&#x3D;0; $i&lt;$n; $i++)&#123;</span><br><span class="line">        if($arr[$i]&#x3D;&#x3D;$k)&#123;</span><br><span class="line">        	return $i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ol>
<li>必须采用顺序存储结构。</li>
<li>必须按关键字大小有序排列。</li>
</ol>
<h3 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h3><p>先取数组中间的值<code>floor((low+top)/2)</code>，然后通过与所需查找的数字进行比较，若比中间值大，则将首值替换为中间位置下一个位置，继续第一步的操作；若比中间值小，则将尾值替换为中间位置的上一个位置，继续第一部操作，重复第二部操作直到找出目标数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 非递归</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二分查找算法</span><br><span class="line"> * @param array $arr 待查找区间</span><br><span class="line"> * @param int $number 查找数</span><br><span class="line"> * @return int        返回找到的键</span><br><span class="line"> *&#x2F;</span><br><span class="line">function binary_search($arr, $number) &#123;</span><br><span class="line">    &#x2F;&#x2F; 非数组或者数组为空，直接返回-1</span><br><span class="line">    if (!is_array($arr) || empty($arr)) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 初始变量值</span><br><span class="line">    $len &#x3D; count($arr);</span><br><span class="line">    $lower &#x3D; 0;</span><br><span class="line">    $high &#x3D; $len - 1;</span><br><span class="line">    &#x2F;&#x2F; 最低点比最高点大就退出</span><br><span class="line">    while ($lower &lt;&#x3D; $high) &#123;</span><br><span class="line">        &#x2F;&#x2F; 以中间点作为参照点比较</span><br><span class="line">        $middle &#x3D; intval(($lower + $high) &#x2F; 2);</span><br><span class="line">        if ($arr[$middle] &gt; $number) &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找数比参照点小，舍去右边</span><br><span class="line">            $high &#x3D; $middle - 1;</span><br><span class="line">        &#125; else if ($arr[$middle] &lt; $number) &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找数比参照点大，舍去左边</span><br><span class="line">            $lower &#x3D; $middle + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 查找数与参照点相等，则找到返回</span><br><span class="line">            return $middle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 未找到，返回-1</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 递归</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param array $arr 待查找区间</span><br><span class="line"> * @param int $number 查找数</span><br><span class="line"> * @param int $lower 区间最低点</span><br><span class="line"> * @param int $high 区间最高点</span><br><span class="line"> * @return int</span><br><span class="line"> *&#x2F;</span><br><span class="line">function binary_search_recursion(&amp;$arr, $number, $lower, $high) &#123;</span><br><span class="line">    &#x2F;&#x2F; 以区间的中间点作为参照点比较</span><br><span class="line">    $middle &#x3D; intval(($lower + $high) &#x2F; 2);</span><br><span class="line">    &#x2F;&#x2F; 最低点比最高点大就退出</span><br><span class="line">    if ($lower &gt; $high) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if ($number &gt; $arr[$middle]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查找数比参照点大，舍去左边继续查找</span><br><span class="line">        return binary_search_recursion($arr, $number, $middle + 1, $high);</span><br><span class="line">    &#125; elseif ($number &lt; $arr[$middle]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 查找数比参照点小，舍去右边继续查找</span><br><span class="line">        return binary_search_recursion($arr, $number, $lower, $middle - 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return $middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历文件夹下的所有文件和子文件夹"><a href="#遍历文件夹下的所有文件和子文件夹" class="headerlink" title="遍历文件夹下的所有文件和子文件夹"></a>遍历文件夹下的所有文件和子文件夹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function my_scandir($dir)&#123;</span><br><span class="line">    $files &#x3D; array();</span><br><span class="line">    if($handle &#x3D; opendir($dir)) &#123;</span><br><span class="line">        while (($file &#x3D; readdir($handle))!&#x3D;&#x3D; false) &#123;</span><br><span class="line">            if($file !&#x3D; &#39;..&#39; &amp;&amp; $file !&#x3D; &#39;.&#39;) &#123;</span><br><span class="line">                if(is_dir($dir.&quot;&#x2F;&quot;.$file))&#123;</span><br><span class="line">                    $files[$file]&#x3D;my_scandir($dir.&quot;&#x2F;&quot;.$file);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    $files[] &#x3D; $file;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        closedir($handle);</span><br><span class="line">        return $files;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>yii2 advanced单域名统一入口处理</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/yii2/advanced%E7%BB%9F%E4%B8%80%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 增加如下配置</span><br><span class="line"></span><br><span class="line">index index.html index.htm index.php;</span><br><span class="line">      location &#x2F; &#123;</span><br><span class="line">          try_files $uri $uri&#x2F; &#x2F;index.php?$args;</span><br><span class="line">      &#125;</span><br><span class="line">      location &#x2F;backend &#123;</span><br><span class="line">          try_files $uri $uri&#x2F; &#x2F;backend&#x2F;index.php$is_args$args;</span><br><span class="line">      &#125;</span><br><span class="line">      location &#x2F;frontend &#123;</span><br><span class="line">          try_files $uri $uri&#x2F; &#x2F;frontend&#x2F;index.php$is_args$args;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<h3 id="yii2配置"><a href="#yii2配置" class="headerlink" title="yii2配置"></a>yii2配置</h3><ul>
<li>在根目录下新建web目录，并且nginx指向该目录；</li>
<li>配置yii2 environments项目初始化目录<ol>
<li>在dev和prod文件夹下增加web目录</li>
<li>将backend和frontend文件夹下的web下所有的文件赋值到dev下web下的backend和frontend文件夹中</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>知识整理</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF和XSS</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/CSRF%E5%92%8CXSS/</url>
    <content><![CDATA[<h2 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h2><p>XSS（Cross Site Scripting）攻击的全称是跨站脚本攻击，跨站脚本攻击的方式是恶意攻击者在网页中嵌入恶意脚本程序，当用户打开网页的时候脚本程序便在客户端执行，盗取客户的cookie及用户名和密码，下载执行病毒及木马程序，甚至获得客户端的admin权限等。</p>
<p>使用过滤函数，禁用cookie</p>
<h2 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h2><p><code>CSRF</code>(跨站请求伪造)是一种恶意的攻击，它凭借已通过身份验证的用户身份来运行未经过授权的命令</p>
<p>使用token验证，禁用cookie，校验Referer参数</p>
<p>常用的过滤函数：</p>
<ul>
<li><p><code>htmlspecialchars</code>把预定义的字符转换为 HTML 实体</p>
<p>预定义字符为：</p>
<ul>
<li><p>&amp; （和号）成为 &amp;</p>
</li>
<li><p>“ （双引号）成为 “</p>
</li>
<li><p>‘ （单引号）成为 ‘</p>
</li>
<li><p>&lt; （小于）成为 &lt;</p>
</li>
<li><p>&gt; （大于）成为 &gt;</p>
</li>
</ul>
<p>注意：在使用<code>htmlspecialchars</code>函数时默认第二个参数为：<code>ENT_COMPAT</code>只编码双引号，使用该函数的时候更多的加上第二个参数，对单引号也编码：<code>htmlspecialchars($string,ENT_QUOTES)</code></p>
<ul>
<li>ENT_COMPAT - 默认。仅编码双引号。</li>
<li>ENT_QUOTES - 编码双引号和单引号。</li>
<li>ENT_NOQUOTES - 不编码任何引号。</li>
</ul>
</li>
<li><p><code>htmlentities</code>把字符转换成html实体</p>
</li>
<li><p><code>stripslashes</code>删除反斜杠</p>
</li>
<li><p><code>strip_tags</code>去除字符串中的html标签</p>
</li>
</ul>
<p>防范方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A.PHP直接输出html的，可以采用以下的方法进行过滤：</span><br><span class="line"></span><br><span class="line">    1.htmlspecialchars函数</span><br><span class="line">    2.htmlentities函数</span><br><span class="line">    3.HTMLPurifier.auto.php插件</span><br><span class="line">    4.RemoveXss函数</span><br><span class="line"></span><br><span class="line">B.PHP输出到JS代码中，或者开发Json API的，则需要前端在JS中进行过滤：</span><br><span class="line"></span><br><span class="line">    1.尽量使用innerText(IE)和textContent(Firefox),也就是jQuery的text()来输出文本内容</span><br><span class="line">    2.必须要用innerHTML等等函数，则需要做类似php的htmlspecialchars的过滤</span><br><span class="line"></span><br><span class="line">C.其它的通用的补充性防御手段</span><br><span class="line"></span><br><span class="line">    1.在输出html时，加上Content Security Policy的Http Header</span><br><span class="line">    （作用：可以防止页面被XSS攻击时，嵌入第三方的脚本文件等）</span><br><span class="line">    （缺陷：IE或低版本的浏览器可能不支持）</span><br><span class="line">    2.在设置Cookie时，加上HttpOnly参数</span><br><span class="line">    （作用：可以防止页面被XSS攻击时，Cookie信息被盗取，可兼容至IE6）</span><br><span class="line">    （缺陷：网站本身的JS代码也无法操作Cookie，而且作用有限，只能保证Cookie的安全）</span><br><span class="line">    3.在开发API时，检验请求的Referer参数</span><br><span class="line">    （作用：可以在一定程度上防止CSRF攻击）</span><br><span class="line">    （缺陷：IE或低版本的浏览器中，Referer参数可以被伪造）</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>yii2 assets资源包</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/yii2/assets/</url>
    <content><![CDATA[<h3 id="Assets发布后，其资源如图片的加载引用"><a href="#Assets发布后，其资源如图片的加载引用" class="headerlink" title="Assets发布后，其资源如图片的加载引用"></a>Assets发布后，其资源如图片的加载引用</h3><p><a href="http://www.yiichina.com/doc/guide/2.0/structure-assets#using-asset-bundles" target="_blank" rel="noopener">http://www.yiichina.com/doc/guide/2.0/structure-assets#using-asset-bundles</a><br>Info：yii\web\AssetBundle::register() 方法返回资源包对象，该对象包含了发布资源的信息比如 basePath 或 baseUrl。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use app\assets\AppAsset;</span><br><span class="line">$asset &#x3D; AppAsset::register($this); &#x2F;&#x2F; $this 代表视图对象</span><br><span class="line">var_dump($asset-&gt;baseurl); &#x2F;&#x2F;获取资源发布地址！！！</span><br><span class="line">?&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;&lt;?&#x3D; $asset-&gt;baseurl ?&gt;&#x2F;img&#x2F;1.jpg&quot;&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>知识整理</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql相关知识</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/mysql/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="SQL的select语句完整的执行顺序"><a href="#SQL的select语句完整的执行顺序" class="headerlink" title="SQL的select语句完整的执行顺序"></a>SQL的select语句完整的执行顺序</h3><ol>
<li>from 子句组装来自不同数据源的数据,所以为表创建别名，别的地方可以用；</li>
<li>where 子句基于指定的条件对记录行进行筛选；</li>
<li>group by 子句将数据划分为多个分组；</li>
<li>使用聚集函数进行计算；    一定要知道他的执行顺序在group by后having之前</li>
<li>使用 having 子句筛选分组；</li>
<li>计算所有的表达式；</li>
<li>select 的字段；</li>
<li>使用 order by 对结果集进行排序</li>
</ol>
<h3 id="SQL的连接查询（左连接和右链接的区别）"><a href="#SQL的连接查询（左连接和右链接的区别）" class="headerlink" title="SQL的连接查询（左连接和右链接的区别）"></a>SQL的连接查询（左连接和右链接的区别）</h3><p>外连接：<br>    左连接（左外连接）：以左表作为基准进行查询，左表数据会全部显示出来，右表如果和左表匹配的数据则显示相应字段的数据，如果不匹配则显示为 null。<br>    右连接（右外连接）：以右表作为基准进行查询，右表数据会全部显示出来，左表如果和右表匹配的数据则显示相应字段的数据，如果不匹配则显示为 null。<br>    全连接：先以左表进行左外连接，再以右表进行右外连接。<br>内连接：<br>    显示表之间有连接匹配的所有行。</p>
<h3 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h3><ol>
<li><p>当只要一行数据时使用 limit 1查询时如果已知会得到一条数据，这种情况下加上 limit 1 会增加性能。因为 mysql 数据库引擎会在找到一条结果停止搜索，而不是继续查询下一条是否符合标准直到所有记录查询完毕</p>
</li>
<li><p>选择正确的数据库引擎Mysql 中有两个引擎 MyISAM 和 InnoDB，每个引擎有利有弊。<br>MyISAM 适用于一些大量查询的应用，但对于有大量写功能的应用不是很好。甚至你只需要update 一个字段整个表都会被锁起来。而别的进程就算是读操作也不行要等到当前 update 操作完成之后才能继续进行。另外，MyISAM 对于 select count(*)这类操作是超级快的。InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用会比 MyISAM 还慢，但是支持“行锁”，所以在写操作比较多的时候会比较优秀。并且，它支持很多的高级应用，例如：事物。</p>
</li>
<li><p>用 not exists 代替 not in/not exists 用到了连接能够发挥已经建立好的索引的作用，not in 不能使用索引。Not in 是最慢的方式要同每条记录比较，在数据量比较大的操作红不建议使用这种方式。</p>
</li>
<li><p>对操作符的优化，尽量不采用不利于索引的操作符。如：in /not in /is null /is not null /&lt;&gt; 等<br>某个字段总要拿来搜索，为其建立索引：Mysql 中可以利用 alter table 语句来为表中的字段添加索引，<br>语法为：<br> alter table 表名 add index (字段名)；</p>
</li>
<li><p>分库分表，主从配置。</p>
</li>
<li><p>对于多张大数据量（这里几百条就算大了）的表 JOIN，要先分页再 JOIN，否则逻辑读会很高，性能很差。</p>
</li>
<li><p>存储过程执行比一条一条地执行其中的各条语句快</p>
</li>
<li><p>决不要检索比需求还要多的数据</p>
</li>
<li><p>导入数据前应该关闭自动提交，最好删除索引然后导入完成后新建</p>
</li>
<li><p>索引改善数据检索的性能，但是损害了数据插入删除更新的性能</p>
</li>
<li><p>like很慢，一般来说最好使用fulltext而不是like</p>
</li>
<li><p>如果从一个表中删除大量数据，应该使用optimize table回收所用的空间，从而优化表性能</p>
</li>
<li><p>char比varchar效率高很多，因此确定字符长度字段最好使用char字段</p>
</li>
<li><p>随机获取数据时， 避免使用order by rand() limit, 效率会很慢， 建议使用join</p>
</li>
</ol>
<h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><p>InnoDB 存储引擎<br>    InnoDB 是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB 是默认的 MySQL引擎。<br>MyISAM 存储引擎<br>    MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM 拥有较高的插入、查询速度，但不支持事物。</p>
<p>InnoDB支持事务和外键，有独立的缓冲池，支持表锁，不存储表的总行数，比MyISAM插入效率高</p>
<h3 id="事务的特征"><a href="#事务的特征" class="headerlink" title="事务的特征"></a>事务的特征</h3><p>只要满足一下四个特征的就属于事务，事务的四大特性ACID(原子性、一致性、隔离性、持久性)<br>（1）、原子性：<br>        事务中整个操作要么全部完成，要么全部不完成。<br>（2）、一致性：<br>        在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>（3）、隔离性：<br>        事务间的操作互不干扰。<br>（4）、持久性：<br>        事务一旦完成，就永久保存。<br> mysql中关于事务的语句：<br>        start trunsaction –开启事务<br>        savepoint 保留点    –创建保留点(即：还原点)<br>        rollback to 保留点  –回滚<br>        commit    –提交<br> 补充：<br>        set autocommit=0 –设置mysql不自动提交更改<br>        release 保留点 释放保留点</p>
<h3 id="where查询为空数据"><a href="#where查询为空数据" class="headerlink" title="where查询为空数据"></a>where查询为空数据</h3><p>不能使用==，应该书写成以下方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tablename where field is null</span><br></pre></td></tr></table></figure>

<h3 id="char等字符串类型占用"><a href="#char等字符串类型占用" class="headerlink" title="char等字符串类型占用"></a>char等字符串类型占用</h3><p>char类型支持的最大字节数是255，</p>
<p>text约为64kb,</p>
<p>MEDIUMTEXT约为16M,</p>
<p>LONGTEXT约为4G</p>
<h3 id="MySQL数据类型的选择和优化案例"><a href="#MySQL数据类型的选择和优化案例" class="headerlink" title="MySQL数据类型的选择和优化案例"></a>MySQL数据类型的选择和优化案例</h3><p>1、手机号存储<br>使用BIGINT代替CHAR或者VARCHAR存放手机号码。<br>这是因为CHAR或者VARCHAR，占用空间大，影响查询性能。<br>例如：11位手机号CHAR存储，utf8编码，则占用33个字节；<br>使用如果使用INT的话，INT最大只能保存10为数据，而手机号为11位，会出现溢出，所以使用BIGINT占用8个字节，支持11为数据存储。<br>2、IP地址可以使用INT存储<br>MySQL里提供了一个很好的函数：INET_ATON(),他负责把IP地址转化为数字，而另一个函数    INET_NTOA（）负责将数字转化为IP地址，示例如下：注意：INT使用无符号，这是因为INT有符号最大为2147483647而无符号 最大为4294967295，如果使用有符号的话，会出现溢出，使用无符号则不会溢出。<br>3、对于非负整数优先使用无符号整形存储<br>4、避免使用enum类型，用TINYINT替代<br>    修改值必须使用alter、排序的效率比较低、禁止使用数字作为enum枚举值<br>5、使用timestamp（4字节）/datetime（8字节）存储日期时间<br>    timestamp日期范围：1970-1-1 00:00:01—-2038-01-10 03:14:07<br>    timestamp以int存储，但可读性高<br>6、尽可能把所有列定义为not null<br>    索引null列会占用更多的空间<br>    进行比较时需要作额外的处理</p>
<h3 id="如何查看索引是否有效"><a href="#如何查看索引是否有效" class="headerlink" title="如何查看索引是否有效"></a>如何查看索引是否有效</h3><p>在查询语句前加explain关键字，查看type类型是否为all,是则没有用到索引，否则使用了索引</p>
<h3 id="group-by-使用规则"><a href="#group-by-使用规则" class="headerlink" title="group by 使用规则"></a>group by 使用规则</h3><ul>
<li>group by子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制</li>
<li>如果在group by子句中嵌套了分组，数据将在最后规定的分组上进行汇总。话句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）</li>
<li>group by子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在SELECT中使用表达式，则必须在group by子句中指定相同的表达式。不能使用别名。</li>
<li>除聚集计算语句外，SELECT语句中的每个列都必须在group by子句中给出。</li>
<li>如果分组列中具有null值，则null将作为一个分组返回。如果列中有多行null值，它们将分为一组。</li>
<li>group by子句必须出现在where子句之后，order by 子句之前</li>
</ul>
<h3 id="MySql查询优化"><a href="#MySql查询优化" class="headerlink" title="MySql查询优化"></a>MySql查询优化</h3><ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>
<li>应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num=10 or num=20可以这样查询：select id from t where num=10 union all select id from t where num=20</li>
<li>in和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3</li>
<li>下面的查询也将导致全表扫描：select id from t where name like ‘李%’若要提高效率，可以考虑全文检索。</li>
<li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：select id from t where num=@num可以改为强制查询使用索引：select id from t with(index(索引名)) where num=@num</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where num/2=100应改为:select id from t where num=100*2</li>
<li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’ ，name以abc开头的id<br>应改为:<br>select id from t where name like ‘abc%’</li>
<li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>
<li>在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</li>
<li>不要写一些没有意义的查询，如需要生成一个空表结构：select col1,col2 into #t from t where 1=0<br>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>create table #t(…)</li>
<li>很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)<br>用下面的语句替换：<br>select num from a where exists(select 1 from b where num=a.num)</li>
<li>并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</li>
<li>索引并不是越多越好，索引固然可 以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</li>
<li>应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</li>
<li>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</li>
<li>尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</li>
<li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</li>
<li>尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</li>
<li>避免频繁创建和删除临时表，以减少系统表资源的消耗。</li>
<li>临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。</li>
<li>在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</li>
<li>如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</li>
<li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</li>
<li>使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</li>
<li>与临时表一样，游标并不是不可使 用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</li>
<li>在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送DONE_IN_PROC 消息。</li>
<li>尽量避免大事务操作，提高系统并发能力。</li>
<li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#SELECT b.* FROM auth_item a INNER JOIN auth_item_child c ON a.id &#x3D; c.parent INNER JOIN auth_item b ON c.child!&#x3D;b.id WHERE a.id &#x3D; 3 AND b.id!&#x3D;3 ORDER BY b.type ASC,b.id ASC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#SELECT c.* FROM auth_item AS a INNER JOIN auth_item AS b ON a.type&#x3D;b.type INNER JOIN auth_item AS c ON a.id&#x3D;c.id OR b.id&#x3D;c.id WHERE a.created_at&#x3D;1590029454 AND b.created_at&#x3D;1590028569;</span><br></pre></td></tr></table></figure>

<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>注意：要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。</p>
<p>我们可以使用命令设置MySQL为非autocommit模式：</p>
<p>set autocommit=0;</p>
<p>设置完autocommit后，我们就可以执行我们的正常业务了。具体如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>转载：</p>
<ol>
<li><a href="https://segmentfault.com/a/1190000018371218" target="_blank" rel="noopener">https://segmentfault.com/a/1190000018371218</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/123984044" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/123984044</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>php的数组相关函数</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/array%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><ul>
<li><code>array_column()</code>返回数组中某一个单列的值</li>
<li><code>array_keys()</code>返回数组中所有的键名</li>
<li><code>array_merge()</code>把一个或多个数组合并成一个数组</li>
<li><code>array_pop()</code>删除数组的最后一个元素（出栈）</li>
<li><code>array_push()</code>把一个或多个元素插入数组的末尾（入栈）</li>
<li><code>array_rand()</code>返回数组中一个或多个随机的键</li>
<li><code>array_search()</code>搜索数组中给定的值并返回键名</li>
<li><code>array_shift()</code>删除数组首个元素并返回被删除元素的值</li>
<li><code>array_unshift()</code>在数组头部添加一个或多个元素</li>
<li><code>array_sum()</code>返回数组中值的和</li>
<li><code>array_unique()</code>删除数组中重复的值</li>
<li><code>array_values()</code>返回数组中所有的值</li>
<li><code>arsort()</code>按照 键值 对关联数组进行降序排序</li>
<li><code>asort()</code>按照 键值 对关联数组进行升序排序</li>
<li><code>count()</code>返回数组中元素的数量</li>
<li><code>in_array()</code>检查数组中是否存在指定的值</li>
<li><code>krsort()</code>对数组按照键名逆向排序</li>
<li><code>ksort()</code>对数组按照键名排序</li>
<li><code>list()</code>把数组中的值赋给一些变量</li>
<li><code>sort()</code>对数组排序</li>
<li><code>rsort()</code>对数组逆向排序</li>
<li><code>shuffle()</code>将数组打乱</li>
</ul>
<h2 id="详细列表"><a href="#详细列表" class="headerlink" title="详细列表"></a>详细列表</h2><table>
<thead>
<tr>
<th><a href="https://www.w3school.com.cn/php/func_array.asp" target="_blank" rel="noopener">array()</a></th>
<th>创建数组。</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.w3school.com.cn/php/func_array_change_key_case.asp" target="_blank" rel="noopener">array_change_key_case()</a></td>
<td>把数组中所有键更改为小写或大写。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_chunk.asp" target="_blank" rel="noopener">array_chunk()</a></td>
<td>把一个数组分割为新的数组块。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_column.asp" target="_blank" rel="noopener">array_column()</a></td>
<td>返回输入数组中某个单一列的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_combine.asp" target="_blank" rel="noopener">array_combine()</a></td>
<td>通过合并两个数组来创建一个新数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_count_values.asp" target="_blank" rel="noopener">array_count_values()</a></td>
<td>用于统计数组中所有值出现的次数。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_diff.asp" target="_blank" rel="noopener">array_diff()</a></td>
<td>比较数组，返回差集（只比较键值）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_diff_assoc.asp" target="_blank" rel="noopener">array_diff_assoc()</a></td>
<td>比较数组，返回差集（比较键名和键值）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_diff_key.asp" target="_blank" rel="noopener">array_diff_key()</a></td>
<td>比较数组，返回差集（只比较键名）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_diff_uassoc.asp" target="_blank" rel="noopener">array_diff_uassoc()</a></td>
<td>比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_diff_ukey.asp" target="_blank" rel="noopener">array_diff_ukey()</a></td>
<td>比较数组，返回差集（只比较键名，使用用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_fill.asp" target="_blank" rel="noopener">array_fill()</a></td>
<td>用给定的键值填充数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_fill_keys.asp" target="_blank" rel="noopener">array_fill_keys()</a></td>
<td>用指定键名的给定键值填充数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_filter.asp" target="_blank" rel="noopener">array_filter()</a></td>
<td>用回调函数过滤数组中的元素。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_flip.asp" target="_blank" rel="noopener">array_flip()</a></td>
<td>交换数组中的键和值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_intersect.asp" target="_blank" rel="noopener">array_intersect()</a></td>
<td>比较数组，返回交集（只比较键值）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_intersect_assoc.asp" target="_blank" rel="noopener">array_intersect_assoc()</a></td>
<td>比较数组，返回交集（比较键名和键值）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_intersect_key.asp" target="_blank" rel="noopener">array_intersect_key()</a></td>
<td>比较数组，返回交集（只比较键名）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_intersect_uassoc.asp" target="_blank" rel="noopener">array_intersect_uassoc()</a></td>
<td>比较数组，返回交集（比较键名和键值，使用用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_intersect_ukey.asp" target="_blank" rel="noopener">array_intersect_ukey()</a></td>
<td>比较数组，返回交集（只比较键名，使用用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_key_exists.asp" target="_blank" rel="noopener">array_key_exists()</a></td>
<td>检查指定的键名是否存在于数组中。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_keys.asp" target="_blank" rel="noopener">array_keys()</a></td>
<td>返回数组中所有的键名。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_map.asp" target="_blank" rel="noopener">array_map()</a></td>
<td>把数组中的每个值发送到用户自定义函数，返回新的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_merge.asp" target="_blank" rel="noopener">array_merge()</a></td>
<td>把一个或多个数组合并为一个数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_merge_recursive.asp" target="_blank" rel="noopener">array_merge_recursive()</a></td>
<td>递归地合并一个或多个数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_multisort.asp" target="_blank" rel="noopener">array_multisort()</a></td>
<td>对多个数组或多维数组进行排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_pad.asp" target="_blank" rel="noopener">array_pad()</a></td>
<td>用值将数组填补到指定长度。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_pop.asp" target="_blank" rel="noopener">array_pop()</a></td>
<td>删除数组的最后一个元素（出栈）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_product.asp" target="_blank" rel="noopener">array_product()</a></td>
<td>计算数组中所有值的乘积。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_push.asp" target="_blank" rel="noopener">array_push()</a></td>
<td>将一个或多个元素插入数组的末尾（入栈）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_rand.asp" target="_blank" rel="noopener">array_rand()</a></td>
<td>返回数组中一个或多个随机的键。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_reduce.asp" target="_blank" rel="noopener">array_reduce()</a></td>
<td>通过使用用户自定义函数，以字符串返回数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_replace.asp" target="_blank" rel="noopener">array_replace()</a></td>
<td>使用后面数组的值替换第一个数组的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_replace_recursive.asp" target="_blank" rel="noopener">array_replace_recursive()</a></td>
<td>递归地使用后面数组的值替换第一个数组的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_reverse.asp" target="_blank" rel="noopener">array_reverse()</a></td>
<td>以相反的顺序返回数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_search.asp" target="_blank" rel="noopener">array_search()</a></td>
<td>搜索数组中给定的值并返回键名。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_shift.asp" target="_blank" rel="noopener">array_shift()</a></td>
<td>删除数组中首个元素，并返回被删除元素的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_slice.asp" target="_blank" rel="noopener">array_slice()</a></td>
<td>返回数组中被选定的部分。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_splice.asp" target="_blank" rel="noopener">array_splice()</a></td>
<td>删除并替换数组中指定的元素。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_sum.asp" target="_blank" rel="noopener">array_sum()</a></td>
<td>返回数组中值的和。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_udiff.asp" target="_blank" rel="noopener">array_udiff()</a></td>
<td>比较数组，返回差集（只比较值，使用一个用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_udiff_assoc.asp" target="_blank" rel="noopener">array_udiff_assoc()</a></td>
<td>比较数组，返回差集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_udiff_uassoc.asp" target="_blank" rel="noopener">array_udiff_uassoc()</a></td>
<td>比较数组，返回差集（比较键和值，使用两个用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_uintersect.asp" target="_blank" rel="noopener">array_uintersect()</a></td>
<td>比较数组，返回交集（只比较值，使用一个用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_uintersect_assoc.asp" target="_blank" rel="noopener">array_uintersect_assoc()</a></td>
<td>比较数组，返回交集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_uintersect_uassoc.asp" target="_blank" rel="noopener">array_uintersect_uassoc()</a></td>
<td>比较数组，返回交集（比较键和值，使用两个用户自定义的键名比较函数）。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_unique.asp" target="_blank" rel="noopener">array_unique()</a></td>
<td>删除数组中的重复值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_unshift.asp" target="_blank" rel="noopener">array_unshift()</a></td>
<td>在数组开头插入一个或多个元素。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_values.asp" target="_blank" rel="noopener">array_values()</a></td>
<td>返回数组中所有的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_walk.asp" target="_blank" rel="noopener">array_walk()</a></td>
<td>对数组中的每个成员应用用户函数。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_walk_recursive.asp" target="_blank" rel="noopener">array_walk_recursive()</a></td>
<td>对数组中的每个成员递归地应用用户函数。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_arsort.asp" target="_blank" rel="noopener">arsort()</a></td>
<td>对关联数组按照键值进行降序排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_asort.asp" target="_blank" rel="noopener">asort()</a></td>
<td>对关联数组按照键值进行升序排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_compact.asp" target="_blank" rel="noopener">compact()</a></td>
<td>创建包含变量名和它们的值的数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_count.asp" target="_blank" rel="noopener">count()</a></td>
<td>返回数组中元素的数目。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_current.asp" target="_blank" rel="noopener">current()</a></td>
<td>返回数组中的当前元素。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_each.asp" target="_blank" rel="noopener">each()</a></td>
<td>返回数组中当前的键／值对。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_end.asp" target="_blank" rel="noopener">end()</a></td>
<td>将数组的内部指针指向最后一个元素。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_extract.asp" target="_blank" rel="noopener">extract()</a></td>
<td>从数组中将变量导入到当前的符号表。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_in_array.asp" target="_blank" rel="noopener">in_array()</a></td>
<td>检查数组中是否存在指定的值。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_key.asp" target="_blank" rel="noopener">key()</a></td>
<td>从关联数组中取得键名。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_krsort.asp" target="_blank" rel="noopener">krsort()</a></td>
<td>对数组按照键名逆向排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_ksort.asp" target="_blank" rel="noopener">ksort()</a></td>
<td>对数组按照键名排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_list.asp" target="_blank" rel="noopener">list()</a></td>
<td>把数组中的值赋给一些变量。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_natcasesort.asp" target="_blank" rel="noopener">natcasesort()</a></td>
<td>用“自然排序”算法对数组进行不区分大小写字母的排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_natsort.asp" target="_blank" rel="noopener">natsort()</a></td>
<td>用“自然排序”算法对数组排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_next.asp" target="_blank" rel="noopener">next()</a></td>
<td>将数组中的内部指针向前移动一位。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_pos.asp" target="_blank" rel="noopener">pos()</a></td>
<td>current() 的别名。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_prev.asp" target="_blank" rel="noopener">prev()</a></td>
<td>将数组的内部指针倒回一位。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_range.asp" target="_blank" rel="noopener">range()</a></td>
<td>创建包含指定范围单元的数组。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_reset.asp" target="_blank" rel="noopener">reset()</a></td>
<td>将数组的内部指针指向第一个元素。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_rsort.asp" target="_blank" rel="noopener">rsort()</a></td>
<td>对数组逆向排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_shuffle.asp" target="_blank" rel="noopener">shuffle()</a></td>
<td>将数组打乱。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_sizeof.asp" target="_blank" rel="noopener">sizeof()</a></td>
<td>count() 的别名。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_sort.asp" target="_blank" rel="noopener">sort()</a></td>
<td>对数组排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_uasort.asp" target="_blank" rel="noopener">uasort()</a></td>
<td>使用用户自定义的比较函数对数组中的键值进行排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_uksort.asp" target="_blank" rel="noopener">uksort()</a></td>
<td>使用用户自定义的比较函数对数组中的键名进行排序。</td>
</tr>
<tr>
<td><a href="https://www.w3school.com.cn/php/func_array_usort.asp" target="_blank" rel="noopener">usort()</a></td>
<td>使用用户自定义的比较函数对数组进行排序。</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>PHP变量</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="变量规则"><a href="#变量规则" class="headerlink" title="变量规则"></a>变量规则</h2><ol>
<li>变量以<code>$</code>符号开始，后面跟着变量的名称</li>
<li>变量名必须以字母或下划线字符开始</li>
<li>变量名只能包含字母，数字和下划线（A-z、0-9和_）</li>
<li>变量名不能包含空格</li>
<li>变量名区分大小写（<code>$y</code>和<code>$Y</code>是两个不同的变量）</li>
</ol>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>php</code>有四种不同的变量作用域：</p>
<ul>
<li>local：局部变量</li>
<li>global：全局变量</li>
<li>static：静态变量</li>
<li>parameter：参数</li>
</ul>
<h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>在 <code>PHP</code> 函数内部声明的变量是局部变量，仅能在函数内部访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">	$x &#x3D; &quot;Hello World&quot;;</span><br><span class="line">	echo $x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在所有函数外部定义的变量，拥有全局作用域。</p>
<p>除了函数外，全局变量可以被脚本中的任何部分访问；</p>
<p>要在一个函数中访问一个全局变量，需要使用 <code>global</code> 关键字。</p>
<p><code>PHP</code> 将所有全局变量存储在一个名为 <code>$GLOBALS[index]</code>的数组中。 <code>index</code> 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$x &#x3D; 5; &#x2F;&#x2F; 全局变量</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">	global $x;</span><br><span class="line">	echo $x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">function test2()&#123;</span><br><span class="line">	echo $GLOBALS[&#39;x&#39;]</span><br><span class="line">&#125;</span><br><span class="line">test2();</span><br></pre></td></tr></table></figure>

<h3 id="static作用域"><a href="#static作用域" class="headerlink" title="static作用域"></a>static作用域</h3><p>当一个函数完成时，它的所有变量通常都会被删除。然而，有时候您希望某个局部变量不要被删除。</p>
<p>要做到这一点，请在您第一次声明变量时使用 <strong>static</strong> 关键字</p>
<p>然后，每次调用该函数时，该变量将会保留着函数前一次被调用时的值。</p>
<p><strong>注释：</strong>该变量仍然是函数的局部变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function test()&#123;</span><br><span class="line">	static $x &#x3D; 0;</span><br><span class="line">	echo $x;</span><br><span class="line">	$x++;</span><br><span class="line">	echo &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line">test();</span><br><span class="line">test();</span><br></pre></td></tr></table></figure>

<h3 id="参数作用域"><a href="#参数作用域" class="headerlink" title="参数作用域"></a>参数作用域</h3><p>参数是通过调用代码将值传递给函数的局部变量。</p>
<p>参数是在参数列表中声明的，作为函数声明的一部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">function test($x)&#123;</span><br><span class="line">	echo $x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(10);</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>PHP-FPM优化</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/php-fpm%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="etc-php-ini"><a href="#etc-php-ini" class="headerlink" title="/etc/php.ini"></a>/etc/php.ini</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#;;;;;;;;;;;;;;;;;</span><br><span class="line"># Error logging ;</span><br><span class="line">#;;;;;;;;;;;;;;;;;</span><br><span class="line">expose_php &#x3D; Off # 关闭php版本信息</span><br><span class="line">display_error &#x3D; Off # 屏幕不显示错误日志</span><br><span class="line">error_reporting &#x3D; E_WARNING &amp; E_ERROR # 记录php错误日志至后台</span><br><span class="line">log_errors &#x3D; On # 开启日志</span><br><span class="line">error_log &#x3D; &#x2F;var&#x2F;log&#x2F;php_error.log # 错误日志记录的位置</span><br><span class="line">date.timezone &#x3D; PRC # 时区调整,默认PRC, 建议调整为Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line">#;;;;;;;;;;;;;;;</span><br><span class="line"># File Uploads ;</span><br><span class="line">#;;;;;;;;;;;;;;;</span><br><span class="line">file_uploads &#x3D; On # 开启文件上传功能，默认启动</span><br><span class="line">upload_max_filesize &#x3D; 300M # 允许上传文件的最大大小</span><br><span class="line">post_max_size &#x3D; 300M # 允许客户端单个POST请求发送的最大数据</span><br><span class="line">max_file_uploads &#x3D; 20 # 允许同时上传的文件的最大数量</span><br><span class="line">memory_limit &#x3D; 128M # 每个脚本执行最大内存</span><br><span class="line"></span><br><span class="line">#&#x2F;etc&#x2F;php.ini优化配置如下</span><br><span class="line">sql.safe_mode &#x3D; Off</span><br><span class="line">post_max_size &#x3D; 300M</span><br><span class="line">upload_max_filesize &#x3D; 300M</span><br><span class="line">max_file_uploads &#x3D; 20</span><br><span class="line">memory_limit &#x3D; 128M</span><br><span class="line">date.timezone &#x3D; Asia&#x2F;Shanghai</span><br><span class="line"></span><br><span class="line">expose_php &#x3D; Off</span><br><span class="line">display_error &#x3D; Off</span><br><span class="line">error_reporting &#x3D; E_WARNING &amp; E_ERROR</span><br><span class="line">log_errors &#x3D; On</span><br><span class="line">error_log &#x3D; &#x2F;var&#x2F;log&#x2F;php_error.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#PHP 默认的会话处理程序会拖慢大型应用，因为这个处理程序会把会话数据存储在硬盘中，需要创建不必要的磁盘I&#x2F;O，浪费时间。我们应该把会话数据保存在内存中，例如可以使用 Memcached 或 Redis。这么做还有个额外好处 —— 以后便于伸缩。如果会话数据存储在硬盘中，不便于增加额外的服务器，如果把会话数据存放在 Memcached 或 Redis 里，任何一台分布式 PHP-FPM 服务器都能访问会话数据。如果想把会话数据保存在 Memcached 中，需要做如下配置：</span><br><span class="line">session.save_handler &#x3D; &#39;memcached&#39;</span><br><span class="line">session.save_path &#x3D; &#39;127.0.0.1:11211&#39;</span><br></pre></td></tr></table></figure>

<h3 id="etc-php-fpm-conf"><a href="#etc-php-fpm-conf" class="headerlink" title="/etc/php-fpm.conf"></a>/etc/php-fpm.conf</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#第一部分，fpm配置</span><br><span class="line">;include&#x3D;etc&#x2F;fpm.d&#x2F;*.conf</span><br><span class="line"></span><br><span class="line">#第二部分，全局配置</span><br><span class="line">[global]</span><br><span class="line">;pid &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;php-fpm.pid #pid文件存放的位置</span><br><span class="line">;error_log &#x3D; &#x2F;var&#x2F;log&#x2F;php-fpm&#x2F;php-fpm.log #错误日志存放的位置</span><br><span class="line">;log_level &#x3D; error #日志级别, alert, error, warning, notice, debug</span><br><span class="line">rlimit_files &#x3D; 65535 #php-fpm进程能打开的文件数</span><br><span class="line">events.mechanism &#x3D; epoll #使用epoll事件模型处理请求</span><br><span class="line"></span><br><span class="line">#第三部分，进程池定义</span><br><span class="line">[www] #池名称</span><br><span class="line">user &#x3D; www #进程运行的用户</span><br><span class="line">group &#x3D; www #进程运行的组</span><br><span class="line">;listen &#x3D; &#x2F;dev&#x2F;shm&#x2F;php-fpm.sock #监听在本地socket文件</span><br><span class="line">listen &#x3D; 127.0.0.1:9000 #监听在本地tcp的9000端口</span><br><span class="line">;listen.allowed_clients &#x3D; 127.0.0.1 #允许访问FastCGI进程的IP，any不限制</span><br><span class="line"></span><br><span class="line">; Choose how the process manager will control the number of child processes.</span><br><span class="line">; Possible Values:</span><br><span class="line">; static - a fixed number (pm.max_children) of child processes;</span><br><span class="line">; dynamic - the number of child processes are set dynamically based on the</span><br><span class="line">; following directives:</span><br><span class="line">; pm.max_children - the maximum number of children that can</span><br><span class="line">; be alive at the same time.</span><br><span class="line">; pm.start_servers - the number of children created on startup.</span><br><span class="line">; pm.min_spare_servers - the minimum number of children in &#39;idle&#39;</span><br><span class="line">; state (waiting to process). If the number</span><br><span class="line">; of &#39;idle&#39; processes is less than this</span><br><span class="line">; number then some children will be created.</span><br><span class="line">; pm.max_spare_servers - the maximum number of children in &#39;idle&#39;</span><br><span class="line">; state (waiting to process). If the number</span><br><span class="line">; of &#39;idle&#39; processes is greater than this</span><br><span class="line">; number then some children will be killed.</span><br><span class="line">; Note: This value is mandatory.</span><br><span class="line"></span><br><span class="line">pm &#x3D; dynamic #</span><br><span class="line">pm.max_children &#x3D; 512 #最大启动的php-fpm进程数</span><br><span class="line">pm.start_servers &#x3D; 32 #初始启动的php-fpm进程数</span><br><span class="line">pm.min_spare_servers &#x3D; 32 #最少的空闲php-fpm进程数</span><br><span class="line">pm.max_spare_servers &#x3D; 64 #最大的空闲php-fpm进程数</span><br><span class="line">pm.max_requests &#x3D; 1500 #每一个进程能响应的请求数</span><br><span class="line">pm.process_idle_timeout &#x3D; 15s;</span><br><span class="line"></span><br><span class="line"># 错误日志</span><br><span class="line">php_flag[display_errors] &#x3D; off</span><br><span class="line">php_admin_value[error_log] &#x3D; &#x2F;soft&#x2F;log&#x2F;php&#x2F;php-www_error.log</span><br><span class="line">php_admin_flag[log_errors] &#x3D; on</span><br><span class="line"></span><br><span class="line"># 将查询超过5s的连接记录至慢查询日志中</span><br><span class="line">request_slowlog_timeout &#x3D; 5s</span><br><span class="line">slowlog &#x3D; &#x2F;var&#x2F;log&#x2F;php&#x2F;slow.log</span><br></pre></td></tr></table></figure>

<h3 id="etc-php-fpm-d-www-conf"><a href="#etc-php-fpm-d-www-conf" class="headerlink" title="/etc/php-fpm.d/www.conf"></a>/etc/php-fpm.d/<a href="http://www.conf" target="_blank" rel="noopener">www.conf</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">pid &#x3D; &#x2F;var&#x2F;run&#x2F;php-fpm.pid</span><br><span class="line"></span><br><span class="line">error_log &#x3D; &#x2F;var&#x2F;log&#x2F;php&#x2F;php-fpm.log</span><br><span class="line">log_level &#x3D; warning</span><br><span class="line">rlimit_files &#x3D; 655350</span><br><span class="line">events.mechanism &#x3D; epoll</span><br><span class="line"></span><br><span class="line">[www]</span><br><span class="line">user &#x3D; nginx</span><br><span class="line">group &#x3D; nginx</span><br><span class="line">listen &#x3D; 127.0.0.1:9000</span><br><span class="line">listen.owner &#x3D; www</span><br><span class="line">listen.group &#x3D; www</span><br><span class="line">listen.mode &#x3D; 0660</span><br><span class="line"></span><br><span class="line">listen.allowed_clients &#x3D; 127.0.0.1</span><br><span class="line">pm &#x3D; dynamic</span><br><span class="line">pm.max_children &#x3D; 512</span><br><span class="line">pm.start_servers &#x3D; 10</span><br><span class="line">pm.min_spare_servers &#x3D; 10</span><br><span class="line">pm.max_spare_servers &#x3D; 30</span><br><span class="line">pm.process_idle_timeout &#x3D; 15s;</span><br><span class="line">pm.max_requests &#x3D; 2048</span><br><span class="line">pm.status_path &#x3D; &#x2F;phpfpm_status</span><br><span class="line"></span><br><span class="line">#php-www模块错误日志</span><br><span class="line">php_flag[display_errors] &#x3D; off</span><br><span class="line">php_admin_value[error_log] &#x3D; &#x2F;var&#x2F;log&#x2F;php&#x2F;php-www.log</span><br><span class="line">php_admin_flag[log_errors] &#x3D; on</span><br><span class="line"></span><br><span class="line">#php慢查询日志</span><br><span class="line">request_slowlog_timeout &#x3D; 5s</span><br><span class="line">slowlog &#x3D; &#x2F;var&#x2F;log&#x2F;php&#x2F;php-slow.log</span><br></pre></td></tr></table></figure>

<p>参考地址：</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/135865719" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/135865719</a></li>
</ul>
]]></content>
      <categories>
        <category>知识整理</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>http状态码</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/http%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<h3 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h3><ul>
<li>200    请求成功。一般用于get或post请求</li>
<li>201    已创建。成功请求并创建了新的资源</li>
<li>204    无内容。服务器成功处理，但未返回内容</li>
<li>301    永久移动。请求的资源被永久移动到新的地址</li>
<li>302    临时移动</li>
<li>400    客户端请求语法错误，服务器无法理解</li>
<li>401    请求需要用户的身份认证</li>
<li>403    服务器理解客户端的请求，但拒绝执行，没有权限</li>
<li>404    没有找到请求的资源</li>
<li>500    服务器内部错误</li>
<li>502    作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</li>
<li>503    超载或系统维护，服务器暂时无法处理客户端请求</li>
</ul>
<h3 id="状态码分类"><a href="#状态码分类" class="headerlink" title="状态码分类"></a>状态码分类</h3><table>
<thead>
<tr>
<th align="left">分类</th>
<th align="left">分类描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1**</td>
<td align="left">信息，服务器收到请求，需要请求者继续执行操作</td>
</tr>
<tr>
<td align="left">2**</td>
<td align="left">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td align="left">3**</td>
<td align="left">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td align="left">4**</td>
<td align="left">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td align="left">5**</td>
<td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody></table>
<h3 id="状态码列表"><a href="#状态码列表" class="headerlink" title="状态码列表"></a>状态码列表</h3><table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/" target="_blank" rel="noopener">客户端</a>应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">200</td>
<td align="left">OK</td>
<td align="left">请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td align="left">201</td>
<td align="left">Created</td>
<td align="left">已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td align="left">202</td>
<td align="left">Accepted</td>
<td align="left">已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td align="left">203</td>
<td align="left">Non-Authoritative Information</td>
<td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td align="left">204</td>
<td align="left">No Content</td>
<td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td align="left">205</td>
<td align="left">Reset Content</td>
<td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td align="left">206</td>
<td align="left">Partial Content</td>
<td align="left">部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">300</td>
<td align="left">Multiple Choices</td>
<td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td align="left">301</td>
<td align="left">Moved Permanently</td>
<td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td align="left">302</td>
<td align="left">Found</td>
<td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td align="left">303</td>
<td align="left">See Other</td>
<td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td align="left">304</td>
<td align="left">Not Modified</td>
<td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td align="left">305</td>
<td align="left">Use Proxy</td>
<td align="left">使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td align="left">306</td>
<td align="left">Unused</td>
<td align="left">已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td align="left">307</td>
<td align="left">Temporary Redirect</td>
<td align="left">临时重定向。与302类似。使用GET请求重定向</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">400</td>
<td align="left">Bad Request</td>
<td align="left">客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td align="left">401</td>
<td align="left">Unauthorized</td>
<td align="left">请求要求用户的身份认证</td>
</tr>
<tr>
<td align="left">402</td>
<td align="left">Payment Required</td>
<td align="left">保留，将来使用</td>
</tr>
<tr>
<td align="left">403</td>
<td align="left">Forbidden</td>
<td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td align="left">404</td>
<td align="left">Not Found</td>
<td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td align="left">405</td>
<td align="left">Method Not Allowed</td>
<td align="left">客户端请求中的方法被禁止</td>
</tr>
<tr>
<td align="left">406</td>
<td align="left">Not Acceptable</td>
<td align="left">服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td align="left">407</td>
<td align="left">Proxy Authentication Required</td>
<td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td align="left">408</td>
<td align="left">Request Time-out</td>
<td align="left">服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td align="left">409</td>
<td align="left">Conflict</td>
<td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td align="left">410</td>
<td align="left">Gone</td>
<td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td align="left">411</td>
<td align="left">Length Required</td>
<td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td align="left">412</td>
<td align="left">Precondition Failed</td>
<td align="left">客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td align="left">413</td>
<td align="left">Request Entity Too Large</td>
<td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td align="left">414</td>
<td align="left">Request-URI Too Large</td>
<td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td align="left">415</td>
<td align="left">Unsupported Media Type</td>
<td align="left">服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td align="left">416</td>
<td align="left">Requested range not satisfiable</td>
<td align="left">客户端请求的范围无效</td>
</tr>
<tr>
<td align="left">417</td>
<td align="left">Expectation Failed</td>
<td align="left">服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">500</td>
<td align="left">Internal Server Error</td>
<td align="left">服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td align="left">501</td>
<td align="left">Not Implemented</td>
<td align="left">服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td align="left">502</td>
<td align="left">Bad Gateway</td>
<td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td align="left">503</td>
<td align="left">Service Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td align="left">504</td>
<td align="left">Gateway Time-out</td>
<td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td align="left">505</td>
<td align="left">HTTP Version not supported</td>
<td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>php的abstract和interface区别</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/php%E7%9A%84abstract%E5%92%8Cinterface/</url>
    <content><![CDATA[<h2 id="abstract抽象类"><a href="#abstract抽象类" class="headerlink" title="abstract抽象类"></a>abstract抽象类</h2><ul>
<li>定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。（抽象类可以没有抽象方法，但是抽象类依然不能被实例化）被定义为抽象的方法只是声明了其调用方式（参数），<strong>不能</strong>定义其具体的功能实现</li>
<li>继承一个抽象类的时候，非抽象子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的</li>
<li>此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数（<em>类似function eat($a,$b=1)中的$b就是可选参数</em>），而父类抽象方法的声明里没有，则两者的声明并无冲突。这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的</li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><ol>
<li>抽象类可以有成员属性</li>
<li>人问：抽象方法是否可以定义为私有，答案是不可以，因为抽象接口的目的就是为了抽象出类模型用来继承，定义为私有，外部访问不到，偏移了设计目的</li>
<li>抽象类可以实现接口，且可以不实现其中的方法</li>
<li>抽象类可以继承抽象类，<strong>且不能</strong>重写抽象父类的抽象方法。这样的用法，可以理解为对抽象类的扩展</li>
</ol>
<h2 id="interface接口"><a href="#interface接口" class="headerlink" title="interface接口"></a>interface接口</h2><ul>
<li>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。</li>
<li>接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。</li>
<li>接口中定义的所有方法都必须是公有，这是接口的特性，protected和private会报错（<em>Fatal error: Access type for interface method</em>）。</li>
<li>常量：接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。(不建议这样用，实在想不到有什么意义，也容易产生和抽象类的混淆)</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><strong>抽象类：</strong>是基于类来说，其本身就是类，只是一种特殊的类，不能直接实例，可以在类里定义方法，属性。类似于模版，规范后让子类实现详细功能。</li>
<li><strong>接口：</strong>主要基于方法的规范，有点像抽象类里的抽象方法，只是其相对于抽象方法来说，更加独立。可让某个类通过组合多个方法来形成新的类</li>
</ul>
<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>1、都是用于声明某一种事物，规范名称、参数，形成模块，未有详细的实现细节。</p>
<p>2、都是通过类来实现相关的细节工作</p>
<p>3、语法上，抽象类的抽象方法与接口一样，不能有方法体，即｛｝符号</p>
<p>4、都可以用继承，接口可以继承接口形成新的接口，抽象类可以继承抽象类从而形成新的抽象类</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>1、抽象类可以有属性、普通方法、抽象方法，但接口不能有属性、普通方法、可以有常量</p>
<p>2、抽象类内未必有抽象方法，但接口内一定会有“抽象”方法</p>
<p>3、语法上有不同</p>
<p>4、抽象类用abstract关键字在类前声明，且有class声明为类，接口是用interface来声明，但不能用class来声明，因为接口不是类。</p>
<p>5、抽象类的抽象方法一定要用abstract来声明，而接口则不需要</p>
<p>6、抽象类是用extends关键字让子类继承父类后，在子类实现详细的抽象方法。而接口则是用implements让普通类在类里实现接口的详细方法，且接口可以一次性实现多个方法，用逗号分开各个接口就可</p>
<h3 id="各自的特点"><a href="#各自的特点" class="headerlink" title="各自的特点"></a>各自的特点</h3><p>抽象类内未必有抽象方法，但有抽象方法的类，则必是抽象类</p>
<p>抽象类内，即便全是具体方法，也不能够实例化，只要新建类来继承后，实例继承类才可以</p>
<p>接口可以让一个类一次性实现多个不同的方法</p>
<p>接口本身就是抽象的，但注意不是抽象类，因为接口不是类，只是其方法是抽象的。所以，其也是抽象的</p>
]]></content>
      <categories>
        <category>知识整理</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>网络协议</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="网络七层结构简介"><a href="#网络七层结构简介" class="headerlink" title="网络七层结构简介"></a>网络七层结构简介</h3><ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li>传输层</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
<p><img src="/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/1.png" alt="网络七层协议"></p>
<h3 id="tcp连接的三次握手和四次挥手的通俗理解"><a href="#tcp连接的三次握手和四次挥手的通俗理解" class="headerlink" title="tcp连接的三次握手和四次挥手的通俗理解"></a>tcp连接的三次握手和四次挥手的通俗理解</h3><ul>
<li>三次握手，以此确认两个方向上的数据传输通道是否正常<ol>
<li>客户端向服务端发送建立连接的信号，客户端进入<code>SYN_SENT</code>的状态</li>
<li>服务端收到消息后，向客户端发送一个随机产生确认消息，服务端进入<code>SYN_RCVD</code>状态</li>
<li>客户端收到确认消息后，向服务端发送本身合法的数据；服务端检测验证数据后链接建立成功</li>
</ol>
</li>
<li>四次挥手，断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开<ol>
<li>客户端向服务端发送关闭消息，用户关闭客户端到服务端的数据传送，客户端处于<code>FIN_WAIT_1</code>状态</li>
<li>服务端收到消息后向客户端发送等待通知的信号，检查是否发送完全部数据，服务端处于<code>close_wait</code>状态</li>
<li>服务端将全部数据发送完成后向客户端发送关闭信号，服务端进入<code>lsat_ack</code>状态</li>
<li>客户端收到消息后向服务端发送确认信号并关闭</li>
</ol>
</li>
</ul>
<h4 id="为什么要进行三次握手"><a href="#为什么要进行三次握手" class="headerlink" title="为什么要进行三次握手"></a>为什么要进行三次握手</h4><p>为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<h4 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢</h4><p>因为关闭连接时，当服务端收到对方的关闭通知时，仅仅表示客户端不再发送数据了但是还能接收数据，客户端也未必将全部数据都发送给对方了；所以服务端要先判断数据是否全部发送完毕再关闭</p>
<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p> HTTP协议（HyperText Transfer Protocol，超文本传输协议）是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>OPTIONS</li>
</ul>
<h4 id="GET和POST区别"><a href="#GET和POST区别" class="headerlink" title="GET和POST区别"></a>GET和POST区别</h4><ol>
<li>GET常用来请求资源，POST用来修改资源</li>
<li>POST的安全性要比GET的安全性高</li>
<li>POST可以比GET提交更多的数据；HTTP协议本身并没有对URL长度做限制，大部分的限制都是浏览器或服务器对他的限制</li>
</ol>
]]></content>
      <categories>
        <category>知识整理</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>php常用的输出函数及区别</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p><strong>PHP中几个输出函数echo，print()，print_r()，sprintf()，var_dump()的区别</strong></p>
<p>1：echo：是语句不是函数，没有返回值，可输出多个变量值，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。</p>
<p>2：print：是语句不是函数，有返回值 1 ，只能输出一个变量，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。</p>
<p>3：print_r：是函数，可以打印复合类型，例如：stirng、int、float、array、object等，输出array时会用结构表示，而且可以通过print_r($str,true)来使print_r不输出而返回print_r处理后的值</p>
<p>4：printf：是函数，把文字格式化以后输出（参看C语言）</p>
<p>5：sprintf：是函数，跟printf相似，但不打印，而是返回格式化后的文字（该函数把格式化的字符串写写入一个变量中，而不是输出来），其   他的与printf一样。 </p>
<p>例如： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 $str &#x3D; &quot;Hello&quot;;    </span><br><span class="line">2 $number &#x3D; 123; </span><br><span class="line">3 $txt &#x3D; sprintf(&quot;%s world. Day number %u&quot;,$str,$number)；</span><br><span class="line">4 &#x2F;&#x2F;输出： Hello world. Day number 123</span><br></pre></td></tr></table></figure>

<p>6：var_dump()：函数，输出变量的内容、类型或字符串的内容、类型、长度。常用来调试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以通过function_exists(&#39;函数名称&#39;)进行测试</span><br><span class="line">1 var_dump(function_exists(&#39;print&#39;));  &#x2F;&#x2F;bool(false)</span><br><span class="line">2 </span><br><span class="line">3 var_dump(function_exists(&#39;echo&#39;));  &#x2F;&#x2F;bool(false)</span><br><span class="line">4 </span><br><span class="line">5 var_dump(function_exists(&#39;print_r&#39;)); &#x2F;&#x2F;bool(true)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>PHP面向对象设计五大原则</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>SOLID 是 <strong>面向对象编程</strong> 和 <strong>面试对象设计</strong> 的五个基本原则，应用这五个原则能创建一个易于维护和扩展的软件系统。</p>
<table>
<thead>
<tr>
<th align="center">首字母 - 简写（全称）</th>
<th align="center">指代</th>
<th align="center">概念</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S-SRP(Single Responsibility Principle)</td>
<td align="center">单一功能原则</td>
<td align="center">对象应该仅具有一种单一功能</td>
</tr>
<tr>
<td align="center">O-OCP(Opened Closed Principle)</td>
<td align="center">开闭原则</td>
<td align="center">软件应该是对于扩展开放的，但对于修改封闭的</td>
</tr>
<tr>
<td align="center">L-LSP(Liskov Substitution Principle)</td>
<td align="center">里氏替换原则</td>
<td align="center">程序中的对象应该是可以在不改变程序正确性的前提下被他的子类所替换</td>
</tr>
<tr>
<td align="center">I-ISP(Interface Segregation Principle)</td>
<td align="center">接口隔离原则</td>
<td align="center">多个特定客户端接口要好于一个宽泛用途的接口</td>
</tr>
<tr>
<td align="center">D-DIP(Dependency Inversion Principle)</td>
<td align="center">依赖反转原则</td>
<td align="center">一个方法应该遵从「依赖于抽象而不是一个实例」</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table>
<thead>
<tr>
<th>SRP</th>
<th>单一职责原则</th>
<th>一个类有且只有一个更改的原因</th>
</tr>
</thead>
<tbody><tr>
<td>OCP</td>
<td>开闭原则</td>
<td>能够不更改类而扩展类的行为</td>
</tr>
<tr>
<td>LSP</td>
<td>里氏替换原则</td>
<td>派生类可以替换基类使用</td>
</tr>
<tr>
<td>ISP</td>
<td>接口隔离原则</td>
<td>使用客户端特定的细粒度接口</td>
</tr>
<tr>
<td>DIP</td>
<td>依赖反转原则</td>
<td>依赖抽象而不是具体实现</td>
</tr>
</tbody></table>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li><strong>单一职责（SRP）</strong>如何正确的划分职责，类的职责单一提高代码复用性，降低耦合性</li>
<li><strong>接口隔离（ISP）</strong>合理划分接口功能，保证接口的专一性，纯洁性，减少依赖关系</li>
<li><strong>里氏替换（LSP）</strong>合理利用类的继承体系，保证正确的继承关系不被破坏</li>
<li><strong>依赖倒置（DIP）</strong>抽象接口编程由于抽象具体实现</li>
<li><strong>开放封闭（OCP）</strong>面向对象编程终极目标所达到的结果，类/模块/系统的功能行为可扩展，内部更改性是封闭的</li>
</ul>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h5 id="定义与特性"><a href="#定义与特性" class="headerlink" title="定义与特性"></a>定义与特性</h5><ul>
<li>仅有一个引起类变化的原因，即一个类只承担一项职责</li>
<li>避免相同的职责分散到不同的类中，造成功能重复</li>
</ul>
<h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><ul>
<li><strong>减少类之间的耦合</strong>：当需求变化时，只修改一个类，从而隔离了变化带来类对其他职责的影响</li>
<li><strong>提高类的复用性</strong>：按需引用，一个类负责一个职责，需求的变动只需要修改对应的类或增加某一职责</li>
<li><strong>降低类的复杂度</strong>：职责单一，功能分散开降低一个类多个职责类的复杂度</li>
</ul>
<p>在实际代码开发中的应用：工厂模式、命令模式、代理模式等。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h5 id="定义，特性"><a href="#定义，特性" class="headerlink" title="定义，特性"></a>定义，特性</h5><ul>
<li>客户端不应该依赖他们不需要的方法/功能</li>
<li>一个类对一个类的依赖应该建立在最小的接口上</li>
<li>接口的实现类应该只呈现为单一职责原则</li>
</ul>
<h5 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a>优势：</h5><ul>
<li>将胖接口分离，每一组接口提供特定功能服务于特定一组的客户端程序</li>
<li>对一组接口的更改不会/较小的影响到其他的接口/客户端程序，保证接口的纯洁性</li>
</ul>
<h5 id="单一职责和接口隔离比较"><a href="#单一职责和接口隔离比较" class="headerlink" title="单一职责和接口隔离比较"></a>单一职责和接口隔离比较</h5><ul>
<li>都是解决软件设计中依赖关系原则</li>
<li>SRP 注重职责的划分，主要约束类，其实是接口和方法，是程序中的细节和实现。ISP 注重接口的隔离，约束的是接口，从更宏观的角度对接口的抽象设计</li>
</ul>
<h2 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h2><h5 id="定义，特性-1"><a href="#定义，特性-1" class="headerlink" title="定义，特性"></a>定义，特性</h5><ul>
<li>一个模块在扩展行为方面应该是开放的而在更改性方面应该是封闭的</li>
</ul>
<h5 id="优势：-2"><a href="#优势：-2" class="headerlink" title="优势："></a>优势：</h5><ul>
<li>模块的行为是可扩展的，可以方便的对现有模块的行为/功能进行扩展</li>
<li>对于模块行为的扩展不会/较小的影响现有系统/模块</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>OCP核心思想就是抽象接口编程，抽象相对稳定。让类依赖与固定的抽象，通过面向对象的继承和多态让类继承抽象，复写其方法或固有行为，是想新的扩展方法/功能，实现扩展。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h5 id="定义，特性-2"><a href="#定义，特性-2" class="headerlink" title="定义，特性"></a>定义，特性</h5><ul>
<li><strong>子类必须能够替换掉他们的基类型</strong>：任何出现基类的地方都可以替换成子类并且客户端程序不会改变基类行为或者出现异常和错误，反之不行。</li>
<li>客户端程序只应该使用子类的抽象父类，这样可以实现动态绑定（php多态）</li>
</ul>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>LSP是OCP得以应用的最主要的原则之一，正是因为子类性的可替换行是的基类类型在无需修改的情况下扩展功能。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><h5 id="定义，特性-3"><a href="#定义，特性-3" class="headerlink" title="定义，特性"></a>定义，特性</h5><ul>
<li>高层模块不应该依赖与底层模块，二者都应该依赖于抽象</li>
<li>抽象不应该依赖与细节，细节应该依赖于抽象</li>
</ul>
<h5 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h5><p>DIP原则就是每个高层次模块定义一个它所需服务的接口声明，低层次模块实现这个接口。每个高层次类通过该抽象接口使用服务。</p>
]]></content>
      <categories>
        <category>知识整理</category>
      </categories>
      <tags>
        <tag>知识整理</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的设计模式</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>单例模式</td>
<td>类只允许被创建一次</td>
</tr>
<tr>
<td>工厂模式</td>
<td>通过工厂方法或类生成对象，而不是在代码中直接new</td>
</tr>
<tr>
<td>适配器模式</td>
<td>将某个对象的接口适配成另一个对象所期望的接口（不同的数据库适配）</td>
</tr>
<tr>
<td>装饰器模式</td>
<td>类作为参数，并修改这个操作类的数据；这样在操作类执行最终输出方法前，只需要实例化装饰器类，无需修改原来代码即可达到需求更改的目的</td>
</tr>
<tr>
<td>观察者模式</td>
<td>当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新</td>
</tr>
<tr>
<td>策略模式</td>
<td>将一组特定的行为和算法封装成类，以适应某些特定的上下文环境</td>
</tr>
<tr>
<td>原型模式</td>
<td>对象克隆以避免创建对象时的消耗</td>
</tr>
</tbody></table>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>定义：</p>
<p>使某个类的对象仅允许创建一次</p>
<p>构造函数，析构函数和克隆函数都必须私有，使用private定义；声明一个static的getInstance方法，在该方法中创建该对象的实例。如果实例已存在，则不创建。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class InventoryConnection&#123;</span><br><span class="line">    protected static $_instance &#x3D; NULL;</span><br><span class="line">    protected $_handle &#x3D; NULL;</span><br><span class="line">    </span><br><span class="line">    public static function getInstance()&#123;</span><br><span class="line">        if(!self::$_instance instanceof self)&#123;</span><br><span class="line">            self::$_instance &#x3D; new self;</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    protected function __construct()&#123;</span><br><span class="line">        $this-&gt;_handle &#x3D; mysql_connect(&#39;localhost&#39;,&#39;user&#39;,&#39;pass&#39;);</span><br><span class="line">        mysql_select_db(&#39;CD&#39;,$this-&gt;_handle);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public function updateQuantity($band,$title,$number)&#123;</span><br><span class="line">        $query &#x3D; &quot;update CDs set amount&#x3D;amount+&quot;.intval($number);</span><br><span class="line">        $query .&#x3D; &quot; where band&#x3D;&#39;&quot;.mysql_real_escape_string($band).&quot;&#39;&quot;;</span><br><span class="line">        $query .&#x3D; &quot; and title&#x3D;&#39;&quot;.mysql_real_excape_string($title).&quot;&#39;&quot;;</span><br><span class="line">        </span><br><span class="line">        mysql_query($query,$this-&gt;_handle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>个人理解：相当于实例化一个第三方类的类</p>
<p>工厂模式，工厂方法或者类生成对象，而不是在代码中直接new。<br>使用工厂模式，可以避免当改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。</p>
<p>工厂模式提供获取某个对象的新实例的一个接口，同时使调用代码避免重复实例化基类的步骤</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test1&#123;</span><br><span class="line">    static function test()&#123;</span><br><span class="line">        echo __FILE__;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Factory&#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 如果某个类在很多的文件中都new ClassName()，那么万一这个类的名字</span><br><span class="line">     * 发生变更或者参数发生变化，如果不使用工厂模式，就需要修改每一个PHP</span><br><span class="line">     * 代码，使用了工厂模式之后，只需要修改工厂类或者方法就可以了。</span><br><span class="line">     *&#x2F;</span><br><span class="line">    static function createDatabase()&#123;</span><br><span class="line">        $test &#x3D; new Test1();</span><br><span class="line">        return $test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$test &#x3D; Factory::createDatabase();</span><br><span class="line">$test-&gt;test();</span><br></pre></td></tr></table></figure>

<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>个人理解：调用相似的不同种类的api时，继承一个统一的接口，使用同样的方法封装不同类的操作方法</p>
<p>将各种截然不同的函数接口封装成统一的API</p>
<p>将某个对象的接口适配为另一个对象所期望的接口</p>
<p>例如：PHP中的数据库操作有MySQL,MySQLi,PDO三种，可以用适配器模式统一成一致，使不同的数据库操作，统一成一样的API。类似的场景还有cache适配器，可以将memcache,redis,file,apc等不同的缓存函数，统一成一致。 </p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    function connect($host, $user, $passwd, $dbname);</span><br><span class="line">    function query($sql);</span><br><span class="line">    function close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MySQL</span><br><span class="line">class MySQL implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    protected $conn;</span><br><span class="line">    function connect($host, $user, $passwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        $conn &#x3D; mysql_connect($host, $user, $passwd);</span><br><span class="line">        mysql_select_db($dbname, $conn);</span><br><span class="line">        $this-&gt;conn &#x3D; $conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        $res &#x3D; mysql_query($sql, $this-&gt;conn);</span><br><span class="line">        return $res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        mysql_close($this-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MySQLi</span><br><span class="line">class MySQLi implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    protected $conn;</span><br><span class="line"></span><br><span class="line">    function connect($host, $user, $passwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        $conn &#x3D; mysqli_connect($host, $user, $passwd, $dbname);</span><br><span class="line">        $this-&gt;conn &#x3D; $conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        return mysqli_query($this-&gt;conn, $sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        mysqli_close($this-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; PDO</span><br><span class="line">class PDO implements IDatabase</span><br><span class="line">&#123;</span><br><span class="line">    protected $conn;</span><br><span class="line">    function connect($host, $user, $passwd, $dbname)</span><br><span class="line">    &#123;</span><br><span class="line">        $conn &#x3D; new \PDO(&quot;mysql:host&#x3D;$host;dbname&#x3D;$dbname&quot;, $user, $passwd);</span><br><span class="line">        $this-&gt;conn &#x3D; $conn;</span><br><span class="line">    &#125;</span><br><span class="line">function query($sql)</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;conn-&gt;query($sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function close()</span><br><span class="line">    &#123;</span><br><span class="line">        unset($this-&gt;conn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上案例，PHP与MySQL的数据库交互有三套API，在不同的场景下可能使用不同的API，那么开发好的代码，换一个环境，可能就要改变它的数据库API，那么就要改写所有的代码，使用适配器模式之后，就可以使用统一的API去屏蔽底层的API差异带来的环境改变之后需要改写代码的问题。</p>
<h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>个人理解：增加一个类，对原有类的功能进行改变；实例化一个要操作的类，比如这个类的功能是返回输入的字符（输入的字符保存在类变量中）；现在需要对这个类的需求进行更改，此时新建一个类，这个人接受实例化的操作类作为参数，并修改这个操作类的数据；这样在操作类执行最终输出方法前，只需要实例化装饰器类，无需更改原来代码即可达到需求更改的目的</p>
<p>1：装饰器模式，可以动态的添加修改类的功能<br>2：一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重写实现类的方法<br>3：使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大额灵活性</p>
<p>如果已有对象的部分内容或功能性发生改变，但是不需要修改原始对象的结构，那么使用装饰器设计模式最合适</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CD&#123;</span><br><span class="line">    public $trackList;</span><br><span class="line">    public function __construct()&#123;</span><br><span class="line">        $this-&gt;trackList &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line">    public function addTrack($track)&#123;</span><br><span class="line">        $this-&gt;trackList[] &#x3D; $track;</span><br><span class="line">    &#125;</span><br><span class="line">    public function getTrackList()&#123;</span><br><span class="line">        $output &#x3D; &#39;&#39;;</span><br><span class="line">        foreach($this-&gt;trackList as $num&#x3D;&gt;$track)&#123;</span><br><span class="line">            $output .&#x3D; ($num+1).&quot;) &#123;$track&#125;. &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return $output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$tracksFromExternalSource &#x3D; [&#39;What It Means&#39;,&#39;Brr&#39;,&#39;Goodbye&#39;];</span><br><span class="line"></span><br><span class="line">$myCD &#x3D; new CD();</span><br><span class="line"></span><br><span class="line">foreach($tracksFromExternalSource as $track)&#123;</span><br><span class="line">    $myCD-&gt;addTrack($track);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print &quot;The CD contains&quot;.$myCD-&gt;getTrackList();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更改需求，要求输出的内容全部大写</span><br><span class="line"></span><br><span class="line">class CDTrackListDecoratorCaps&#123;</span><br><span class="line">    private $_cd;</span><br><span class="line">    public function __construct(CD $cd)&#123;</span><br><span class="line">        $this-&gt;_cd &#x3D; $cd;</span><br><span class="line">    &#125;</span><br><span class="line">    public function makeCaps()&#123;</span><br><span class="line">        foreach($this-&gt;_cd-&gt;trackList as &amp;$strack)&#123;</span><br><span class="line">            $track &#x3D; strtoupper($track);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myCD &#x3D; new CD();</span><br><span class="line"></span><br><span class="line">foreach($tracksFromExternalSource as $track)&#123;</span><br><span class="line">    $myCD-&gt;addTrack($track);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$myCDCaps &#x3D; new CDTrackListDecoratorCaps($myCD);</span><br><span class="line">$myCDCaps-&gt;makeCaps();</span><br><span class="line"></span><br><span class="line">print &quot;The CD contains the following tracks: &quot;.$myCD-&gt;getTrackList();</span><br></pre></td></tr></table></figure>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>个人理解：相当于将各个不同的类的操作方法都继承于一个统一的接口；在这个接口中注册所有的类实例，当接到触发方法后，循环处理这个接口中所有类实例的对应方法</p>
<p>1：观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。<br>2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。<br>3：观察者模式实现了低耦合，非侵入式的通知与更新机制。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义一个事件触发抽象类</span><br><span class="line">abstract class EventGenerator&#123;</span><br><span class="line">    private $observers &#x3D; array();</span><br><span class="line">    function addObserver(Observer $observer)&#123;</span><br><span class="line">        $this-&gt;observers[]&#x3D;$observer;</span><br><span class="line">    &#125;</span><br><span class="line">    function notify()&#123;</span><br><span class="line">        foreach ($this-&gt;observers as $observer)&#123;</span><br><span class="line">            $observer-&gt;update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义一个观察者接口</span><br><span class="line">interface Observer&#123;</span><br><span class="line">    function update();&#x2F;&#x2F;这里就是在事件发生后要执行的逻辑</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;一个实现了EventGenerator抽象类的类，用于具体定义某个发生的事件</span><br><span class="line">class Event extends EventGenerator&#123;</span><br><span class="line">    function triger()&#123;</span><br><span class="line">        echo &quot;Event&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现了观察者接口的类</span><br><span class="line">class Observer1 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑1&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现了观察者接口的类</span><br><span class="line">class Observer2 implements Observer&#123;</span><br><span class="line">    function update()&#123;</span><br><span class="line">        echo &quot;逻辑2&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$event &#x3D; new Event();</span><br><span class="line">$event-&gt;addObserver(new Observer1());</span><br><span class="line">$event-&gt;addObserver(new Observer2());</span><br><span class="line">$event-&gt;triger();</span><br><span class="line">$event-&gt;notify();</span><br></pre></td></tr></table></figure>

<p>当某个事件发生后，需要执行的逻辑增多时，可以以松耦合的方式去增删逻辑。也就是观察者接口的方法，只需要定义一个实现了观察者接口的类，实现复杂的逻辑，然后在观察者接口增加对应的方法即可。这样实现了低耦合。</p>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>个人理解：将不同模式【策略】下的操作方法抽象成不同的类；在执行代码中根据模式调用不同的类</p>
<p>策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。<br>示例：假如有一个电商网站系统，针对男性女性用户要各自跳转到不同的商品类目，并且所有的广告位展示不同的广告。在传统的代码中，都是在系统中加入各种if else的判断，硬编码的方式。如果有一天增加了一种用户，就需要改写代码。使用策略模式，如果新增加一种用户类型，只需要增加一种策略就可以。其他所有的地方只需要使用不同的策略就可以。<br>首先声明策略的接口文件，约定了策略的包含的行为。然后，定义各个具体的策略实现类。</p>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 声明策略文件的接口，约定策略包含的行为。</span><br><span class="line"> *&#x2F;</span><br><span class="line">interface UserStrategy</span><br><span class="line">&#123;</span><br><span class="line">    function showAd();</span><br><span class="line">    function showCategory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FemaleUser implements UserStrategy</span><br><span class="line">&#123;</span><br><span class="line">    function showAd()&#123;</span><br><span class="line">        echo &quot;2016冬季女装&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function showCategory()&#123;</span><br><span class="line">        echo &quot;女装&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MaleUser implements UserStrategy</span><br><span class="line">&#123;</span><br><span class="line">    function showAd()&#123;</span><br><span class="line">        echo &quot;IPhone6s&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function showCategory()&#123;</span><br><span class="line">        echo &quot;电子产品&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page</span><br><span class="line">&#123;</span><br><span class="line">    protected $strategy;</span><br><span class="line">    function index()&#123;</span><br><span class="line">        echo &quot;AD&quot;;</span><br><span class="line">        $this-&gt;strategy-&gt;showAd();</span><br><span class="line">        echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">        echo &quot;Category&quot;;</span><br><span class="line">        $this-&gt;strategy-&gt;showCategory();</span><br><span class="line">        echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    function setStrategy(UserStrategy $strategy)&#123;</span><br><span class="line">        $this-&gt;strategy&#x3D;$strategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$page &#x3D; new Page();</span><br><span class="line">if(isset($_GET[&#39;male&#39;]))&#123;</span><br><span class="line">    $strategy &#x3D; new MaleUser();</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    $strategy &#x3D; new FemaleUser();</span><br><span class="line">&#125;</span><br><span class="line">$page-&gt;setStrategy($strategy);</span><br><span class="line">$page-&gt;index();</span><br></pre></td></tr></table></figure>

<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>个人理解：很类似于单例模式，对象只初始化一次；原型通过clone的方式使得对象可以有不同的状态；而单例只会有一种状态</p>
<p>原型模式（对象克隆以避免创建对象时的消耗）<br>1：与工厂模式类似，都是用来创建对象。<br>2：与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。<br>3：原型模式适用于大对象的创建，创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需要内存拷贝即可。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Canvas&#123;</span><br><span class="line">	private $data;</span><br><span class="line">	function init($width &#x3D; 20, $height &#x3D; 10)</span><br><span class="line">    &#123;</span><br><span class="line">        $data &#x3D; array();</span><br><span class="line">        for($i &#x3D; 0; $i &lt; $height; $i++)</span><br><span class="line">        &#123;</span><br><span class="line">            for($j &#x3D; 0; $j &lt; $width; $j++)</span><br><span class="line">            &#123;</span><br><span class="line">                $data[$i][$j] &#x3D; &#39;*&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        $this-&gt;data &#x3D; $data;</span><br><span class="line">    &#125;</span><br><span class="line">	function rect($x1, $y1, $x2, $y2)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach($this-&gt;data as $k1 &#x3D;&gt; $line)</span><br><span class="line">        &#123;</span><br><span class="line">            if ($x1 &gt; $k1 or $x2 &lt; $k1) continue;</span><br><span class="line">           foreach($line as $k2 &#x3D;&gt; $char)</span><br><span class="line">            &#123;</span><br><span class="line">              if ($y1&gt;$k2 or $y2&lt;$k2) continue;</span><br><span class="line">                $this-&gt;data[$k1][$k2] &#x3D; &#39;#&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function draw()&#123;</span><br><span class="line">        foreach ($this-&gt;data as $line)&#123;</span><br><span class="line">            foreach ($line as $char)&#123;</span><br><span class="line">                echo $char;</span><br><span class="line">            &#125;</span><br><span class="line">            echo &quot;&lt;br&gt;;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$c &#x3D; new Canvas();</span><br><span class="line">$c-&gt;init();</span><br><span class="line">&#x2F; $canvas1 &#x3D; new Canvas();</span><br><span class="line">&#x2F;&#x2F; $canvas1-&gt;init();</span><br><span class="line">$canvas1 &#x3D; clone $c;&#x2F;&#x2F;通过克隆，可以省去init()方法，这个方法循环两百次</span><br><span class="line">&#x2F;&#x2F;去产生一个数组。当项目中需要产生很多的这样的对象时，就会new很多的对象，那样</span><br><span class="line">&#x2F;&#x2F;是非常消耗性能的。</span><br><span class="line">$canvas1-&gt;rect(2, 2, 8, 8);</span><br><span class="line">$canvas1-&gt;draw();</span><br><span class="line">echo &quot;-----------------------------------------&lt;br&gt;&quot;;</span><br><span class="line">&#x2F;&#x2F; $canvas2 &#x3D; new Canvas();</span><br><span class="line">&#x2F;&#x2F; $canvas2-&gt;init();</span><br><span class="line">$canvas2 &#x3D; clone $c;</span><br><span class="line">$canvas2-&gt;rect(1, 4, 8, 8);</span><br><span class="line">$canvas2-&gt;draw();</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>常用的正则表达式</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E5%B8%B8%E7%94%A8%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<ul>
<li>Email地址：<strong>^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$</strong></li>
<li>域名：<strong>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+.?</strong></li>
<li>InternetURL：<strong>[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$</strong></li>
<li>手机号码：<strong>^(13[0-9]|14[5|7]|15[0|1|2|3|4|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</strong></li>
<li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<strong>^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$</strong></li>
<li>国内电话号码(0511-4405222、021-87888822)：<strong>\d{3}-\d{8}|\d{4}-\d{7}</strong></li>
<li>电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: <strong>((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)</strong></li>
<li>身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：<strong>(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)</strong></li>
<li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<strong>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</strong></li>
<li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<strong>^[a-zA-Z]\w{5,17}$</strong></li>
<li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])[a-zA-Z0-9]{8,10}$</strong></li>
<li>强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：<strong>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</strong></li>
<li>日期格式：<strong>^\d{4}-\d{1,2}-\d{1,2}</strong></li>
<li>一年的12个月(01～09和1～12)：<strong>^(0?[1-9]|1[0-2])$</strong></li>
<li>一个月的31天(01～09和1～31)：<strong>^((0?[1-9])|((1|2)[0-9])|30|31)$</strong></li>
<li>钱的输入格式：<ol>
<li>有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：<strong>^[1-9][0-9]*$</strong></li>
<li>这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：<strong>^(0|[1-9][0-9]*)$</strong></li>
<li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<strong>^(0|-?[1-9][0-9]*)$</strong></li>
<li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：<strong>^[0-9]+(.[0-9]+)?$</strong></li>
<li>必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：<strong>^[0-9]+(.[0-9]{2})?$</strong></li>
<li>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：<strong>^[0-9]+(.[0-9]{1,2})?$</strong></li>
<li>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：<strong>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</strong></li>
<li>1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：<strong>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</strong></li>
<li>备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</li>
</ol>
</li>
<li>xml文件：<strong>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$</strong></li>
<li>中文字符的正则表达式：<strong>[\u4e00-\u9fa5]</strong></li>
<li>双字节字符：<strong>[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</strong></li>
<li>空白行的正则表达式：<strong>\n\s*\r (可以用来删除空白行)</strong></li>
<li>HTML标记的正则表达式：<strong>&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; ( 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</strong></li>
<li>腾讯QQ号：<strong>[1-9][0-9]{4,} (腾讯QQ号从10000开始)</strong></li>
<li>中国邮政编码：<strong>[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)</strong></li>
<li>IP地址：<strong>((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>魔术方法与常量</title>
    <url>/2020/01/18/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/php/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>方法：<code>__construct()</code>，<code>__destruct()</code>。   </p>
<p>方法重载：<code>__call()</code>，<code>__callStatic()</code>。</p>
<p>属性重载：<code>__get()</code>，<code>__set()</code>，<code>__isset()</code>，<code>__unset()</code> //这四个只对类中私有受保护的成员属性有效</p>
<p><code>__toString()</code>，<code>__autoload()</code>;</p>
<p><code>__set_state()</code>； //自 PHP 5.1.0 起当调用 var_export() 导出类时，此静态 方法会被调用。 本方法的唯一参数是一个数组。</p>
<p><code>__clone()</code>;    //通常用于对副本进行重新初始化，</p>
<p>说明：this指副本对象引用，that指原对象引用 等方法在 PHP 中被称为”魔术方法”。PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。</p>
<p>常量：</p>
<p><code>__LINK__</code>   //文件中的当前行号。</p>
<p><code>__FILE__</code>   //文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p>
<p><code>__DIR__</code>    //文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录，它等价于 <code>dirname(__FILE__)</code>。</p>
<p><code>__FUNCTION__</code>   //函数名称。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</p>
<p> <code>__CLASS__</code>      //类的名称。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</p>
<p><code>__METHOD__</code>     //类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写</p>
<p><code>__NAMESPACE__</code>  //当前命名空间的名称（大小写敏感）。这个常量是在编译时定义的（PHP 5.3.0 新增）</p>
<ol>
<li><p>__construct()，类的构造函数</p>
<p>通常构造方法被用来执行一些有用的初始化任务</p>
</li>
<li><p>__destruct()，类的析构函数</p>
<p>析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。</p>
</li>
<li><p>__call()，在对象中调用一个不可访问方法时调用</p>
</li>
<li><p>__callStatic()，用静态方式中调用一个不可访问方法时调用</p>
</li>
<li><p>__get()，获得一个类的成员变量时调用</p>
</li>
<li><p>__set()，设置一个类的成员变量时调用</p>
</li>
<li><p>__isset()，当对不可访问属性调用isset()或empty()时调用</p>
</li>
<li><p>__unset()，当对不可访问属性调用unset()时被调用。</p>
</li>
<li><p>__sleep()，执行<code>serialize()</code>时，先会调用这个函数</p>
<p>__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。</p>
<p><code>serialize()</code> 函数会检查类中是否存在一个魔术方法 <code>__sleep()</code>。如果存在，则该方法会优先被调用，然后才执行序列化操作。</p>
<p>此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。</p>
<p>如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。</p>
<p>__sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。</p>
</li>
<li><p>__wakeup()，执行unserialize()时，先会调用这个函数</p>
<p>__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</p>
</li>
<li><p>__toString()，类被当成字符串时的回应方法</p>
</li>
<li><p>__invoke()，调用函数的方式调用一个对象时的回应方法</p>
</li>
<li><p>__set_state()，调用var_export()导出类时，此静态方法会被调用。</p>
</li>
<li><p>__clone()，当对象复制完成时调用</p>
</li>
<li><p>__autoload()，尝试加载未定义的类</p>
</li>
<li><p>__debugInfo()，打印所需调试信息</p>
</li>
</ol>
]]></content>
  </entry>
</search>
